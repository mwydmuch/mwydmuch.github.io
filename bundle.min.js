/*!
 * mwydmuch.pl v21
 * Copyright 2024 Marek Wydmuch
 */

!function s(a,r,n){function h(e,t){if(!r[e]){if(!a[e]){var i="function"==typeof require&&require;if(!t&&i)return i(e,!0);if(o)return o(e,!0);throw new Error("Cannot find module '"+e+"'")}t=r[e]={exports:{}};a[e][0].call(t.exports,function(t){var i=a[e][1][t];return h(i||t)},t,t.exports,s,a,r,n)}return r[e].exports}for(var o="function"==typeof require&&require,t=0;t<n.length;t++)h(n[t]);return h}({1:[function(t,i,e){i.exports=class{constructor(){this.queue=[]}push(t){this.queue.push({step:t,time:0})}step(t){let i=t;for(;this.queue.length&&0<i;){var e=this.queue[0];e.time+=t,0<=(i=e.step(e.time))&&this.queue.shift()}return i}clear(){this.queue=[]}}},{}],2:[function(require,module,exports){let Noise=require("./noise"),Utils=require("./utils");class Animation{constructor(t,i,e,s,a="",r="",n="",h="random",o="2d"){console.log(`Starting ${a} animation`),this.canvas=t,null!==o&&(this.ctx=t.getContext(o,{alpha:!1}),this.ctx?console.log(o+" context obtained successfully"):console.error(`Unable to initialize ${o} context. Your browser may not support it.`)),this.colors=i,this.colorsAlt=e,this.bgColor=s,this.colorA=i[0],this.colorB=i[3],this.name=a,this.file=r,this.description=n,this.time=0,this.frame=0,this.speed=1,this.noise=Noise.noise,this.rand=null,this.maxSeedValue=999999,this.seed=this.assignIfRandom(h,Math.round(Math.random()*this.maxSeedValue)),this.setSeed(this.seed),this.resetFont(),this.debug=!1}resetFont(){this.ctx&&(this.ctx.font="14px sans-serif",this.ctx.lineWidth=2,this.ctx.textAlign="left",this.ctx.textBaseline="alphabetic",this.ctx.fillStyle=this.colors[0],this.ctx.strokeStyle=this.bgColor,this.lineHeight=20)}drawTextLines(i,e,s,a=!1){for(let t=0;t<i.length;++t){var r,n=i[t],h=this.ctx.measureText(n),o=s+(t+1)*this.lineHeight;a&&(r=this.ctx.fillStyle,this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(e,o-this.lineHeight,h.width,this.lineHeight),this.ctx.fillStyle=r),Utils.fillAndStrokeText(this.ctx,n,e,o)}}setSeed(t){this.noise.seed(t/this.maxSeedValue),this.rand=Utils.Mulberry32(t)}assignIfRandom(t,i){return"random"===t?i:t}clear(){Utils.clear(this.ctx,this.bgColor)}fadeOut(t){"#000000"==this.bgColor?this.blendColorAlpha(this.bgColor,t,"darker"):this.blendColorAlpha(this.bgColor,t,"lighter")}blendColorAlpha(t,i,e){i<=5e-4&&this.frame%20==0?Utils.blendColor(this.ctx,t,20*i,e):i<=.001&&this.frame%10==0?Utils.blendColor(this.ctx,t,10*i,e):i<=.005&&this.frame%2==0?Utils.blendColor(this.ctx,t,2*i,e):Utils.blendColor(this.ctx,t,i,e)}getName(){return this.name}getCodeUrl(){return"https://github.com/mwydmuch/mwydmuch.github.io/blob/master/js/animations"+this.file}getDescription(){return this.description}update(t){this.time+=t/1e3*this.speed,++this.frame}resize(){}updateColors(t,i,e){this.colors=t,this.colorsAlt=i,this.bgColor=e,this.colorA=t[0],this.colorB=t[3]}restart(){this.time=0,this.frame=0,this.setSeed(this.seed),this.resize()}getSettings(){return[]}getSeedSettings(t="restart"){return{prop:"seed",icon:'<i class="fa-solid fa-seedling"></i>',type:"int",min:0,max:this.maxSeedValue,toCall:t}}mouseAction(t,i){}setSettings(newSettings){for(var setting of this.getSettings())if(newSettings.has(setting.prop)){let value=newSettings.get(setting.prop);"int"===setting.type?value=parseInt(value):"float"===setting.type?value=parseFloat(value):"bool"===setting.type&&(value="true"===value),eval(`this.${setting.prop} = value;`)}this.restart()}getURLParams(){let url="";for(var setting of this.getSettings())0<url.length&&(url+="&"),url+=setting.prop+"="+eval(`this.${setting.prop};`);return url}}module.exports=Animation},{"./noise":36,"./utils":40}],3:[function(t,i,e){var s=t("../animation");t("../utils");class a extends s{constructor(t,i,e,s,a=30,r=8,n=-20,h=!1,o=1,l=!1,c=!1){super(t,i,e,s,"3n + 1 (Collatz Conjecture) visualization","3n+1.js",`
3n + 1 (Collatz Conjecture) visualization 
inspired by this Veritasium's [video](https://www.youtube.com/watch?v=094y1Z2wpJg).
You can also read about the conjecture on [Wikipedia](https://en.wikipedia.org/wiki/Collatz_conjecture).

Each tic Collatz sequence is generated for the next number.
Following the generated sequence from its end (1), 
for each number, the line is drawn from the point of the previous line's end.
The next line is drawn at the angle of the previous line, rotated by the angle 
that depends if the following number in the sequence is even or odd.

Coded with no external dependencies, using only canvas API.
`),this.length=a,this.evenAngle=r,this.oddAngle=n,this.scale=o,this.center=l,this.drawNumbers=h,this.showStats=c,this.sequences=[],this.max=0}generateNextSequence(){let t=this.sequences.length+1,i=[t];for(;1!==t;)t%2?t=3*t+1:t/=2,t>this.max&&(this.max=t),i.push(t),t<this.sequences.length&&(this.sequences[t-1]=null);this.sequences.push(i)}update(t){for(let t=0;t<this.speed;++t)this.generateNextSequence()}drawSequence(a){if(null!==a){let i=0,e=0,s=270*Math.PI/180;var t=this.colors[this.frame%this.colors.length];this.ctx.strokeStyle=t,this.ctx.lineWidth=2,this.ctx.font="12px sans-serif",this.ctx.fillStyle=t,this.ctx.beginPath(),this.ctx.moveTo(i,e);for(let t=a.length-2;0<=t;--t){var r,n,h=a[t];s+=h%2?this.oddAngleRad:this.evenAngleRad,this.drawNumbers?(r=Math.cos(s),n=Math.sin(s),i+=this.length/2*r,e+=this.length/2*n,this.ctx.fillText(h,i+10,e),i+=this.length/2*r,e+=this.length/2*n):(i+=this.length*Math.cos(s),e+=this.length*Math.sin(s)),this.ctx.lineTo(i,e)}this.ctx.stroke()}}draw(){for(this.evenAngleRad=this.evenAngle*Math.PI/180,this.oddAngleRad=this.oddAngle*Math.PI/180,this.ctx.translate(this.canvas.width/2,this.canvas.height/(this.center?2:1)),this.ctx.scale(this.scale,this.scale);this.frame<this.sequences.length;)this.drawSequence(this.sequences[this.frame]),++this.frame;var t;this.ctx.resetTransform(),this.showStats&&(t=["Current starting number: "+this.sequences.length,"Highest reached number: "+this.max],this.resetFont(),this.drawTextLines(t,this.lineHeight,this.canvas.height-(t.length+1)*this.lineHeight))}resize(){this.frame=0,this.clear()}restart(){this.sequences=[],this.max=0,super.restart()}updateColors(t,i,e){super.updateColors(t,i,e),this.resize()}getSettings(){return[{prop:"length",type:"float",min:1,max:100,step:.1,toCall:"resize"},{prop:"evenAngle",type:"float",min:-45,max:45,step:.1,toCall:"resize"},{prop:"oddAngle",type:"float",min:-45,max:45,step:.1,toCall:"resize"},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"int",min:1,max:16},{prop:"drawNumbers",type:"bool",toCall:"resize"},{prop:"scale",icon:'<i class="fa-solid fa-maximize"></i>',icon:'<i class="fa-solid fa-maximize"></i>',type:"float",min:.05,max:1.95,toCall:"resize"},{prop:"center",icon:'<i class="fa-solid fa-arrows-to-dot"></i>',type:"bool",toCall:"resize"},{prop:"showStats",icon:'<i class="fa-solid fa-circle-info"></i>',type:"bool"}]}}i.exports=a},{"../animation":2,"../utils":40}],4:[function(t,i,e){t=t("./game-of-life");class s extends t{constructor(t,i,e,s,a=12,r=1,n=.5,h=!0,o="random",l=5){super(t,i,e,s,a,r,n,h,o,l),this.name="Brian's brain automata",this.file="brians-brain-automata.js",this.description=`
Visualization of Brain's brain auromata.
You can read a bit about the automata on
[Wikipedia](https://en.wikipedia.org/wiki/Brian%27s_Brain)
or much more on [LifeWiki](https://conwaylife.com/wiki/OCA:Brian%27s_Brain).

You can pause the animation and set the cell states by clicking/touching the canvas.

My other cellular automata visualizations:
- [Conway's game of life](https://mwydmuch.pl/animations?animation=game-of-life)
- [day and night](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`}update(t){++this.frame;for(let i=0;i<this.gridHeight;++i)for(let t=0;t<this.gridWidth;++t){var e=this.numAliveInMooreNeighborhood(t,i),s=this.getIdx(t,i);2===e&&this.grid[s]<0?this.gridNext[s]=1:this.gridNext[s]=this.grid[s]-1}[this.grid,this.gridNext]=[this.gridNext,this.grid]}}i.exports=s},{"./game-of-life":11}],5:[function(t,i,e){var s=t("../animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=400,r=1,n=.05,h=!1){super(t,i,e,s,"cardioids with a pencil of lines","cardioids.js",`
Modified method of L. Cremona for drawing cardioid with a pencil of lines,
as described in section "cardioid as envelope of a pencil of lines" 
of this Wikipedia [article](https://en.wikipedia.org/wiki/Cardioid).

Here the shift of the second point for each line is determined by time passed
from the beginning of the animation.

To see what is really happening, try to set the number of lines to small number.

Playing with both number of lines and speed, allow to notice different interesting patterns.

Coded with no external dependencies, using only canvas API.
`),this.lines=a,this.scale=r,this.speed=n,this.rainbowColors=h,this.radius=0}getVec(t){t=a.remap(t,0,this.lines,0,2*Math.PI);return a.rotateVec2d(a.createVec2d(this.radius,0),Math.PI+t)}draw(){this.clear(),this.radius=Math.max(this.canvas.width,this.canvas.height)/3*this.scale,this.ctx.translate(this.canvas.width/2,this.canvas.height/2),a.strokeCircle(this.ctx,0,0,this.radius,this.colors[0]);for(let i=0;i<=this.lines;++i){var e=this.getVec(i),s=this.getVec(i*this.time);let t;t=this.rainbowColors?"hsl("+i/this.lines*360+", 100%, 75%)":a.lerpColorsPallet([this.colorA,this.colorB,this.colorA],i/this.lines),this.ctx.strokeStyle=t,a.drawLine(this.ctx,e.x,e.y,s.x,s.y,1,t)}this.ctx.resetTransform()}getSettings(){return[{prop:"lines",name:"number of lines",type:"int",min:1,max:2500},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",min:-2,max:2},{prop:"scale",icon:'<i class="fa-solid fa-maximize"></i>',type:"float",min:.25,max:1.75},{prop:"rainbowColors",icon:'<i class="fa-solid fa-rainbow"></i>',type:"bool"}]}}i.exports=r},{"../animation":2,"../utils":40}],6:[function(t,i,e){var s=t("../animation");let n=t("../utils");class a extends s{constructor(t,i,e,s,a=180,r=.5,n=.4,h=1.2,o=.001,l=!1){super(t,i,e,s,"circular waves","circular-waves.js",`
This animation draw a circle as a set of vertices and edges,
noise is added to the position of each vertex to create a wave effect. 

Coded with no external dependencies, using only canvas API.
`),this.vertices=a,this.noiseScale=r,this.radiusScaleMin=n,this.radiusScaleMax=h,this.fadingSpeed=o,this.rainbowColors=l,this.radiusMin=0,this.radiusMax=0}draw(){this.fadeOut(this.fadingSpeed);var i=.005*this.frame,e=2*Math.PI/this.vertices;this.rainbowColors?this.ctx.strokeStyle="hsl("+360*Math.abs(Math.sin(5*i))+", 100%, 50%)":this.ctx.strokeStyle=n.lerpColor(this.colorA,this.colorB,Math.abs(Math.sin(5*i))),this.ctx.translate(this.canvas.width/2,this.canvas.height/2),this.ctx.beginPath();for(let t=0;t<=this.vertices;++t){var s=t*e,a=Math.cos(s)*this.noiseScale,r=Math.sin(s)*this.noiseScale,a=this.noise.simplex3(a,r,i),r=n.remap(a,-1,1,this.radiusMin,this.radiusMax),a=r*Math.cos(s),r=r*Math.sin(s);0===t?this.ctx.moveTo(a,r):this.ctx.lineTo(a,r)}this.ctx.stroke(),this.ctx.resetTransform()}resize(){this.radiusMin=Math.min(this.canvas.width,this.canvas.height)/2*this.radiusScaleMin,this.radiusMax=Math.max(this.canvas.width,this.canvas.height)/2*this.radiusScaleMax,this.radiusMin>this.radiusMax&&([this.radiusMin,this.radiusMax]=[this.radiusMax,this.radiusMin]),this.clear()}updateColors(t,i,e){super.updateColors(t,i,e),this.resize()}getSettings(){return[{prop:"vertices",icon:'<i class="fa-solid fa-draw-polygon"></i>',type:"int",min:3,max:720,toCall:"resize"},{prop:"radiusScaleMin",type:"float",min:0,max:2,toCall:"resize"},{prop:"radiusScaleMax",type:"float",min:0,max:2,toCall:"resize"},{prop:"noiseScale",type:"float",min:0,max:2,toCall:"resize"},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},{prop:"rainbowColors",icon:'<i class="fa-solid fa-rainbow"></i>',type:"bool"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],7:[function(t,i,e){var s=t("../animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=20,r){super(t,i,e,s,"coding this website","coding.js",`
Work in progress.

Code writing animation inspired by: https://openprocessing.org/sketch/1219550
It's only light themed to match website colors, personally I always use dark IDE.

Coded with no external dependencies, using only canvas API.
`),this.charSize=a,this.editorTheme={keyword:"#33C5E1",typeName:"#F52D73",argument:"#F9A857",variable:"#030303",numericValue:"#B693FB",stringValue:"#F0763B",comment:"#737373"}}updateCharSize(){this.padding=this.charSize/2,this.lineHeight=1.25*this.charSize,this.charWidth=Math.ceil(this.charSize/1.618),this.charHeight=this.charSize,this.imageData=null,this.line=0,this.resize(),this.newWord()}newWord(){(this.wordLen=0)===this.words?this.currentColor=a.randomChoice(this.firstWordColors):this.currentColor===this.editorTheme.typeName?this.currentColor=a.randomChoice(this.afterTypeName):this.currentColor===this.editorTheme.variable?this.currentColor=a.randomChoice(this.afterVariable):this.currentColor===this.editorTheme.comment?this.currentColor=this.editorTheme.comment:this.currentColor=a.randomChoice(this.otherCases)}newLine(){var t;this.line>this.maxLines&&(t=(this.maxLines-this.line)*this.lineHeight,this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,t),this.line=this.maxLines),this.words=0,this.lineX=this.padding+this.tabs*this.tabSize*this.charWidth,this.lineY=this.padding+this.line*this.lineHeight}draw(){var t;this.rand()<Math.pow(.9,this.wordLen-2)||this.wordLen<3?(this.lineX+=this.charWidth,++this.wordLen,this.ctx.fillStyle=this.currentColor,this.ctx.fillRect(this.lineX,this.lineY,this.charWidth,this.charHeight)):(this.rand()<Math.pow(.5,this.words-1)||this.words<2?(++this.words,this.lineX+=this.charWidth):("inc"===(t=a.randomChoice(["inc","inc","dec","dec","keep","keep","reset","keep+newline"]))&&this.tabs<4?++this.tabs:"keep+newline"===t?++this.line:"dec"===t&&0<this.tabs?(++this.line,--this.tabs):"reset"===t&&0<this.tabs&&(++this.line,this.tabs=0),++this.line,this.newLine()),this.newWord()),this.imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height)}resize(){this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.maxLines=Math.floor((this.canvas.height-2*this.padding)/this.lineHeight)-1,this.newLine()}getSettings(){return[{prop:"charSize",type:"int",min:8,max:72,toCall:"updateCharSize"},{prop:"tabSize",type:"int",min:1,max:16}]}}i.exports=r},{"../animation":2,"../utils":40}],8:[function(t,i,e){t=t("./game-of-life");class s extends t{constructor(t,i,e,s,a=12,r=1,n=.5,h=!0,o="random",l=5){super(t,i,e,s,a,r,n,h,o,l),this.name="day and night automata",this.file="day-and-night-automata.js",this.description=`
Visualization of Day and Night auromata.
You can read abit about the automata on
[Wikipedia](https://en.wikipedia.org/wiki/Day_and_Night_(cellular_automaton))
or much more on [LifeWiki](https://conwaylife.com/wiki/OCA:Day_%26_Night).

You can pause the animation and set the cell states by clicking/touching the canvas.

My other cellular automata visualizations:
- [Conway's game of life](https://mwydmuch.pl/animations?animation=game-of-life)
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [glitch automata](https://mwydmuch.pl/animations?animation=glitch-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`}update(t){++this.frame;for(let i=0;i<this.gridHeight;++i)for(let t=0;t<this.gridWidth;++t){var e=this.numAliveInMooreNeighborhood(t,i),s=this.getIdx(t,i);this.grid[s]<=0&&[3,6,7,8].includes(e)||1<=this.grid[s]&&[3,4,6,7,8].includes(e)?this.gridNext[s]=1:this.gridNext[s]=this.grid[s]-1}[this.grid,this.gridNext]=[this.gridNext,this.grid]}}i.exports=s},{"./game-of-life":11}],9:[function(t,i,e){var s=t("../animation");let h=t("../utils");class a extends s{constructor(t,i,e,s,a=500,r=50,n="random"){super(t,i,e,s,"figures spiral","figures-spiral.js",`
Very simple of figures spinning in the spiral.

Coded with no external dependencies, using only canvas API.
`),this.shapeSides=[0,1,2,3,4,5,6,8],this.shapeNames=["circles","points","lines","triangles","rectangles","pentagons","hexagons","octagons"],this.sides=this.assignIfRandom(n,h.randomChoice(this.shapeSides)),this.updateName(),this.size=r,this.number=a}updateName(){this.name=this.shapeNames[this.shapeSides.indexOf(this.sides)]+" spinning in spiral"}draw(){this.clear(),this.ctx.translate(this.canvas.width/2,this.canvas.height/2),this.ctx.scale(this.scale,this.scale),this.ctx.strokeStyle=this.colors[0];for(let t=0;t<this.number;++t)this.ctx.rotate(Math.PI*(.001*this.time+1e-6*t)),this.ctx.beginPath(),0===this.sides&&h.pathCircle(this.ctx,t,t,this.size),1===this.sides?h.pathCircle(this.ctx,t,t,1):h.pathPolygon(this.ctx,t,t,this.size,this.sides,0),this.ctx.stroke();this.ctx.resetTransform()}getSettings(){return[{prop:"sides",type:"int",min:0,max:8,toCall:"updateName"},{prop:"number",type:"int",min:1,max:1024},{prop:"size",type:"int",min:1,max:128},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.1,min:-4,max:4}]}}i.exports=a},{"../animation":2,"../utils":40}],10:[function(t,i,e){var s=t("./game-of-life");let p=t("../utils");class a extends s{constructor(t,i,e,s,a=14,r=0,n=.4,h=!0,o=!0,l=!0,c=.75){super(t,i,e,s,a,r,n,l),this.name="isometric Conway's game of life",this.file="game-of-life-isometric.js",this.description=`
Conway's game of life visualization with isometric rendering.
You can read about the game of life on
[Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).
Game of life is one of the first programs I wrote in my life.

As in the [top-down version](https://mwydmuch.pl/animations?animation=game-of-life),
cells leave a trace for a few steps after they die to achieve a nice effect.
Especially, cells that died in the previous step keep the appearance 
of the life cell resulting in a stable image 
since flickering is not that good for a background image.

My other cellular automata visualizations:
- [Conway's game of life](https://mwydmuch.pl/animations?animation=game-of-life)
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [day and night](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [glitch automata](https://mwydmuch.pl/animations?animation=glitch-automata)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`,this.fadeDeadCells=h,this.drawCellsGrid=o,this.gridSize=c,this.sqrt3=Math.sqrt(3),this.xShift=this.cellSize*this.sqrt3/2,this.yShift=this.cellSize/2,this.renderedGrid=null,this.renderedCubes=[];var d=p.createOffscreenCanvas(4*this.xShift,4*this.yShift).getContext("2d");this.drawIsoCube(d,0,3*this.yShift,!0,!0,this.colors,0,this.cellSize),this.renderedCubes.push(d.canvas);for(let t=1;t<this.cellSize;++t)d=p.createOffscreenCanvas(4*this.xShift,4*this.yShift).getContext("2d"),this.drawIsoCube(d,0,3*this.yShift,!0,!0,this.colorsAlt,-t,this.cellSize),this.renderedCubes.push(d.canvas)}drawIsoCube(t,i,e,s,a,r,n,h){var o=h*this.sqrt3/2,h=h/2;n*=-1,t.strokeStyle=r[0],t.fillStyle=r[3],t.beginPath(),p.pathClosedShape(t,[[i,e-2*h+n],[i+o,e-h+n],[i+2*o,e-2*h+n],[i+o,e-3*h+n]]),t.fill(),t.stroke(),s&&(t.fillStyle=r[2],t.beginPath(),p.pathClosedShape(t,[[i,e],[i+o,e+h],[i+o,e-h+n],[i,e-2*h+n]]),t.fill(),t.stroke()),a&&(t.fillStyle=r[1],t.beginPath(),p.pathClosedShape(t,[[i+o,e+h],[i+2*o,e],[i+2*o,e-2*h+n],[i+o,e-h+n]]),t.fill(),t.stroke())}drawCube(t,i,e,s=0,a=0){var r=t*this.xShift-i*this.xShift,n=(t+i+1)*this.yShift;this.drawIsoCube(this.ctx,r,n,!this.isAlive(t,i+1),!this.isAlive(t+1,i),e,s,this.cellSize-2*a)}drawGrid(s,t,i){var a=this.gridHeight*-this.xShift,r=this.gridHeight*this.yShift,n=this.gridWidth*this.xShift,h=this.gridWidth*this.yShift,e=(-this.gridHeight+this.gridWidth)*this.xShift,o=(this.gridHeight+this.gridWidth)*this.yShift,l=this.colors[0];for(let e=0;e<this.gridHeight;++e){let t=e*-this.xShift,i=e*this.yShift;p.drawLine(s,t,i,t+n,i+h,1,l),p.drawLine(s,-t,i,-t+a,i+r,1,l)}p.drawLine(s,0,0,n,h,3,l),p.drawLine(s,0,0,a,r,3,l),p.drawLine(s,a,r,e,o,3,l),p.drawLine(s,n,h,e,o,3,l)}drawPrerenderedCube(t,i,e){var s=t*this.xShift-i*this.xShift,t=(t+i+1)*this.yShift;this.ctx.drawImage(this.renderedCubes[e],s-+this.xShift,t-3*this.yShift)}mouseCellCord(t,i){}draw(){var t;this.clear(),this.drawCellsGrid&&(this.renderedGrid||((t=p.createOffscreenCanvas(this.canvas.width,this.canvas.height).getContext("2d")).translate(this.canvas.width/2,(1-this.gridSize)/2*this.canvas.height),this.drawGrid(t,0,0),this.renderedGrid=t.canvas),this.ctx.drawImage(this.renderedGrid,0,0)),this.ctx.translate(this.canvas.width/2,(1-this.gridSize)/2*this.canvas.height);for(let i=0;i<this.gridHeight;++i)for(let t=0;t<this.gridWidth;++t){var e=this.getVal(t,i);this.fadeDeadCells&&e>-(this.cellSize-2*this.cellBasePadding)?this.drawPrerenderedCube(t,i,Math.max(0,-e)):0<e&&this.drawPrerenderedCube(t,i,0)}this.ctx.resetTransform()}resize(){var t=Math.min(this.canvas.width,this.canvas.height),t=Math.ceil(this.gridSize*t/this.cellSize);this.resizeGrid(t,t),this.renderedGrid=null}getSettings(){return[{prop:"loopGrid",type:"bool"},{prop:"fadeDeadCells",type:"bool"},{prop:"drawCellsGrid",type:"bool"},{prop:"gridSize",type:"float",step:.01,min:0,max:2,toCall:"resize"},{prop:"spawnProb",icon:'<i class="fa-solid fa-dice"></i>',type:"float",step:.01,min:0,max:1,toCall:"restart"},this.getSeedSettings()]}}i.exports=a},{"../utils":40,"./game-of-life":11}],11:[function(t,i,e){var s=t("../grid-animation");let d=t("../utils");class a extends s{constructor(t,i,e,s,a=12,r=1,n=.4,h=!0,o="random",l=5,c="size+color"){super(t,i,e,s,"Conway's game of life","game-of-life.js",`
Voisualization of Conway's game of life - probably the most famous cellular automata.
You can read about the game of life on
[Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
or [LifeWiki](https://conwaylife.com/wiki/Conway%27s_Game_of_Life) (it's a great website).
Game of life is one of the first programs I wrote in my life.

In this version, cells leave a trace for 
a few steps after they die to achieve a nice effect.
Especially, cells that died in the previous step keep the appearance 
of the life cell resulting in a stable image 
since flickering is not that good for a background image.

You can pause the animation and set the cell states by clicking/touching the canvas.

My other cellular automata visualizations:
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [day and night automata](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [glitch automata](https://mwydmuch.pl/animations?animation=glitch-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.cellBasePadding=r,this.initialPaterns=["random","R Pentomino"],this.spawnProb=n,this.cellStyles=["square","circle"],this.cellStyle=this.assignIfRandom(o,d.randomChoice(this.cellStyles)),this.deadCellsFadingSteps=l,this.deadCellsFadingStyles=["color","size","size+color"],this.deadCellsFadingStyle=this.assignIfRandom(c,d.randomChoice(this.deadCellsFadingStyles)),this.loopGrid=h,this.mouseDown=!1,this.mouseVal=0}isAlive(t,i){return this.loopGrid?1<=this.getValWrap(t,i)?1:0:!(t<0||t>=this.gridWidth||i<0||i>=this.gridHeight)&&1<=this.getVal(t,i)?1:0}numAliveInMooreNeighborhood(t,i){return this.isAlive(t-1,i-1)+this.isAlive(t,i-1)+this.isAlive(t+1,i-1)+this.isAlive(t-1,i)+this.isAlive(t+1,i)+this.isAlive(t-1,i+1)+this.isAlive(t,i+1)+this.isAlive(t+1,i+1)}update(t){super.update(t);for(let i=0;i<this.gridHeight;++i)for(let t=0;t<this.gridWidth;++t){var e=this.numAliveInMooreNeighborhood(t,i),s=this.getIdx(t,i);2===e&&1<=this.grid[s]?this.gridNext[s]=this.grid[s]+1:this.gridNext[s]=3===e?Math.max(1,this.grid[s]+1):Math.min(0,this.grid[s]-1)}[this.grid,this.gridNext]=[this.gridNext,this.grid]}drawSquareCell(t,i,e){this.ctx.fillRect(t*this.cellSize+e,i*this.cellSize+e,this.cellSize-2*e,this.cellSize-2*e)}drawCircleCell(t,i,e){this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,i*this.cellSize+this.cellSize/2,this.cellSize/2-e,0,2*Math.PI,!1),this.ctx.fill()}draw(){this.clear(),this.ctx.translate(-(this.mapWidth*this.cellSize-this.canvas.width)/2,-(this.mapHeight*this.cellSize-this.canvas.height)/2),"square"===this.cellStyle?this.drawCell=this.drawSquareCell:this.drawCell=this.drawCircleCell;var r=(this.cellSize/2-this.cellBasePadding)/(this.deadCellsFadingSteps+1),n=this.deadCellsFadingStyle.includes("size"),h=this.deadCellsFadingStyle.includes("color"),o=new Array(this.deadCellsFadingSteps);for(let t=0;t<this.deadCellsFadingSteps;++t)o[t]=d.lerpColor(this.colors[0],this.bgColor,t/this.deadCellsFadingSteps);for(let a=0;a<this.gridHeight;++a)for(let t=0;t<this.gridWidth;++t){var l=this.getVal(t,a);let i=this.cellBasePadding,e=null,s=-1;if(0<l)e=this.colors[0];else for(let t=0;t<this.deadCellsFadingSteps;++t){if(l>s){e=h?o[t]:this.colors[0],n&&(i+=t*r);break}s*=2}e&&(this.ctx.fillStyle=e,this.drawCell(t,a,i))}this.ctx.resetTransform()}newCellState(t,i){return this.rand()<this.spawnProb?1:-99999}mouseAction(t,i){"down"===i?this.mouseDown=!0:"up"===i&&(this.mouseDown=!1),("down"===i||"move"===i&&this.mouseDown)&&(t=this.mouseCellCord(t.x,t.y),"down"===i&&(1===this.grid[t]?this.mouseVal=-99999:this.mouseVal=1),this.grid[t]!==this.mouseVal)&&(this.grid[t]=this.mouseVal,this.draw())}mouseCellCord(t,i){return Math.floor(t/this.cellSize)+Math.floor(i/this.cellSize)*this.gridWidth}getSettings(){return[{prop:"changeGrid",type:"text",value:'<<i class="fa-solid fa-computer-mouse"></i> click/touch>'},{prop:"loopGrid",type:"bool"},{prop:"cellSize",type:"int",min:4,max:32,toCall:"restart"},{prop:"cellStyle",type:"select",values:this.cellStyles},{prop:"cellBasePadding",name:"cell padding",type:"bool"},{prop:"deadCellsFadingSteps",type:"int",min:0,max:8},{prop:"deadCellsFadingStyle",type:"select",values:this.deadCellsFadingStyles},{prop:"spawnProb",icon:'<i class="fa-solid fa-dice"></i>',type:"float",step:.01,min:0,max:1,toCall:"restart"},this.getSeedSettings()]}}i.exports=a},{"../grid-animation":34,"../utils":40}],12:[function(t,i,e){var s=t("../grid-animation");let h=t("../utils");class a extends s{constructor(t,i,e,s,a=7,r="random",n=.0051){super(t,i,e,s,"glitch automata","glitch-automata.js",`
The animation is a type of cellular automata that apply to the cell 
a state of one of the neighbor cells based on a noise function.
It reminds me the effect of glitching 

TODO

https://en.wikipedia.org/wiki/Error_diffusion

My other cellular automata visualizations:
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [day and night automata](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [glitch automata](https://mwydmuch.pl/animations?animation=glitch-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.noiseScale=n,this.initialPaterns=["1x1 checkerboard","2x2 checkerboard","4x4 checkerboard","vertical lines","horizontal lines","photo"],this.initialPatern=this.assignIfRandom(r,h.randomChoice(this.initialPaterns))}update(t){super.update(t);for(let i=0;i<this.gridWidth;++i)for(let t=0;t<this.gridHeight;++t){var e=this.noise.simplex3(i*this.noiseScale,t*this.noiseScale,this.frame*this.noiseScale),e=Math.round(20*e)%5,s=this.getIdx(i,t);switch(e){case 0:this.gridNext[s]=this.grid[this.getIdxWrap(i-1,t)];break;case 1:this.gridNext[s]=this.grid[this.getIdxWrap(i+1,t)];break;case 2:this.gridNext[s]=this.grid[this.getIdxWrap(i,t-1)];break;case 3:this.gridNext[s]=this.grid[this.getIdxWrap(i,t+1)];break;case 4:this.gridNext[s]=this.grid[s]}}[this.grid,this.gridNext]=[this.gridNext,this.grid]}draw(){this.clear(),this.ctx.fillStyle=this.colors[0];for(let i=0;i<this.gridWidth;++i)for(let t=0;t<this.gridHeight;++t)0<this.grid[this.getIdx(i,t)]&&this.ctx.fillRect(i*this.cellSize,t*this.cellSize,this.cellSize,this.cellSize)}newCellState(t,i){return"1x1 checkerboard"==this.initialPatern?(t+i)%2?1:0:"2x2 checkerboard"==this.initialPatern?(Math.floor(t/2)+Math.floor(i/2))%2?1:0:"4x4 checkerboard"==this.initialPatern?(Math.floor(t/4)+Math.floor(i/4))%2?1:0:"vertical lines"==this.initialPatern?t%4?0:1:"horizontal lines"==this.initialPatern?i%4?0:1:"random"==this.initialPatern?Math.round(Math.random()):0}setGridUsingImage(t){console.log("Image loaded");var i=new OffscreenCanvas(this.gridWidth,this.gridHeight),e=t.naturalWidth,s=t.naturalHeight,a=Math.min(this.gridWidth/e,this.gridHeight/s),e=e*a,s=s*a,a=i.getContext("2d"),r=(a.drawImage(t,(this.gridWidth-e)/2,(this.gridHeight-s)/2,e,s),a.getImageData(0,0,i.width,i.height));console.log("Image processed"),this.clear(),this.ctx.putImageData(r,200,200);for(let t=0;t<r.data.length;t+=4){var n=.2126*r.data[t]+.7152*r.data[t+1]+.0722*r.data[t+2];r.data[t]=n,r.data[t+1]=n,r.data[t+2]=n,this.grid[t/4]=n<128?1:0}this.clear(),this.ctx.fillStyle=this.colors[0];for(let i=0;i<this.gridWidth;++i)for(let t=0;t<this.gridHeight;++t)0<this.grid[this.getIdx(i,t)]&&this.ctx.fillRect(i*this.cellSize,t*this.cellSize,this.cellSize,this.cellSize);this.ctx.putImageData(r,200+this.gridWidth,200+this.gridHeight)}restart(){if("photo"==this.initialPatern){console.log("Restart... using");let t=new Image,i=this;t.src="./assets/marek-wydmuch.jpg",t.onload=function(){i.setGridUsingImage(t)}}else this.gridWidth=0,this.gridHeight=0,super.restart()}getSettings(){return[{prop:"cellSize",type:"int",min:4,max:12,toCall:"resize"},{prop:"initialPatern",type:"select",values:this.initialPaterns,toCall:"restart"},{prop:"noiseScale",type:"float",step:1e-4,min:.001,max:.05},this.getSeedSettings()]}}i.exports=a},{"../grid-animation":34,"../utils":40}],13:[function(t,i,e){var s=t("../animation");let y=t("../utils");class a{constructor(t){this.name=t}update(t){return 0}init(t){this.w=[...t]}getName(){return this.name}}class l extends a{constructor(t=.001){super("SGD"),this.eta=t}update(i){for(let t=0;t<this.w.length;++t)this.w[t]-=this.eta*i[t]}}class c extends a{constructor(t=.001,i=.9){super("Momentum"),this.eta=t,this.beta=i}init(t){super.init(t),this.m=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta*this.m[t]+(1-this.beta)*i[t],this.w[t]-=this.eta*this.m[t]}}class d extends a{constructor(t=.1){super("AdaGrad"),this.eta=t}init(t){super.init(t),this.v=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.v[t]+=i[t]*i[t],this.w[t]-=this.eta/Math.sqrt(this.v[t]+1e-6)*i[t]}}class p extends a{constructor(t=.01,i=.9){super("RMSProp"),this.eta=t,this.beta=i}init(t){super.init(t),this.v=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.v[t]=this.beta*this.v[t]+(1-this.beta)*i[t]*i[t],this.w[t]-=this.eta/Math.sqrt(this.v[t]+1e-6)*i[t]}}class m extends a{constructor(t=.01,i=.9,e=.999){super("Adam"),this.eta=t,this.beta1=i,this.beta2=e}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*i[t],this.v[t]=this.beta2*this.v[t]+(1-this.beta2)*i[t]*i[t],this.w[t]-=this.eta/(Math.sqrt(this.v[t]/(1-this.beta2))+1e-6)*this.m[t]/(1-this.beta1)}}class u extends a{constructor(t=.002,i=.9,e=.999){super("AdaMax"),this.alpha=t,this.beta1=i,this.beta2=e}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*i[t],this.v[t]=Math.max(this.beta2*this.v[t],Math.abs(i[t])),this.w[t]-=this.alpha/(this.v[t]+1e-6)*this.m[t]/(1-this.beta1)}}class g extends a{constructor(t=.002,i=.9,e=.999){super("AMSGrad"),this.alpha=t,this.beta1=i,this.beta2=e}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(i){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*i[t],this.v[t]=Math.max(this.beta2*this.v[t]+(1-this.beta2)*i[t]*i[t],this.v[t]),this.w[t]-=this.alpha/(Math.sqrt(this.v[t])+1e-6)*this.m[t]}}class r{constructor(t,i,e,s,a=[0,0]){this.name=t,this.globalMin=i,this.startPoints=e,this.drawScale=s,this.shift=a}val(t){return 0}grad(t){return t}hasGlobalMin(){return null!==this.globalMin}getGlobalMin(){return y.subArrays(this.globalMin,this.shift)}getStartPoint(){return y.subArrays(y.randomChoice(this.startPoints),this.shift)}getScale(){return this.drawScale}getName(){return this.name}}class f extends r{constructor(){super("Two-dimensional function with saddle point: f(x) = x[0]^2 - x[1]^2",null,[[-1,.001],[-1,-1e-4],[1,.01],[1,-.001]],1.1)}val(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1];return i*i-t*t}grad(t){return[2*(t[0]+this.shift[0]),-2*(t[1]+this.shift[1])]}}class x extends r{constructor(){super("Two-dimensional non-convex, multimodal BEALE function",[3,.5],[[.2,.7],[2,2],[-1,-1.3],[-1.4,-1.7],[4,-1.1]],2.2,[2,0])}val(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1];return Math.pow(1.5-i+i*t,2)+Math.pow(2.25-i+i*t*t,2)+Math.pow(2.625-i+i*Math.pow(t,3),2)}grad(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1],e=t*t,s=e*t,a=s*t,r=a*t;return[2*i*(r*t+a-2*s-e-2*t+3)+5.25*s+4.5*e+3*t-12.75,6*i*(i*(r+2/3*s-e-1/3*t-1/3)+2.625*e+1.5*t+.5)]}}class v extends r{constructor(){super("Two variables non-convex, multimodal Stybliski-Tang function",[-2.903534,-2.903534],[[0,5],[0,-5],[5,0],[-5,0],[-.5,-5],[-5,-.5],[-5,-5]],5.5)}val(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1],e=i*i,s=t*t;return(e*e-16*e+5*i+(s*s-16*s+5*t))/2+78.33233}grad(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1];return[2*Math.pow(i,3)-16*i+2.5,2*Math.pow(t,3)-16*t+2.5]}}class w extends r{constructor(){super("Two-dimensional non-convex, multimodal Rosenbrock function",[1,1],[[-2.5,-2.5],[2.5,-2.5],[0,2.5]],3.072)}val(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1];return 100*Math.pow(t-i*i,2)+Math.pow(1-i,2)}grad(t){var i=t[0]+this.shift[0],t=t[1]+this.shift[1],e=i*i;return[2*(-1+i+200*(e*i)-200*i*t),200*(-e+t)]}}class n extends s{constructor(t,i,e,s,a="random",r=1,n=5,h=!0,o=1e3){super(t,i,e,s,"visualization of gradient descent algorithms","gradient-descent.js",`
Visualization of the popular gradient descent-based optimizers.
Default hyperparameters are set to recommended values
according to the original papers or/and PyTorch documentation.

The objective functions were taken from this very nice 
[website](https://www.sfu.ca/~ssurjano/optimization.html).

You can select the starting point by clicking/touching the canvas.

The interesting challenge related to this animation was 
to efficiently visualize the optimized function. 
This is done by using simplified version of the marching squares algorithm.

Coded with no external dependencies, using only canvas API.
`),this.funcNames=["with saddle point","BEALE","Rosenbrock","Styblinski-Tang"],this.functionToOptimize=this.assignIfRandom(a,y.randomChoice(this.funcNames)),this.funcClasses=[f,x,w,v],this.scale=r,this.rounding=n,this.autoRestart=h,this.autoRestartSteps=o,this.func=null,this.start=null,this.optims=null,this.imageData=null,this.drawScale=0,this.functionImageData=null,this.sgd=new l,this.momentum=new c,this.adagrad=new d,this.rmsprop=new p,this.adam=new m,this.adamax=new u,this.amsgrad=new g,this.optims=[this.sgd,this.momentum,this.adagrad,this.rmsprop,this.adam,this.adamax,this.amsgrad]}draw(){this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.ctx.translate(this.canvas.width/2,this.canvas.height/2);for(let t=0;t<this.optims.length;++t){var i,e,s,a=this.optims[t];[i,e]=a.w,a.update(this.func.grad(a.w)),[a,s]=a.w,isFinite(i)&&isFinite(e)&&isFinite(a)&&isFinite(s)&&(isNaN(i)||isNaN(e)||isNaN(a)||isNaN(s)||1e4<Math.abs(i)||1e4<Math.abs(e)||1e4<Math.abs(a)||1e4<Math.abs(s)||y.drawLine(this.ctx,i*this.drawScale,-e*this.drawScale,a*this.drawScale,-s*this.drawScale,2,this.colorsAlt[t]))}this.ctx.resetTransform(),this.imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height),this.resetFont();let r=this.textYOffset+2*this.lineHeight;y.fillAndStrokeText(this.ctx,"Steps: "+this.frame,this.textXOffset,r),r+=this.lineHeight,y.fillAndStrokeText(this.ctx,"Optimizers:",this.textXOffset,r);for(let t=0;t<this.optims.length;++t){r+=this.lineHeight,this.ctx.fillStyle=this.colorsAlt[t];var n=this.optims[t].w[0].toFixed(this.rounding),h=this.optims[t].w[1].toFixed(this.rounding),n=this.optims[t].getName()+`: f([${n}, ${h}]) = `+this.func.val([n,h]).toFixed(this.rounding);y.fillAndStrokeText(this.ctx,n,this.textXOffset+16,r),y.fillCircle(this.ctx,this.textXOffset+3,r-4,3,this.colorsAlt[t])}this.autoRestart&&this.frame>=this.autoRestartSteps&&(this.start=null,this.resize())}drawFunction(){if(this.functionImageData)this.ctx.putImageData(this.functionImageData,0,0);else{this.clear();var n=this.canvas.width,h=this.canvas.height,o=n/2,l=h/2,t=this.func.getScale(),c=t/this.scale,d=t/.5,p=(this.drawScale=Math.min(n,h)/t/2*this.scale,this.ctx.fillStyle=this.colors[0],this.ctx.strokeStyle=this.bgColor,this.ctx.font="12px sans-serif",new Array(n*h));let e,s,a,r=0;a=this.func.hasGlobalMin()?(r=this.func.val(this.func.getGlobalMin()),e=[0,.125],s=1.5,0):(r=0,t=[this.func.val([0,0]),this.func.val([d,0]),this.func.val([0,d]),this.func.val([-d,0]),this.func.val([0,-d]),this.func.val([d,d]),this.func.val([-d,-d]),this.func.val([d,-d]),this.func.val([-d,d])],d=Math.min(...t),t=Math.max(...t),e=[d],s=1,(t-d)/29);for(let i=0;i<n;++i)for(let t=0;t<h;++t){for(var m=(i-o)/this.drawScale,u=-(t-l)/this.drawScale,g=this.func.val([m,u]),f=i+t*n;g>r+e[e.length-1];)e.push(e[e.length-1]*s+a);for(let t=1;t<e.length;++t)if(g<r+e[t]){p[f]=t-1;break}}var x=[];for(let t=0;t<e.length;++t)x.push(y.lerpColor(this.colorA,this.colorB,(t+1)/(e.length+1)));for(let i=0;i<n;++i)for(let t=0;t<h;++t){var v=i+t*n,w=-3*p[v]+p[v+1]+p[v+n]+p[v+1+n];this.ctx.fillStyle=x[p[v]],0!==w&&4!==w&&this.ctx.fillRect(i,t,1,1)}this.ctx.fillStyle=this.colors[0];let i=.5;6<c?i=2:3<c&&(i=1);for(let t=0;t<o/this.drawScale;t+=i)y.fillAndStrokeText(this.ctx,t.toFixed(1),o+t*this.drawScale,h-22),0!==t&&y.fillAndStrokeText(this.ctx,(-t).toFixed(1),o-t*this.drawScale,h-22);for(let t=0;t<l/this.drawScale;t+=i)y.fillAndStrokeText(this.ctx,(-t).toFixed(1),10,l+t*this.drawScale),0!==t&&y.fillAndStrokeText(this.ctx,t.toFixed(1),10,l-t*this.drawScale);this.functionImageData=this.ctx.getImageData(0,0,n,h),this.functionImageData.drawScale=this.drawScale,this.functionImageData.scale=this.scale}}drawLegend(){var t,i=this.canvas.width,e=this.canvas.height,s=i/2,a=e/2;this.textYOffset=22,this.textXOffset=50,this.resetFont(),y.fillAndStrokeText(this.ctx,this.func.getName(),this.textXOffset,this.textYOffset),this.func.hasGlobalMin()&&(this.textYOffset+=this.lineHeight,t=this.func.getGlobalMin(),y.fillAndStrokeText(this.ctx,`Optimum: f(x*) = ${this.func.val(t).toFixed(this.rounding)}, at x* = [${t[0]}, ${t[1]}]`,this.textXOffset,this.textYOffset,2),y.fillCircle(this.ctx,s+t[0]*this.drawScale,a+-t[1]*this.drawScale,2,this.colors[0])),this.textYOffset+=this.lineHeight,y.fillAndStrokeText(this.ctx,`Starting point: x0 = [${this.start[0].toFixed(this.rounding)}, ${this.start[1].toFixed(this.rounding)}], f(x0) = `+this.func.val(this.start).toFixed(this.rounding),this.textXOffset,this.textYOffset),this.imageData=this.ctx.getImageData(0,0,i,e)}mouseAction(t,i){"click"===i&&(this.start=[(t.x-this.canvas.width/2)/this.drawScale,-(t.y-this.canvas.height/2)/this.drawScale],this.resize())}resize(){this.frame=0;var t,i=new this.funcClasses[this.funcNames.indexOf(this.functionToOptimize)];null!==this.func&&this.func.getName()===i.getName()||(this.func=i,this.functionImageData=null,this.start=null),null===this.functionImageData||this.functionImageData.width===this.canvas.width&&this.functionImageData.height===this.canvas.height&&this.functionImageData.scale===this.scale||(this.functionImageData=null),null===this.start&&(this.start=this.func.getStartPoint()),this.drawFunction(),this.drawLegend();for(t of this.optims)t.init(this.start)}updateColors(t,i,e){super.updateColors(t,i,e),this.functionImageData=null,this.resize()}getSettings(){return[{prop:"functionToOptimize",icon:'<i class="fa-solid fa-chart-area"></i>',type:"select",values:this.funcNames,toCall:"resize"},{prop:"selectStartingPoint",type:"text",value:"<click/touch>"},{prop:"scale",icon:'<i class="fa-solid fa-maximize"></i>',type:"float",step:.1,min:.5,max:1.5,toCall:"resize"},{prop:"autoRestart",icon:'<i class="fa-solid fa-clock-rotate-left"></i>',type:"bool"},{prop:"autoRestartSteps",type:"int",step:1,min:100,max:1e4},{type:"separator"},{prop:"sgd.eta",type:"float",step:1e-5,min:0,max:.1},{prop:"momentum.eta",type:"float",step:1e-5,min:0,max:.1},{prop:"momentum.beta",type:"float",step:1e-4,min:0,max:1},{prop:"adagrad.eta",type:"float",step:1e-5,min:0,max:1},{prop:"rmsprop.eta",type:"float",step:1e-5,min:0,max:1},{prop:"adam.eta",type:"float",step:1e-5,min:0,max:1},{prop:"adam.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"adam.beta2",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.alpha",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.beta2",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.alpha",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.beta2",type:"float",step:1e-5,min:0,max:1}]}}i.exports=n},{"../animation":2,"../utils":40}],14:[function(t,i,e){var s=t("../animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=20,r=.6,n=.01,h=!0){super(t,i,e,s,"Matrix digital rain","matrix.js",`
Recreation of matrix digital rain based on this analysis
of the original effect on this 
[website](https://carlnewton.github.io/digital-rain-analysis/).

I'm a huge fan of the first movie.

Coded with no external dependencies, using only canvas API.
`),this.dropsSize=a,this.dropsSpeed=r,this.fadingSpeed=n,this.glowEffect=h,this.flipProp=.25,this.errorProp=.1,this.cellWidth=0,this.cellHeight=0,this.columns=0,this.columnHeight=0,this.drops=[],this.imageData=null;this.characters='ｦｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾜﾝ0123456789*+:=.<>#@!?^~"'}dropSpawnPoint(t){return a.randomInt(0,Math.min(t-1,this.columnHeight/2),this.rand)-1}dropDespawn(t){return this.rand()<.1*Math.pow(t/this.columnHeight,2)||t>this.columnHeight}drawCharacter(t,i,e){this.ctx.fillStyle=this.colors[0],this.glowEffect&&(this.ctx.filter=`blur(${this.dropsSize/10}px)`,this.ctx.fillText(t,i,e),this.ctx.filter="blur(0)",this.ctx.fillStyle=this.colors[1]),this.ctx.fillText(t,i,e)}drawCharacterCell(t,i,e){this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(i-this.cellWidth/2,e,this.cellWidth,this.cellHeight),this.rand()<this.flipProp?(this.ctx.save(),this.ctx.translate(i,e),this.ctx.scale(-1,1),this.drawCharacter(t,0,0),this.ctx.restore()):this.drawCharacter(t,i,e)}draw(){this.fadeOut(this.fadingSpeed),this.ctx.font=this.dropsSize+"px monospace",this.ctx.textAlign="center",this.ctx.textBaseline="top";for(var t of this.drops){var i,e;Math.floor(t.y)!==Math.floor(t.y+this.dropsSpeed)?(t.y+=this.dropsSpeed,i=t.x*this.cellWidth+this.cellWidth/2,e=Math.floor(t.y)*this.cellHeight,this.drawCharacterCell(t.char,i,e,this.textColor),t.char=a.randomChoice(this.characters,this.rand),this.dropDespawn(t.y)&&(t.y=this.dropSpawnPoint(t.y)),this.rand()<this.errorProp&&(e=a.randomInt(-8,8,this.rand),this.drawCharacterCell(a.randomChoice(this.characters,this.rand),i,Math.floor(e+t.y)*this.cellHeight,this.textColor))):t.y+=this.dropsSpeed}this.imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height)}resize(){if(this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.cellHeight=this.dropsSize,this.cellWidth=Math.ceil(this.dropsSize/1.618),this.columns=this.canvas.width/this.cellWidth,this.columnHeight=this.canvas.height/this.cellHeight,this.drops.length<this.columns)for(let t=this.drops.length;t<this.columns;++t)this.drops.push({char:a.randomChoice(this.characters,this.rand),x:t,y:this.dropSpawnPoint(this.columnHeight)})}restart(){this.drops=[],super.restart()}updateColors(t,i,e){super.updateColors(t,i,e),this.restart()}getSettings(){return[{prop:"dropsSize",type:"int",min:8,max:64,toCall:"resize"},{prop:"dropsSpeed",type:"float",min:0,max:1},{prop:"fadingSpeed",type:"float",step:.01,min:0,max:.15},{prop:"glowEffect",icon:'<i class="fa-solid fa-lightbulb"></i>',type:"bool"},this.getSeedSettings()]}}i.exports=r},{"../animation":2,"../utils":40}],15:[function(t,i,e){var s=t("../animation");let o=t("../utils");class a extends s{constructor(t,i,e,s,a=1,r=125,n=!1){super(t,i,e,s,"ML in PL Network","mlinpl.js",`
Simple network animation, I created for ML in PL websites.

It was used for the on
[ML in PL Conference 2023 website](https://conference2023.mlinpl.org/).
and [MLSS^S 2023 website](https://mlss2023.mlinpl.org/).

Coded with no external dependencies, using only canvas API.
`),this.particlesDensity=a,this.connectionThreshold=r,this.originalColors=n,this.width=0,this.height=0,this.logoScale=.5,this.logoBlack=new Image,this.logoBlack.src="assets/logos/mlinpl-black.png",this.particlesColorsBlack=[this.colors[0],"#000","#222","#444","#AAA","#EEE"],this.logoWhite=new Image,this.logoWhite.src="assets/logos/mlinpl-white.png",this.particlesColorsWhite=[this.colors[0],"#FFF","#DDD","#BBB","#555","#111"],this.particlesColors=null,this.bgParticles=[],this.mgParticles=[],this.fgParticles=[],this.bgParticlesCfg={colors:{5:1},lineColors:{5:1},sizeMin:4,sizeRange:3,speedMax:.5,groups:[[0,1],[0,2],[1,2]],density:15e-5},this.mgParticlesCfg={colors:{4:1},lineColors:{4:1},sizeMin:2,sizeRange:2,speedMax:.75,groups:[[]],density:15e-5},this.fgParticlesCfg={colors:{0:.4,1:.6},lineColors:{1:.3,2:.3,3:.3},sizeMin:2,sizeRange:5,speedMax:1,groups:[[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[0],[1],[2],[3],[4],[0],[1],[2],[3],[4]],density:3e-4}}updateParticles(t,i){for(var e of t){var s=Math.sin(e.x/e.freq)*e.amp,a=(e.x+=e.velX*i/33,Math.sin(e.x/e.freq)*e.amp);e.y+=e.velY*(s-a)*i/33,e.x<-this.connectionThreshold?e.x=this.width+this.connectionThreshold:e.x>this.width+this.connectionThreshold&&(e.x=-this.connectionThreshold),e.y+e.size>=this.height&&(e.velY*=-1)}}createParticles(i,e,s,a,r){var n=s*a*r.density*this.particlesDensity,h=[];for(let t=0;t<n;t++)h.push({x:this.rand()*(s+2*this.connectionThreshold)+i-this.connectionThreshold,y:+o.randomNormal(0,1,this.rand)/2*a+e,velX:(2*this.rand()-1)*r.speedMax,velY:(2*this.rand()-1)*r.speedMax,freq:100*this.rand()+100,amp:200*this.rand(),size:this.rand()*r.sizeRange+r.sizeMin,color:o.randomRulletChoice(r.colors,this.rand),lineColor:o.randomRulletChoice(r.lineColors,this.rand),groups:o.randomChoice(r.groups,this.rand)});return h}spawnParticles(t,i,e,s){this.bgParticles.push(...this.createParticles(t,i,e,s,this.bgParticlesCfg)),this.mgParticles.push(...this.createParticles(t,i,e,s,this.mgParticlesCfg)),this.fgParticles.push(...this.createParticles(t,i,e,s,this.fgParticlesCfg))}update(t){super.update(t),this.updateParticles(this.bgParticles,t),this.updateParticles(this.mgParticles,t),this.updateParticles(this.fgParticles,t)}drawParticles(e){for(let i=0;i<e.length-1;i++)if(0!==e[i].groups.length)for(let t=i+1;t<e.length;t++){var s=e[i],a=e[t];if(!(o.distVec2d(s,a)>this.connectionThreshold))for(var r of s.groups)if(a.groups.includes(r)){o.drawLine(this.ctx,s.x,s.y,a.x,a.y,1,this.particlesColors[s.lineColor]);break}}for(var t of e)o.fillCircle(this.ctx,t.x,t.y,t.size,this.particlesColors[t.color])}draw(){var t,i;"#000000"===this.bgColor?(this.particlesColors=this.particlesColorsWhite,this.logo=this.logoWhite):(this.particlesColors=this.particlesColorsBlack,this.logo=this.logoBlack),this.originalColors?this.particlesColors[0]="#E7322A":this.particlesColors[0]=this.colors[0],this.clear(),this.drawParticles(this.bgParticles),this.drawParticles(this.mgParticles),this.drawParticles(this.fgParticles),this.originalColors&&(t=this.logo.width*this.logoScale,i=this.logo.height*this.logoScale,this.ctx.drawImage(this.logo,(this.width-t)/2,(this.height-i)/2,t,i))}resize(){this.width=this.canvas.width,this.height=this.canvas.height,this.bgParticles=[],this.mgParticles=[],this.fgParticles=[],this.spawnParticles(0,0,this.width,this.height)}getSettings(){return[{prop:"particlesDensity",type:"float",min:0,max:2,step:.1,toCall:"resize"},{prop:"connectionThreshold",type:"float",min:0,max:250,step:1},{prop:"originalColors",type:"bool"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],16:[function(t,i,e){var s=t("../animation");let n=t("../utils"),r=t("../delaunay");class a extends s{constructor(t,i,e,s,a=2e-4,r=!0,n=!1,h=125){super(t,i,e,s,"Delaunay triangulation for a cloud of particles","network.js",`
In this animation, the Delaunay triangulation algorithm 
is applied to a set of moving particles (points).
Then if the edge length between two points is below a threshold value,
a line is drawn between them, creating a network-like structure.

You can read about the Delaunay triangulation on [Wikipedia](https://en.wikipedia.org/wiki/Delaunay_triangulation)

Source of Delaunay triangulation implementation used in this animation
can be found in this [repository](https://github.com/darkskyapp/delaunay-fast).
`),this.particlesDensity=a,this.fillTriangles=r,this.drawParticles=n,this.distanceThreshold=h,this.width=0,this.height=0,this.particles=[],this.mouseDown=!1,this.mouseParticle={x:0,y:0,color:null}}drawTriangle(t,i,e){var s=Math.max(n.distVec2d(t,i),n.distVec2d(t,i),n.distVec2d(i,e));s>this.distanceThreshold||(this.ctx.beginPath(),n.pathClosedShape(this.ctx,[t,i,e]),i=n.lerpColor(t.color,this.bgColor,n.easeInSine(s/this.distanceThreshold)),this.fillTriangles?(this.ctx.fillStyle=i,this.ctx.fill()):(this.ctx.lineWidth=1,this.ctx.strokeStyle=i,this.ctx.stroke()))}update(t){super.update(t);for(var i of this.particles)i.x+=i.velX*t*this.speed,i.y+=i.velY*t*this.speed,(i.x<0||i.x>this.width)&&(i.velX*=-1),(i.y<0||i.y>this.height)&&(i.velY*=-1)}draw(){if(this.clear(),this.mouseDown&&this.particles.push(this.mouseParticle),0<this.particles.length){var i=r.triangulate(this.particles.map(function(t){return[t.x,t.y]}));for(let t=0;t<i.length;t+=3){var e=this.particles[i[t]],s=this.particles[i[t+1]],a=this.particles[i[t+2]];this.drawTriangle(e,s,a)}}if(this.drawParticles)for(var t of this.particles)n.fillCircle(this.ctx,t.x,t.y,2,t.color);this.mouseDown&&this.particles.pop()}spawnParticles(i,e,s,a){var r=s*a*this.particlesDensity;for(let t=0;t<r;t++)this.particles.push({x:this.rand()*s+i,y:this.rand()*a+e,velY:(2*this.rand()-1)/30,velX:(2*this.rand()-1)/30,color:n.randomChoice(this.colors,this.rand)})}restart(){this.particles=[],this.width=this.canvas.width,this.height=this.canvas.height,this.spawnParticles(0,0,this.width,this.height)}resize(){var t=this.canvas.width-this.width,i=this.canvas.height-this.height;0<t&&this.spawnParticles(this.width,0,t,this.height),0<i&&this.spawnParticles(0,this.height,this.width,i),(0<t||0<i)&&this.spawnParticles(this.width,this.height,t,i),this.width=this.canvas.width,this.height=this.canvas.height;let e=this.width,s=this.height;this.particles=this.particles.filter(function(t){return!(t.x<0||t.x>e||t.y<0||t.y>s)})}mouseAction(t,i){"down"===i?(this.mouseDown=!0,this.mouseParticle.color=n.randomChoice(this.colors,this.rand)):"up"===i?this.mouseDown=!1:("down"===i||"move"===i&&this.mouseDown)&&(this.mouseParticle.x=t.x,this.mouseParticle.y=t.y)}getSettings(){return[{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.002,toCall:"restart"},{prop:"fillTriangles",type:"bool"},{prop:"drawParticles",type:"bool"},{prop:"distanceThreshold",type:"int",min:0,max:200},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.1,min:-4,max:4},{prop:"addAParticle",type:"text",value:"<hold mouse button/touch>"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../delaunay":33,"../utils":40}],17:[function(t,i,e){var s=t("../animation");let l=t("../utils");class a extends s{constructor(t,i,e,s,a=100,r=.07,n=.05,h=.5,o=1){super(t,i,e,s,"noisy lines","noisy-lines.js",`
Another animation based on Perlin noise. 
The lines are disorted by adding noise to the position of each vertex.
The disortion are larger as the vertices are further from the center.

Coded with no external dependencies, using only canvas API.
`),this.noiseXIncr=r,this.noiseYIncr=n,this.noiseRange=h,this.lines=a,this.speed=o,this.margin=.1}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var t=this.canvas.width/2,i=this.canvas.height/2,e=t*(1-this.margin),s=i*(1-this.margin),a=2*s/(this.lines-1);this.ctx.translate(t,i);let r=.3*this.time;for(let t=0;t<this.lines;++t){var n=-s+t*a;let i=.3*this.time;r+=this.noiseYIncr*a/5,this.ctx.beginPath();for(let t=-e;t<=e;t+=5){i+=this.noiseXIncr;var h=l.remap(this.noise.perlin2(i,r),-1,1,1-this.noiseRange,1),o=t*h,h=n*h;t==-e?this.ctx.moveTo(o,h):this.ctx.lineTo(o,h)}this.ctx.stroke()}this.ctx.resetTransform()}getSettings(){return[{prop:"lines",type:"int",min:2,max:250},{prop:"noiseXIncr",type:"float",min:-.2,max:.2,step:.001},{prop:"noiseYIncr",type:"float",min:-.2,max:.2,step:.001},{prop:"noiseRange",type:"float",min:0,max:1,step:.01},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",min:-8,max:8},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],18:[function(t,i,e){var s=t("../animation");let u=t("../utils");class a extends s{constructor(t,i,e,s,a=1e4,r="random",n=.03,h="random",o="random",l="random",c="random",d=!1,p=1,m=!1){super(t,i,e,s,"system of particles and attractors","particles-and-attractors.js",`
Very simple particle system with attractors.
In this system, distance and momentum are ignored.
The new velocity vector of a particle is calculated as the sum of angles
between the particle and all attractors.
Because the velocity does not depend on the distance to the attractors,
and momentum is not preserved, the particles are not "catapulted" away from the attractors.
This results in a system that is mesmerizing to watch.

Coded with no external dependencies, using only canvas API.
`),this.particles=[],this.numParticles=a,this.particlesSpeed=this.assignIfRandom(r,u.round(u.randomRange(.25,.5))),this.fadingSpeed=n,this.nextFadeStep=0,this.attractors=[],this.drawAttractors=d,this.numAttractors=this.assignIfRandom(h,u.randomInt(3,7)),this.centralAttractor=this.assignIfRandom(o,u.randomChoice([!1,!0])),this.attractorsSystems=["orbits","eights","circle"],this.attractorsSystem=this.assignIfRandom(l,u.randomChoice(this.attractorsSystems)),this.attractorsSpeed=this.assignIfRandom(c,u.round(u.randomRange(.05,.1)*u.randomChoice([-1,1]))),this.attractorsPosition=0,this.startingPosition=u.randomRange(0,10),this.directionScale=1,this.scale=p,this.rainbowColors=m,this.mouseDown=!1,this.mouseAttractor={x:0,y:0},this.setup()}setup(){this.particles=[];for(let t=0;t<this.numParticles;++t)this.particles.push(u.rotateVec2d({x:u.randomRange(1,100,this.rand),y:0,prevX:0,prevY:0},t))}update(i){super.update(i),this.nextFadeStep=this.fadingSpeed*i/33,this.attractorsPosition+=i/1e3*this.attractorsSpeed;var e,s=this.startingPosition+this.attractorsPosition,a=this.numAttractors+1-this.centralAttractor,r=1-this.centralAttractor;if(this.attractors=[],"orbits"===this.attractorsSystem){var n=Math.max(this.canvas.width,this.canvas.height)/(2*(this.numAttractors-1));for(let t=r;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(t*n,0),s*t))}else if("eights"===this.attractorsSystem){var h=Math.max(this.canvas.width,this.canvas.height)/this.numAttractors;for(let t=r;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(t*Math.sin(s*Math.PI/2)*h,0),s*t))}else if("circle"===this.attractorsSystem){this.centralAttractor&&this.attractors.push({x:0,y:0});var o=.4*Math.min(this.canvas.width,this.canvas.height);for(let t=1;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(o,0),2*(s+t)*Math.PI/(a-1)))}this.mouseDown&&this.attractors.push(this.mouseAttractor);for(e of this.particles){let t=0;for(var l of this.attractors)t+=Math.atan2(l.y-e.y,l.x-e.x)*this.directionScale;e.prevX=e.x,e.prevY=e.y,e.x+=Math.cos(t)*this.particlesSpeed*i,e.y+=Math.sin(t)*this.particlesSpeed*i}}draw(){this.fadeOut(this.nextFadeStep),this.ctx.translate(this.canvas.width/2,this.canvas.height/2),this.ctx.scale(this.scale,this.scale);var t,i=this.rainbowColors?`hsl(${this.time/5*360}, 100%, 75%)`:this.colors[0];for(t of this.particles)u.drawLine(this.ctx,t.prevX,t.prevY,t.x,t.y,1,i);if(this.drawAttractors)for(var e of this.attractors)u.fillCircle(this.ctx,e.x,e.y,5,this.colorsAlt[2]);this.ctx.resetTransform()}resize(){this.clear()}restart(){super.restart(),this.attractorsPosition=0,this.setup()}mouseAction(t,i){"down"===i?this.mouseDown=!0:"up"===i?this.mouseDown=!1:("down"===i||"move"===i&&this.mouseDown)&&(console.log("attractor!"),this.mouseAttractor={x:(t.x-this.canvas.width/2)/this.scale,y:(t.y-this.canvas.height/2)/this.scale})}updateColors(t,i,e){super.updateColors(t,i,e),this.resize()}getSettings(){return[{prop:"numParticles",type:"int",min:1e3,max:2e4,toCall:"setup"},{prop:"particlesSpeed",type:"float",min:.1,max:1.5},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},{prop:"attractorsSystem",type:"select",values:this.attractorsSystems},{prop:"numAttractors",type:"int",min:3,max:7},{prop:"centralAttractor",type:"bool"},{prop:"attractorsSpeed",type:"float",min:-.25,max:.25},{prop:"directionScale",type:"float",min:0,max:4},{prop:"addAnAttractor",type:"text",value:"<hold mouse button/touch>"},{prop:"drawAttractors",type:"bool"},{prop:"scale",icon:'<i class="fa-solid fa-maximize"></i>',type:"float",min:.05,max:1.95},{prop:"rainbowColors",icon:'<i class="fa-solid fa-rainbow"></i>',type:"bool"}]}}i.exports=a},{"../animation":2,"../utils":40}],19:[function(t,i,e){var s=t("../animation");let d=t("../utils");class a extends s{constructor(t,i,e,s,a=1500,r="random",n="random",h="random",o="random",l="random",c=1){super(t,i,e,s,"vortex of particles","particles-vortex.js",`
Particles vortex with randomized speed and direction.
The illusion of a 3D vortex is created by calculating the 2D position 
of each particle, each frame, using simple trigonometry functions.

Coded with no external dependencies, using only canvas API.
`),this.particles=a,this.radiusMin=50,this.radiusMax=250,this.radius=this.assignIfRandom(r,d.round(d.randomRange(this.radiusMin,this.radiusMax),2)),this.speedMin=.02,this.speedMax=.05,this.speed=this.assignIfRandom(n,d.round(d.randomRange(this.speedMin,this.speedMax)*d.randomChoice([-1,1]),2)),this.rotationSpeedMin=.01,this.rotationSpeedMax=.02,this.rotationSpeed=this.assignIfRandom(h,d.round(d.randomRange(this.rotationSpeedMin,this.rotationSpeedMax)*d.randomChoice([-1,1]),2)),this.dirMax=.75,this.dirX=this.assignIfRandom(o,d.round(d.randomRange(-this.dirMax,this.dirMax),2)),this.dirY=this.assignIfRandom(l,d.round(d.randomRange(-this.dirMax,this.dirMax),2)),this.scale=c}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var t=Math.min(this.canvas.width,this.canvas.height)/4,i=this.canvas.width/2+this.dirX*t,t=this.canvas.height/2+this.dirY*t,e=Math.round(1e4*this.time)/10;this.ctx.translate(i,t),this.ctx.scale(this.scale,this.scale),this.ctx.beginPath();for(let t=1;t<=this.particles;t++){var s=this.radius+Math.pow(t/(this.particles/1.5),2)*t/2,a=100*this.noise.perlin2(.1*t+e,.1)+e*this.rotationSpeed,r=Math.cos(a)*s+Math.sqrt(t*this.radius)*this.dirX,a=Math.sin(a)*s+Math.sqrt(t*this.radius)*this.dirY;d.pathCircle(this.ctx,r,a,.01*t)}this.ctx.stroke(),this.ctx.resetTransform()}getSettings(){return[{prop:"particles",type:"int",min:1,max:3e3},{prop:"radius",type:"float",min:this.radiusMin,max:this.radiusMax},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",min:-this.speedMax,max:this.speedMax},{prop:"rotationSpeed",type:"float",min:-this.rotationSpeedMax,max:this.rotationSpeedMax},{prop:"dirX",type:"float",min:-this.dirMax,max:this.dirMax},{prop:"dirY",type:"float",min:-this.dirMax,max:this.dirMax},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],20:[function(t,i,e){var s=t("../animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=.5,r=.01,n=.001,h=.02){super(t,i,e,s,"particles waves","particles-waves.js",`
"Particles waves" animation.
The effect was achieved by modifying Perlin noise animation.

Coded with no external dependencies, using only canvas API.
`),this.particlesSpeed=a,this.particlesDensity=r,this.noiseScale=n,this.fadingSpeed=h,this.nextFadeStep=0,this.particles=[],this.width=0,this.height=0}update(t){super.update(t),this.nextFadeStep=this.fadingSpeed*t/33;for(var i of this.particles){var e=2*this.noise.perlin3(i.x*this.noiseScale*2,i.y*this.noiseScale*3,this.frame*this.noiseScale*3)*Math.PI;i.x+=100*this.particlesSpeed*Math.tan(e)*t/1e3,i.y+=100*this.particlesSpeed*Math.sin(e)*t/1e3,i.x<0&&(i.x=this.width),i.x>this.width&&(i.x=0),i.y<0&&(i.y=this.height),i.y>this.height&&(i.y=0)}}draw(){this.fadeOut(this.nextFadeStep);for(var t of this.particles)this.ctx.fillStyle=t.color,this.ctx.fillRect(t.x,t.y,1,1)}resize(){this.clear(),this.width=this.canvas.width,this.height=this.canvas.height;var i=this.width*this.height*this.particlesDensity;this.particles=[];for(let t=0;t<i;t++){var e=this.rand()*this.width,s=this.rand()*this.height;this.particles.push({x:e,y:s,color:a.lerpColor(this.colorA,this.colorB,e/this.width)})}}updateColors(t,i,e){super.updateColors(t,i,e),this.resize()}getSettings(){return[{prop:"particlesSpeed",type:"float",step:.01,min:.1,max:2},{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.05,toCall:"resize"},{prop:"noiseScale",type:"float",step:.001,min:.001,max:.01},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},this.getSeedSettings()]}}i.exports=r},{"../animation":2,"../utils":40}],21:[function(t,i,e){var s=t("../animation");let l=t("../utils");class a extends s{constructor(t,i,e,s,a=7e-4,r="random",n="random",h="random",o=0){super(t,i,e,s,"particles moving through Perlin noise","perlin-noise-particles.js",`
Particles moving through Perlin noise.

Coded with no external dependencies, using only canvas API.
`),this.particlesDensity=a,this.noiseScale=this.assignIfRandom(r,l.randomChoice([.001,.002,.003])),this.particlesSpeed=this.assignIfRandom(n,l.randomChoice([1,1.5,2])),this.particlesSize=this.assignIfRandom(h,l.randomChoice([1,1.5,2])),this.fadingSpeed=o,this.width=0,this.height=0,this.particles=[],this.imageData=null}update(t){this.time+=t/1e3,++this.frame;let i=1,e=this.particlesSpeed;for(;1<e;)e/=2,i*=2;for(var s of this.particles)s.prevX=s.x,s.prevY=s.y;for(let t=0;t<i;++t)for(var a of this.particles){var r=2*this.noise.perlin2(a.x*this.noiseScale,a.y*this.noiseScale)*Math.PI/this.noiseScale;a.x+=Math.cos(r)*a.speed*e,a.y+=Math.sin(r)*a.speed*e}}draw(){this.fadeOut(this.fadingSpeed);for(var t of this.particles)l.drawLine(this.ctx,t.prevX,t.prevY,t.x,t.y,2*t.radius*this.particlesSize,t.color);this.imageData=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height)}spawnParticles(i,e,s,a){var r=s*a*this.particlesDensity;for(let t=0;t<r;t++){var n=this.rand()*s+i,h=this.rand()*a+e;this.particles.push({x:n,y:h,prevX:n,prevY:h,speed:.2*this.rand()+.1,radius:.5*this.rand()+.5,color:l.randomChoice(this.colors,this.rand)})}}restart(){super.restart(),this.clear(),this.particles=[],this.width=this.canvas.width,this.height=this.canvas.height,this.spawnParticles(0,0,this.width,this.height)}resize(){this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0);var t=this.canvas.width-this.width,i=this.canvas.height-this.height;0<t&&this.spawnParticles(this.width,0,t,this.height),0<i&&this.spawnParticles(0,this.height,this.width,i),(0<t||0<i)&&this.spawnParticles(this.width,this.height,t,i),this.width=this.canvas.width,this.height=this.canvas.height;let e=this.width,s=this.height;this.particles=this.particles.filter(function(t){return!(t.x<0||t.x>e||t.y<0||t.y>s)})}updateColors(t,i,e){super.updateColors(t,i,e),this.restart()}getSettings(){return[{prop:"noiseScale",type:"float",step:.001,min:.001,max:.01,toCall:"restart"},{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.005,toCall:"restart"},{prop:"particlesSpeed",type:"float",min:.25,max:32},{prop:"particlesSize",type:"float",step:.1,min:1,max:4},{prop:"fadingSpeed",type:"float",step:1e-4,min:0,max:.01},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],22:[function(t,i,e){var s=t("../animation");let d=t("../utils");class a extends s{constructor(t,i,e,s,a=1,r=.4,n=!1,h=.002,o={x:"random",y:"random",z:1},l=.01,c=!0){super(t,i,e,s,"quadtree visualization","quadtree.js",`
Visualization of quadtree for points generated by thresholding Perlin noise.
Quadtree is a data structure that is 2-dimensional, special variant of k-d trees.

You can read about quadtree on [Wikipedia](https://en.wikipedia.org/wiki/Quadtree).

Coded with no external dependencies, using only canvas API.
`),this.pointsDensity=r,this.drawPoints=n,this.maxPointsInNode=a,this.noiseThreshold=l,this.drawLeafNodes=c,this.noiseScale=h,this.noiseSpeed=o,this.noiseSpeed.x=this.assignIfRandom(this.noiseSpeed.x,d.round(d.randomRange(-1,1),1)),this.noiseSpeed.y=this.assignIfRandom(this.noiseSpeed.y,d.round(d.randomRange(-1,1),1)),this.minNodeSize=4,this.width=0,this.height=0,this.noisePos={x:0,y:0,z:0}}update(t){this.noisePos.x+=this.noiseSpeed.x*t/1e3*10,this.noisePos.y+=this.noiseSpeed.y*t/1e3*10,this.noisePos.z+=this.noiseSpeed.z*t/1e3*.05,super.update(t)}generatePoints(){var e=[],s=1/this.pointsDensity,a=s/2,r=d.Mulberry32(this.seed);for(let i=a;i<this.width;i+=s)for(let t=a;t<this.height;t+=s){var n=this.noise.perlin3((i+this.noisePos.x)*this.noiseScale,(t+this.noisePos.y)*this.noiseScale,this.noisePos.z);Math.abs(n)<=this.noiseThreshold&&e.push({x:i-a+r()*s,y:t-a+r()*s})}return e}quadTree(t,i,e,s,a){var r=e/2,n=e/4;if(s.length<=this.maxPointsInNode||e<=this.minNodeSize)(e>this.minNodeSize||this.drawLeafNodes)&&this.ctx.strokeRect(t-r,i-r,e,e);else{var h,o=[],l=[],c=[],d=[];for(h of s)h.x<t&&h.y>=i?o.push(h):h.x>=t&&h.y>=i?l.push(h):h.x>=t&&h.y<i?d.push(h):h.x<t&&h.y<i&&c.push(h);this.quadTree(t+n,i+n,r,l,++a),this.quadTree(t+n,i-n,r,d,a),this.quadTree(t-n,i+n,r,o,a),this.quadTree(t-n,i-n,r,c,a)}}draw(){this.clear(),this.width=this.canvas.width,this.height=this.canvas.height;var t=Math.max(this.width,this.height),i=this.generatePoints();if(this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0],this.quadTree(this.width/2,this.height/2,t,i,0),this.drawPoints)if(this.ctx.fillStyle=this.colorsAlt[1],this.pointsDensity<.5)for(var e of i)d.fillCircle(this.ctx,e.x,e.y,2,this.colorsAlt[1]);else for(var s of i)this.ctx.fillRect(s.x,s.y,2,2)}restart(){this.noisePos={x:0,y:0,z:0},super.restart()}getSettings(){return[{prop:"maxPointsInNode",type:"int",min:1,max:16},{prop:"pointsDensity",type:"float",step:.1,min:.1,max:.7},{prop:"noiseScale",type:"float",step:1e-4,min:5e-4,max:.0125},{prop:"noiseSpeed.x",type:"float",step:.1,min:-10,max:10},{prop:"noiseSpeed.y",type:"float",step:.1,min:-10,max:10},{prop:"noiseSpeed.z",type:"float",step:.1,min:-10,max:10},{prop:"noiseThreshold",type:"float",min:0,max:.15,step:.001},{prop:"drawLeafNodes",type:"bool"},{prop:"drawPoints",type:"bool"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],23:[function(t,i,e){var s=t("../animation");let n=t("../animation-queue"),l=t("../utils");class h{constructor(t,i,e,s,a){this.x=t,this.y=i,this.squaresPerSide=e,this.squares=e*e,this.depth=s,this.rand=a,this.createChildren()}createChildren(){this.animQueue=new n,this.children=[],this.positions=[],this.freePosIdx=this.squares-1,this.prevFreePosIdx=this.squares-1;for(let i=0;i<this.squaresPerSide;++i)for(let t=0;t<this.squaresPerSide;++t){var e=t*this.squaresPerSide+i,s=i/this.squaresPerSide,a=t/this.squaresPerSide,r=[];0<=i-1&&r.push(e-1),i+1<this.squaresPerSide&&r.push(e+1),0<=t-1&&r.push(e-this.squaresPerSide),t+1<this.squaresPerSide&&r.push(e+this.squaresPerSide),this.positions[e]={x:s,y:a,neighbors:r},i==this.squaresPerSide-1&&t==this.squaresPerSide-1||0==this.depth||(r=new h(s,a,this.squaresPerSide,this.depth-1,this.rand),this.positions[e].child=r,this.children.push(r))}}update(t){if(0!==this.children.length){for(var i of this.children)i.update(t);for(;0<this.animQueue.step(t);){let e=this.positions[this.freePosIdx],t=this.prevFreePosIdx;for(;t===this.prevFreePosIdx;)t=l.randomChoice(e.neighbors,this.rand);let s=this.positions[t],a=s.child,r=this.depth/2,n=(s.child=null,e.child=a,this.prevFreePosIdx=this.freePosIdx,this.freePosIdx=t,l.easeInOutSine);this.animQueue.push(function(t){var i=Math.min(t,r)/r;return a.x=l.lerp(s.x,e.x,n(i)),a.y=l.lerp(s.y,e.y,n(i)),t-r})}}}draw(t,i,e,s){if(s||e||t.strokeRect(0,0,i,i),0===this.children.length)e&&(s?t.fillRect(2,2,i-2,i-2):t.strokeRect(4,4,i-4,i-4));else for(var a of this.children)t.save(),t.translate(a.x*i,a.y*i),a.draw(t,i/this.squaresPerSide,e,s),t.restore()}}class a extends s{constructor(t,i,e,s,a=5,r=3,n=1,h="padded stroke",o=!1){super(t,i,e,s,"recursive squares","recursion-squares.js",`
Simple recursive animation. 
Each rectangle contains three smaller squares, which move around.
One randomly chosen rectangle is always moving to the empty space.

Coded with no external dependencies, using only canvas API.
`),this.squaresPerSide=a,this.depth=r,this.speed=n,this.squareStyles=["padded fill","padded stroke","stroke"],this.squareStyle=this.assignIfRandom(h,l.randomChoice(this.squareStyles)),this.contain=o,this.createSquares()}createSquares(){let t=this.depth;for(;2048<Math.pow(this.squaresPerSide,t+1);)--t;this.mainSquare=new h(0,0,this.squaresPerSide,t,this.rand)}update(t){t=t/1e3*this.speed,this.mainSquare.update(t)}draw(){this.clear();let t=0,i=!1,e=!1;this.contain?(t=Math.min(this.canvas.width,this.canvas.height),this.ctx.translate((this.canvas.width-t)/2,(this.canvas.height-t)/2)):t=Math.max(this.canvas.width,this.canvas.height),this.ctx.lineWidth=1,"padded stroke"===this.squareStyle&&(this.ctx.lineWidth=2),this.squareStyle.startsWith("padded")&&(e=!0),"padded fill"===this.squareStyle&&(i=!0),this.ctx.strokeStyle=this.colors[0],this.ctx.fillStyle=this.colors[0],this.mainSquare.draw(this.ctx,t,e,i),this.ctx.resetTransform()}restart(){super.restart(),this.createSquares()}getSettings(){return[{prop:"squaresPerSide",type:"int",min:2,max:6,toCall:"restart"},{prop:"depth",type:"int",min:2,max:8,toCall:"restart"},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.25,min:.5,max:8},{prop:"squareStyle",type:"select",values:this.squareStyles},{prop:"contain",name:"contained fit",type:"bool"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../animation-queue":1,"../utils":40}],24:[function(t,i,e){var s=t("../grid-animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=9,r=3,n=3){super(t,i,e,s,"rock-paper-scissors automata","rock-paper-scissors-automata.js",`
Rock-paper-scissors automata.

This cellular automata adapts the rules of the rock-paper-scissors game 
(one type beats one state but loses to another).
If the cell has more than a defined number of neighbors with the state it losses to, 
it changes its state to that state.

My other cellular automata visualizations:
- [Conway's game of life](https://mwydmuch.pl/animations?animation=game-of-life)
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [day and night](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [sand automata](https://mwydmuch.pl/animations?animation=sand-automata)

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.numStates=r,this.minimumLosses=n}update(t){super.update(t);for(let i=0;i<this.gridWidth;++i)for(let t=0;t<this.gridHeight;++t){var e=this.getIdx(i,t),s=this.grid[e],a=(s+1)%this.numStates,r=Array(this.numStates).fill(0);++r[this.getValWrap(i-1,t-1)],++r[this.getValWrap(i,t-1)],++r[this.getValWrap(i+1,t-1)],++r[this.getValWrap(i-1,t)],++r[this.getValWrap(i+1,t)],++r[this.getValWrap(i-1,t+1)],++r[this.getValWrap(i,t+1)],++r[this.getValWrap(i+1,t+1)],r[a]>=this.minimumLosses?this.gridNext[e]=a:this.gridNext[e]=s}[this.grid,this.gridNext]=[this.gridNext,this.grid]}draw(){a.clear(this.ctx,this.colors[0]);for(let i=0;i<this.gridWidth;++i)for(let t=0;t<this.gridHeight;++t){var e=this.getVal(i,t);e&&(this.ctx.fillStyle=this.colors[e],this.ctx.fillRect(i*this.cellSize,t*this.cellSize,this.cellSize,this.cellSize))}}newCellState(t,i){return a.randomInt(0,this.numStates,this.rand)}resize(){var t=Math.ceil(this.canvas.width/this.cellSize),i=Math.ceil(this.canvas.height/this.cellSize);this.resizeGrid(t,i)}getSettings(){return[{prop:"cellSize",type:"int",min:4,max:12,toCall:"resize"},{prop:"numStates",name:"number of states",type:"int",min:2,max:6,toCall:"restart"},{prop:"minimumLosses",name:"minimum number of losses",type:"int",min:0,max:8},this.getSeedSettings()]}}i.exports=r},{"../grid-animation":34,"../utils":40}],25:[function(t,i,e){var s=t("../grid-animation");let d=t("../utils");class a extends s{constructor(t,i,e,s,a=5,r=!0,n=5){super(t,i,e,s,"sand automata","sand-automata.js",`
The visualization of a sand automata, that is a simple model of falling sand.

There are many variations of this automata.
This one is updated in place, from the bottom to the top.
The cell can "fall" down to the cell below it if the cell below is empty. 
If not, it can move to the below left or right cell if one of those cells is empty.
To reduce the bias of falling to the left or right, 
the cells in each row are updated in random order.

It generates random Tetris blocks and lets them fall to demonstrate
the properties of automata.

My other cellular automata visualizations:
- [Conway's game of life](https://mwydmuch.pl/animations?animation=game-of-life)
- [Brain's brain](https://mwydmuch.pl/animations?animation=brains-brain-automata)
- [day and night](https://mwydmuch.pl/animations?animation=day-and-night-automata)
- [isometric game of life](https://mwydmuch.pl/animations?animation=game-of-life-isometric)
- [rock paper scissors](https://mwydmuch.pl/animations?animation=rock-paper-scissors-automata)

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.spawnTetrisBlocks=r,this.tetrisBlocksSize=n,this.maxBlockSize=16,this.updateOrder=null,this.toRedraw=[],this.redrawAll=!1,this.mouseDown=!1,this.mouseCellCord=0,this.mouseValue=0,this.blocksTemplates=[["XXXX"],["X","X","X","X"],["XX "," XX"],["X ","XX"," X"],[" XX","XX "],[" X","XX","X "],["XX","XX"],["XX","XX"],["XXX"," X "],[" X ","XXX"],["X ","XX","X "],[" X","XX"," X"],["XXX","  X"],["X  ","XXX"],["XX","X ","X "],[" X"," X","XX"],["XXX","X  "],["  X","XXX"],["X ","X ","XX"],["XX"," X"," X"]],this.generateBlocks()}generateBlocks(){this.blocks=[];for(var i of this.blocksTemplates){var s=[];for(let t=0;t<i.length*this.tetrisBlocksSize;++t)s.push([]);for(let e=0;e<i.length;++e)for(let t=0;t<i[e].length;++t){var a="X"==i[e][t];for(let i=0;i<this.tetrisBlocksSize;++i)for(let t=0;t<this.tetrisBlocksSize;++t)s[e*this.tetrisBlocksSize+i].push(a)}this.blocks.push(s)}}update(t){if(super.update(t),this.frame%30==0&&this.spawnTetrisBlocks){var e=d.randomChoice(this.blocks,this.rand),s=d.randomInt(0,this.gridWidth-e[0].length,this.rand),a=d.randomInt(0,this.colors.length,this.rand)+1;for(let i=0;i<e[0].length;++i)for(let t=0;t<e.length;++t){var r=this.getIdx(s+i,t),n=e[t][i];this.grid[r]=n*a-1}}this.mouseDown&&(this.grid[this.mouseCellCord]=this.mouseValue,this.toRedraw[this.mouseCellCord]=1);for(let i=this.gridHeight-2;0<=i;--i){d.randomShuffle(this.updateOrder,this.rand);for(let t=0;t<this.gridWidth;++t){var h,o=this.updateOrder[t],l=this.getIdx(o,i),c=this.grid[l];c<0||(h=this.getIdx(o,i+1),this.grid[h]<0?(this.grid[l]=-1,this.grid[h]=c,this.toRedraw[l]=2,this.toRedraw[h]=2):(h=this.getIdxWrap(o-1,i+1),this.grid[h]<0?(this.grid[l]=-1,this.grid[h]=c,this.toRedraw[l]=2,this.toRedraw[h]=2):(h=this.getIdxWrap(o+1,i+1),this.grid[h]<0&&(this.grid[l]=-1,this.grid[h]=c,this.toRedraw[l]=2,this.toRedraw[h]=2))))}}}draw(){for(let i=0;i<this.gridWidth;++i)for(let t=4*this.tetrisBlocksSize;t<this.gridHeight;++t){var e=this.getIdx(i,t),s=this.grid[e],a=this.toRedraw[e],r=t-4*this.maxBlockSize;1<=a&&0<=s?(this.ctx.fillStyle=this.colors[s],this.ctx.fillRect(i*this.cellSize,r*this.cellSize,this.cellSize,this.cellSize),this.toRedraw[e]=0):2<=a&&(this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(i*this.cellSize,r*this.cellSize,this.cellSize,this.cellSize),this.toRedraw[e]=0)}}resize(){var e=Math.ceil(this.canvas.width/this.cellSize),t=Math.ceil(this.canvas.height/this.cellSize)+4*this.maxBlockSize,s=new Array(e*t),a=(s.fill(-1),Math.min(this.gridHeight,t)),r=Math.min(this.gridWidth,e);for(let i=0;i<a;++i)for(let t=0;t<r;++t)s[t+i*e]=this.grid[this.getIdx(t,i)];delete this.grid,this.grid=s,this.gridWidth=e,this.gridHeight=t,this.toRedraw=new Array(this.gridWidth*this.gridHeight),this.toRedraw.fill(1),this.updateOrder=new Array(this.gridWidth);for(let t=0;t<this.gridWidth;++t)this.updateOrder[t]=t;this.clear()}mouseAction(t,i){"down"===i?(this.mouseDown=!0,this.mouseValue=this.mouseValue%this.colors.length+1):"up"===i&&(this.mouseDown=!1),("down"===i||"move"===i&&this.mouseDown)&&(i=Math.floor(t.x/this.cellSize),t=Math.floor(t.y/this.cellSize),this.mouseCellCord=i+(t+4*this.maxBlockSize)*this.gridWidth,this.grid[this.mouseCellCord]<0)&&(this.grid[this.mouseCellCord]=this.mouseValue,this.toRedraw[this.mouseCellCord]=1,this.draw())}getSettings(){return[{prop:"cellSize",type:"int",min:2,max:12,toCall:"resize"},{prop:"spawnTetrisBlocks",type:"bool"},{prop:"tetrisBlocksSize",type:"int",min:1,max:this.maxBlockSize,toCall:"generateBlocks"},{prop:"spawnASand",type:"text",value:"<click/touch>"},this.getSeedSettings()]}}i.exports=a},{"../grid-animation":34,"../utils":40}],26:[function(t,i,e){var s=t("../animation");let d=t("../utils"),a=t("../queue");class r extends s{constructor(t,i,e,s,a=12,r="A*",n="random",h=1,o=!0,l="random",c=!1){super(t,i,e,s,"finding the shortest path in a grid world","shortest-path.js",`
Animation showing the process of finding the shortest path
in the grid world by BFS or A* algorithm.

In the 8-way variant, horizontal or vertical moves have a length (cost) of 1 
while diagonal moves have a length of sqrt(2).

The map is generated by recursively dividing rectangular rooms.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.speed=h,this.autoRestart=o,this.showStats=c,this.searchAlgorithms=["BFS","A*"],this.searchAlgorithm=this.assignIfRandom(r,d.randomChoice(this.searchAlgorithms)),this.movementTypes=["4-dir","8-dir"],this.movementType=this.assignIfRandom(n,d.randomChoice(this.movementTypes)),this.cellStyles=["sharp","rounded"],this.cellStyle=this.assignIfRandom(l,d.randomChoice(this.cellStyles)),this.updateName(),this.queue=null,this.visited=0,this.mapWidth=0,this.mapHeight=0,this.map=null,this.dist=null,this.prev=null,this.pathLenght=0}updateName(){this.name=`finding the shortest path using ${this.searchAlgorithm} algorithm`}getIdx(t,i){return t+i*this.mapWidth}getXY(t){return d.createVec2d(t%this.mapWidth,Math.floor(t/this.mapWidth))}isWall(t,i){return t<0||t>=this.mapWidth||i<0||i>=this.mapHeight||1===this.map[this.getIdx(t,i)]}minDistance(t,i){var e=Math.abs(t.x-i.x),t=Math.abs(t.y-i.y);return"4-dir"===this.movementType?e+t:"8-dir"===this.movementType?(i=Math.min(e,t))*Math.sqrt(2)+e+t-2*i:0}expandNextNode(){var i=this.queue.pop();if(null!==i){++this.visited;var e,s=i.key,a=this.getXY(s),i=this.map[s];this.pathLenght=Math.max(this.pathLenght,this.dist[s]);let t=[];if("4-dir"===this.movementType&&(t=[this.getIdx(a.x-1,a.y),this.getIdx(a.x,a.y-1),this.getIdx(a.x+1,a.y),this.getIdx(a.x,a.y+1)]),"8-dir"===this.movementType&&(t=[this.getIdx(a.x-1,a.y),this.getIdx(a.x-1,a.y-1),this.getIdx(a.x,a.y-1),this.getIdx(a.x+1,a.y-1),this.getIdx(a.x+1,a.y),this.getIdx(a.x+1,a.y+1),this.getIdx(a.x,a.y+1),this.getIdx(a.x-1,a.y+1)]),2!==i&&3!==i)this.map[s]=5;else if(3===i){let t=this.prev[s];for(;0<=this.prev[t];)this.map[t]=6,t=this.prev[t];return this.pathLenght=this.dist[s],void this.queue.clear()}for(e of t){var r,n=this.map[e],h=this.getXY(e),o=this.dist[s]+this.minDistance(a,h);1!==n&&o<this.dist[e]&&("BFS"===this.searchAlgorithm?this.queue.push({key:e,value:o}):"A*"===this.searchAlgorithm&&(r=this.getXY(this.goalIdx),h=this.minDistance(h,r),this.queue.push({key:e,value:o+h})),3!==n&&(this.map[e]=4),this.dist[e]=o,this.prev[e]=s)}}}update(t){for(let t=0;t<this.speed;++t)this.expandNextNode(),++this.frame;this.autoRestart&&this.frame>=this.visited+300&&this.setupMaze()}drawWallCell(t,i,e){var s,a,r,n,h,o,l;"sharp"===this.cellStyle?(s=this.isWall(t-1,i)?0:e,a=this.isWall(t+1,i)?0:e,r=this.isWall(t,i-1)?0:e,n=this.isWall(t,i+1)?0:e,this.ctx.fillRect(t*this.cellSize+s,i*this.cellSize+r,this.cellSize-s-a,this.cellSize-r-n)):"rounded"===this.cellStyle&&(this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,i*this.cellSize+this.cellSize/2,this.cellSize/2-e,0,2*Math.PI,!1),this.ctx.fill(),s=this.cellSize/2,a=t*this.cellSize,r=i*this.cellSize,n=(t+.5)*this.cellSize,h=(i+.5)*this.cellSize,o=(t+1)*this.cellSize,l=(i+1)*this.cellSize,this.isWall(t-1,i)&&this.ctx.fillRect(a,r+e,s,this.cellSize-2*e),this.isWall(t+1,i)&&this.ctx.fillRect(n,r+e,s,this.cellSize-2*e),this.isWall(t,i-1)&&this.ctx.fillRect(a+e,r,this.cellSize-2*e,s),this.isWall(t,i+1)&&this.ctx.fillRect(a+e,h,this.cellSize-2*e,s),this.isWall(t-1,i)&&this.isWall(t,i-1)&&(this.ctx.beginPath(),this.isWall(t-1,i-1)?this.ctx.rect(a,r,e,e):(this.ctx.arc(a,r,e,0,Math.PI/2,!1),this.ctx.lineTo(a+e,r+e),this.ctx.lineTo(a+e,r)),this.ctx.fill()),this.isWall(t-1,i)&&this.isWall(t,i+1)&&(this.ctx.beginPath(),this.isWall(t-1,i+1)?this.ctx.rect(a,l-e,e,e):(this.ctx.arc(a,l,e,1.5*Math.PI,0,!1),this.ctx.lineTo(a+e,l-e),this.ctx.lineTo(a,l-e)),this.ctx.fill()),this.isWall(t+1,i)&&this.isWall(t,i-1)&&(this.ctx.beginPath(),this.isWall(t+1,i-1)?this.ctx.rect(o-e,r,e,e):(this.ctx.arc(o,r,e,Math.PI/2,Math.PI,!1),this.ctx.lineTo(o-e,r+e),this.ctx.lineTo(o,r+e)),this.ctx.fill()),this.isWall(t+1,i))&&this.isWall(t,i+1)&&(this.ctx.beginPath(),this.isWall(t+1,i+1)?this.ctx.rect(o-e,l-e,e,e):(this.ctx.arc(o,l,e,Math.PI,1.5*Math.PI,!1),this.ctx.lineTo(o-e,l-e),this.ctx.lineTo(o-e,l)),this.ctx.fill())}drawNodeCell(t,i,e){var s;"sharp"===this.cellStyle?this.ctx.fillRect(t*this.cellSize+e,i*this.cellSize+e,this.cellSize-2*e,this.cellSize-2*e):"rounded"===this.cellStyle&&(this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,i*this.cellSize+this.cellSize/2,this.cellSize/2-e,0,2*Math.PI,!1),this.ctx.fill()),this.debug&&(this.ctx.fillStyle="black",e=this.getXY(this.goalIdx),e=d.round(this.minDistance({x:t,y:i},e),1),s=d.round(this.dist[this.getIdx(t,i)],1),this.ctx.fillText(s+"+"+e,t*this.cellSize,i*this.cellSize),this.ctx.fillText("="+d.round(s+e),t*this.cellSize,i*this.cellSize+20))}drawNodeConnection(t){var i=this.getXY(t),t=this.getXY(this.prev[t]);this.ctx.beginPath(),this.ctx.moveTo((i.x+.5)*this.cellSize,(i.y+.5)*this.cellSize),this.ctx.lineTo((t.x+.5)*this.cellSize,(t.y+.5)*this.cellSize),this.ctx.stroke()}draw(){this.clear(),this.ctx.translate(-(this.mapWidth*this.cellSize-this.canvas.width)/2,-(this.mapHeight*this.cellSize-this.canvas.height)/2);for(let i=0;i<this.mapHeight;++i)for(let t=0;t<this.mapWidth;++t){var e=this.getIdx(t,i),s=this.map[e];0<=[4,5,6,3].indexOf(s)&&0<=this.prev[e]&&(4===s?this.ctx.strokeStyle=this.colors[2]:5===s?this.ctx.strokeStyle=this.colors[1]:6!==s&&3!==s||(this.ctx.strokeStyle=this.colorsAlt[2]),this.drawNodeConnection(e))}for(let i=0;i<this.mapHeight;++i)for(let t=0;t<this.mapWidth;++t){var a=this.getIdx(t,i),a=this.map[a];1===a?(this.ctx.fillStyle=this.colors[0],this.drawWallCell(t,i,this.cellSize/6)):2===a?(this.ctx.fillStyle=this.colorsAlt[0],this.drawNodeCell(t,i,1)):3===a?(this.ctx.fillStyle=this.colorsAlt[1],this.drawNodeCell(t,i,1)):4===a?(this.ctx.fillStyle=this.colors[2],this.drawNodeCell(t,i,this.cellSize/3)):5===a?(this.ctx.fillStyle=this.colors[1],this.drawNodeCell(t,i,this.cellSize/4)):6===a&&(this.ctx.fillStyle=this.colorsAlt[2],this.drawNodeCell(t,i,this.cellSize/6))}var t;this.ctx.resetTransform(),this.showStats&&(this.resetFont(),t=["Search algorithm: "+this.searchAlgorithm,"Number of visited nodes: "+this.visited,(0===this.queue.size?"Shortest path length: ":"Longest traveled path: ")+d.round(this.pathLenght)],this.drawTextLines(t,this.lineHeight,this.canvas.height-(t.length+1)*this.lineHeight))}recursiveMaze(i,e,s,a){var t=Math.floor(3),r=1-s/this.mapWidth,n=i+s,h=e+a,o=9<=s&&this.rand()>r*a/s,r=9<=a&&this.rand()>r;let l,c;if(o)for(;l=i+d.randomInt(t,s-t,this.rand),1!==this.map[this.getIdx(l,e-1)]||this.map[1!==this.getIdx(l,h)];);else l=i-1;if(r)for(;c=e+d.randomInt(t,a-t,this.rand),1!==this.map[this.getIdx(i-1,c)]||1!==this.map[this.getIdx(n,c)];);else c=h;if(o){for(let t=0;t<a;++t)this.map[this.getIdx(l,e+t)]=1;this.map[this.getIdx(l,d.randomInt(e,c,this.rand))]=0,r&&(this.map[this.getIdx(l,d.randomInt(c+1,h,this.rand))]=0),this.recursiveMaze(i,e,l-i,c-e),this.recursiveMaze(l+1,e,n-l-1,c-e)}if(r){for(let t=0;t<s;++t)this.map[this.getIdx(i+t,c)]=1;o&&(this.map[this.getIdx(d.randomInt(i,l,this.rand),c)]=0),this.map[this.getIdx(d.randomInt(l+1,n,this.rand),c)]=0,this.recursiveMaze(i,c+1,l-i,h-c-1),this.recursiveMaze(l+1,c+1,n-l-1,h-c-1)}}setupMaze(){this.mapWidth=Math.ceil(this.canvas.width/this.cellSize),this.mapHeight=Math.ceil(this.canvas.height/this.cellSize),this.mapSize=this.mapWidth*this.mapHeight,this.map=new Array(this.mapSize),this.dist=new Array(this.mapSize),this.prev=new Array(this.mapSize);for(let i=0;i<this.mapHeight;++i)for(let t=0;t<this.mapWidth;++t){var e=this.getIdx(t,i);0===t||t===this.mapWidth-1||0===i||i===this.mapHeight-1?this.map[e]=1:this.map[e]=0,this.dist[e]=999999,this.prev[e]=-1}for(this.recursiveMaze(1,1,this.mapWidth-2,this.mapHeight-2),this.startIdx=0,this.goalIdx=0;1===this.map[this.startIdx];)this.startIdx=this.getIdx(d.randomInt(1,this.mapWidth-1,this.rand),d.randomInt(1,this.mapHeight-1,this.rand));for(var t=this.getXY(this.startIdx),i=(this.mapHeight+this.mapWidth)/6;1===this.map[this.goalIdx]||this.minDistance(this.getXY(this.goalIdx),t)<i;)this.goalIdx=this.getIdx(d.randomInt(1,this.mapWidth-1,this.rand),d.randomInt(1,this.mapHeight-1,this.rand));this.setupStart()}resetMaze(){for(let i=0;i<this.mapHeight;++i)for(let t=0;t<this.mapWidth;++t){var e=this.getIdx(t,i);1!==this.map[e]&&(this.map[e]=0,this.dist[e]=999999,this.prev[e]=-1)}this.setupStart()}setupStart(){this.frame=0,this.visited=0,this.pathLenght=0,this.map[this.startIdx]=2,this.dist[this.startIdx]=0,this.map[this.goalIdx]=3,this.priorityQueue="A*"===this.searchAlgorithm,this.queue=new a(this.mapSize,this.priorityQueue),this.queue.push({key:this.startIdx,value:0}),this.updateName()}resize(){this.setSeed(this.seed),this.setupMaze()}restart(){this.resetMaze(),super.restart()}getSettings(){return[{prop:"searchAlgorithm",type:"select",values:this.searchAlgorithms,toCall:"restart"},{prop:"movementType",icon:'<i class="fa-solid fa-arrows-up-down-left-right"></i>',type:"select",values:this.movementTypes,toCall:"restart"},{prop:"cellSize",type:"int",min:8,max:48,toCall:"resize"},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"int",min:1,max:64},{prop:"autoRestart",icon:'<i class="fa-solid fa-clock-rotate-left"></i>',type:"bool"},{prop:"cellStyle",type:"select",values:this.cellStyles},{prop:"showStats",icon:'<i class="fa-solid fa-circle-info"></i>',type:"bool"},this.getSeedSettings("resize")]}}i.exports=r},{"../animation":2,"../queue":37,"../utils":40}],27:[function(t,i,e){var s=t("../animation");let a=t("../utils");class r extends s{constructor(t,i,e,s,a=48,r=12,n=!1){super(t,i,e,s,"grid of sine waves","sine-waves.js",`
Grid of random sine waves.
The interesting "effects" for some waves is the artifact of drawing procedure
that draw lines between coordinates that are evenly distributed on the x-axis.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.cellMargin=r,this.rotateCells=n,this.speed=.5,this.gridWidth=0,this.gridHeight=0,this.waves=[]}drawWave(i,e,s,a,r){this.ctx.beginPath(),this.ctx.moveTo(i-this.cellSize/2,e+Math.sin(r)*a);for(let t=0;t<this.cellSize;++t)this.ctx.lineTo(i-this.cellSize/2+t,e+Math.sin(t/this.cellSize*2*Math.PI*s+r)*a);this.ctx.stroke()}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var i=this.gridCellsWidth*this.gridCellsHeight;this.rotateCells||this.ctx.translate(this.canvas.width/2,this.canvas.height/2);for(let t=0;t<i;++t){var e=this.cellMargin+t%this.gridCellsWidth*this.cellTotalSize-this.gridWidth/2+this.cellSize/2,s=this.cellMargin+Math.floor(t/this.gridCellsWidth)*this.cellTotalSize-this.gridHeight/2+this.cellSize/2,a=this.waves[t];this.ctx.strokeStyle=a.color,this.rotateCells?(this.ctx.translate(this.canvas.width/2,this.canvas.height/2),this.ctx.translate(e,s),this.ctx.rotate(2*a.rotation*Math.PI),this.drawWave(0,0,a.freq,this.cellSize*a.noise*.5,a.noise*Math.PI+this.time*Math.PI),this.ctx.resetTransform()):this.drawWave(e,s,a.freq,this.cellSize*a.noise*.5,a.noise*Math.PI+this.time*Math.PI)}this.rotateCells||this.ctx.resetTransform()}resize(){this.cellTotalSize=this.cellMargin+this.cellSize,this.gridCellsWidth=Math.floor((this.canvas.width-this.cellMargin)/this.cellTotalSize),this.gridCellsHeight=Math.floor((this.canvas.height-this.cellMargin)/this.cellTotalSize),this.gridWidth=this.cellMargin+this.gridCellsWidth*this.cellTotalSize,this.gridHeight=this.cellMargin+this.gridCellsHeight*this.cellTotalSize;var i=Math.max(0,this.gridWidth*this.gridHeight-this.waves.length);for(let t=0;t<i;++t)this.waves.push({freq:Math.pow(2,8*this.rand())*a.randomChoice([-1,1],this.rand),noise:this.rand(),rotation:this.rand(),color:a.randomChoice(this.colors,this.rand)})}restart(){this.waves=[],this.gridWidth=0,this.gridHeight=0,super.restart()}getSettings(){return[{prop:"cellSize",type:"int",min:16,max:256,toCall:"resize"},{prop:"cellMargin",type:"int",min:8,max:32,toCall:"resize"},{prop:"rotateCells",type:"bool"},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.1,min:-4,max:4},this.getSeedSettings()]}}i.exports=r},{"../animation":2,"../utils":40}],28:[function(t,i,e){var s=t("../animation");let o=t("../animation-queue"),p=t("../utils");class a{constructor(t,i,e,s,a,r){this.arr=t,this.moves=[],this.cmpCount=0,this.readCount=0,this.writeCount=0,this.name=i,this.worstComplexity=e,this.averageComplexity=s,this.bestComplexity=a,this.spaceComplexity=r,this.sort()}getName(){return this.name}getTimeComplexity(){return`worst: ${this.worstComplexity}, average: ${this.averageComplexity}, best: `+this.bestComplexity}getSpaceComplexity(){return this.spaceComplexity}comp(t,i,e){return i!==e&&(++this.cmpCount,this.readCount+=2,this.moves.push(["cmp",t[i],t[e]])),t[i].val-t[e].val}compVal(t,i){return t!==i&&(++this.cmpCount,this.readCount+=2,this.moves.push(["cmp",t,i])),t.val-i.val}swap(t,i,e){++this.swapCount,this.writeCount+=2,this.moves.push(["swap",[t[i],t[e]],[t[e],t[i]]]),[t[i],t[e]]=[t[e],t[i]]}rearrange(i,e,s){var a=[],r=[];for(let t=0;t<e.length;++t)a.push(this.arr[e[t]]),r.push(this.arr[s[t]]);for(let t=0;t<e.length;++t)i[e[t]]=r[t];this.moves.push(["swap",r,a]),2===e.length?this.writeCount+=2:this.writeCount+=2*e.length}sort(){}getMoves(){return this.moves}}class d extends a{constructor(t){super(t,"bubble sort","O(n^2)","O(n^2)","O(n)","O(1)")}sort(){var s=this.arr.length;for(let e=0;e<s;++e){let i=!0;for(let t=0;t<s-1-e;++t)0<this.comp(this.arr,t,t+1)&&(this.swap(this.arr,t,t+1),i=!1);if(i)break}}}class m extends a{constructor(t){super(t,"selection sort","O(n^2)","O(n^2)","O(n^2)","O(1)")}sort(){var s=this.arr.length;for(let e=0;e<s;++e){let i=e;for(let t=e;t<s;++t)0<this.comp(this.arr,i,t)&&(i=t);e!==i&&this.swap(this.arr,e,i)}}}class u extends a{constructor(t){super(t,"insertion sort","O(n^2)","O(n^2)","O(n)","O(1)")}sort(){var t=this.arr.length;for(let i=1;i<t;++i){let t=i;for(;0<t&&this.comp(this.arr,t,t-1)<0;)this.swap(this.arr,t,t-1),--t}}}class g extends a{constructor(t){super(t,"merge sort","O(n log n)","O(n log n)","O(n log n)","O(n)")}sort(){this.mergeSort(0,this.arr.length-1)}mergeSort(t,i){var e;t<i&&(e=Math.floor((t+i)/2),this.mergeSort(t,e),this.mergeSort(e+1,i),this.merge(t,e,i))}merge(t,i,e){let s=t,a=i+1;if(!(this.comp(this.arr,i,a)<=0)){var r=[],n=[];for(let t=s;t<=e;++t)n.push(t);for(;s<=i&&a<=e;)this.comp(this.arr,s,a)<0?r.push(s++):r.push(a++);for(;s<=i;)r.push(s++);for(;a<=e;)r.push(a++);this.rearrange(this.arr,n,r)}}}class f extends a{constructor(t){super(t,"quick sort","O(n^2)","O(n log n)","O(n log n)","O(log n)")}sort(){this.quickSort(0,this.arr.length-1)}quickSort(t,i){var e;1<=i-t&&(t<(e=this.partition(t,i))-1&&this.quickSort(t,e-1),e<i)&&this.quickSort(e,i)}partition(t,i){for(var e=this.arr[Math.floor((i+t)/2)];t<=i;){for(;this.compVal(this.arr[t],e)<0;)++t;for(;0<this.compVal(this.arr[i],e);)--i;t<=i&&this.swap(this.arr,t++,i--)}return t}}class x extends a{constructor(t){super(t,"heap sort","O(n log n)","O(n log n)","O(n log n)","O(1)")}sort(){for(let t=Math.floor((this.arr.length-1)/2);0<=t;--t)this.heapify(this.arr.length,t);for(let t=this.arr.length-1;0<t;--t)this.swap(this.arr,0,t),this.heapify(t,0)}heapify(t,i){let e=i,s=2*i+1,a=2*i+2;s<t&&0<this.comp(this.arr,s,e)&&(e=s),(e=a<t&&0<this.comp(this.arr,a,e)?a:e)!==i&&(this.swap(this.arr,i,e),this.heapify(t,e))}}class v extends a{constructor(t){super(t,"gnome sort","O(n^2)","O(n^2)","O(n)","O(1)")}sort(){var t=this.arr.length;let i=0;for(;i<t;)0===i||0<=this.comp(this.arr,i,i-1)?++i:(this.swap(this.arr,i,i-1),--i)}}class w extends a{constructor(t){super(t,"shaker sort","O(n^2)","O(n^2)","O(n)","O(1)")}sort(){var s=this.arr.length;for(let e=0;e<s-1;++e){let i=!0;for(let t=0;t<s-1-e;++t)0<this.comp(this.arr,t,t+1)&&(this.swap(this.arr,t,t+1),i=!1);if(i)break;i=!0;for(let t=s-2-e;t>e;--t)this.comp(this.arr,t,t-1)<0&&(this.swap(this.arr,t,t-1),i=!1);if(i)break}}}class r extends s{constructor(t,i,e,s,a="random",r=96,n=2,h=.25,o=.25,l=1,c=!1){super(t,i,e,s,"sorting algorithm visualization","sorting.js",`
Animated visualization of different sorting algorithms.
Like many, sorting algorithms were one of the first things I studied in computer science.
Since then, I have found watching a nice visualization of sorting algorithms quite satisfying.

The animation first perform full sorting and records all the operations to the animation queue.

Coded with no external dependencies, using only canvas API.
`),this.numElements=r,this.elementPadding=n,this.cmpDuration=h,this.swapDuration=o,this.speed=l,this.showStats=c,this.sortAlgoNames=["selection sort","bubble sort","insertion sort","quick sort","merge sort","heap sort","gnome sort","shaker sort"],this.sortAlgoClasses=[m,d,u,f,g,x,v,w],this.sortingAlgorithm=this.assignIfRandom(a,p.randomChoice(this.sortAlgoNames)),this.initialOrderTypes=["random","sorted","reverse sorted","evens then odds","nearly sorted","few unique"],this.initialOrder="random",this.cmpTotal=0,this.cmpCount=0,this.accessTotal=0,this.accessCount=0,this.setup()}setup(){let e=this.numElements,i=(this.animQueue=new o,null);if(i="few unique"===this.initialOrder?Array.from({length:e},(t,i)=>(i%10+1)/10*e):Array.from({length:e},(t,i)=>i+1),["random","few unique"].includes(this.initialOrder)?p.randomShuffle(i,this.rand):"reverse sorted"===this.initialOrder?i=i.reverse():"evens then odds"===this.initialOrder&&(i=i.sort((t,i)=>t%2+t/(e+1)-(i%2+i/(e+1)))),"nearly sorted"===this.initialOrder){var s=Math.floor(e/5);for(let t=0;t<s;++t){var a=p.randomInt(0,e,this.rand),r=p.randomInt(0,e,this.rand);[i[a],i[r]]=[i[r],i[a]]}}this.elements=[];for(let t=0;t<e;++t){var n=i[t]/e,h=p.lerpColor(this.colors[0],this.colors[2],n);this.elements.push({val:n,pos:t,color:h,z:0})}var t=new this.sortAlgoClasses[this.sortAlgoNames.indexOf(this.sortingAlgorithm)](this.elements);this.moves=t.getMoves(),this.name=t.getName()+" algorithm visualization",this.timeComplexity=t.getTimeComplexity(),this.spaceComplexity=t.getSpaceComplexity(),this.cmpTotal=t.cmpCount,this.cmpCount=0,this.accessTotal=t.readCount+t.writeCount,this.accessCount=0}update(t){for(t=t/1e3*this.speed,this.time+=t,++this.frame;0<this.animQueue.step(t);){if(!this.moves.length)return;var d=this.moves[0];let l=t=>t<.5?p.easeInOutCubic(2*t):1-p.easeInOutCubic(2*t-1),c=p.easeInOutSine;if("cmp"===d[0]){let e=d[1],s=d[2],a=e.color,r=s.color,n=this.colorsAlt[3],h=this.cmpDuration;++this.cmpCount,this.accessCount+=2,this.animQueue.push(function(t){var i=Math.min(t,h)/h;return e.color=p.lerpColor(a,n,l(i)),s.color=p.lerpColor(r,n,l(i)),t-h})}else if("swap"===d[0]){let e=d[1],i=d[2],s=[],a=[],r=[],n=this.colorsAlt[1],h=this.frame,o=this.swapDuration*e.length;2===e.length?this.accessCount+=2:this.accessCount+=2*e.length;for(let t=0;t<e.length;++t)s.push(e[t].pos),a.push(i[t].pos),r.push(e[t].color);this.animQueue.push(function(t){var i=Math.min(t,o)/o;for(let t=0;t<e.length;++t)e[t].z=h,e[t].color=p.lerpColor(r[t],n,l(i)),e[t].pos=p.lerp(s[t],a[t],c(i));return t-o})}this.moves.shift()}}draw(){this.clear();var t,i,e=this.canvas.height,s=this.canvas.width/this.numElements;this.elements=this.elements.sort((t,i)=>t.z-i.z);for(t of this.elements){var a=t.pos*s+this.elementPadding/2,r=t.val*e;this.ctx.fillStyle=t.color,this.ctx.fillRect(a,0,s-this.elementPadding,r)}this.showStats&&(this.resetFont(),i=["Sorting algorithm: "+this.sortingAlgorithm,"Theoretical time complexity: "+this.timeComplexity,"Theoretical space complexity: "+this.spaceComplexity,"Number of elements: "+this.numElements,`Number of elements comparisons: ${this.cmpCount} / `+this.cmpTotal,`Number of array accesses (read/write): ${this.accessCount} / `+this.accessTotal],this.drawTextLines(i,this.lineHeight,this.canvas.height-(i.length+1)*this.lineHeight))}restart(){super.restart(),this.setup()}getSettings(){return[{prop:"initialOrder",icon:'<i class="fa-solid fa-chart-simple"></i>',type:"select",values:this.initialOrderTypes,toCall:"restart"},{prop:"sortingAlgorithm",type:"select",values:this.sortAlgoNames,toCall:"restart"},{prop:"numElements",label:"number of elements (n)",type:"int",min:8,max:256,toCall:"restart"},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.25,min:.5,max:8},{prop:"showStats",icon:'<i class="fa-solid fa-circle-info"></i>',type:"bool"},this.getSeedSettings()]}}i.exports=r},{"../animation":2,"../animation-queue":1,"../utils":40}],29:[function(t,i,e){var s=t("../animation");let d=t("../utils");class a extends s{constructor(t,i,e,s,a=500,r=0,n=!1,h=1,o=1,l="random",c=!1){super(t,i,e,s,"shapes dancing in a circle","spinning-shapes.js",`
Just same shape "dancing" in a circle.
This animation recreates the effect 
described in this [article](https://observablehq.com/@rreusser/instanced-webgl-circles).

Coded with no external dependencies, using only canvas API.
`),this.shapeNames=["circles","points","lines","triangles","rectangles","pentagons","hexagons","heptagons","octagons"],this.vertices=this.assignIfRandom(r,d.randomInt(0,8)),this.updateName(),this.rotateShapes=n,this.shapes=a,this.distanceBase=.6,this.distanceRange=.2,this.sizeBase=.2,this.sizeRange=.12,this.scale=h,this.colorsScale=o,this.colorsShift=this.assignIfRandom(l,d.randomChoice([0,3.14])),this.rainbowColors=c}updateName(){this.name=this.shapeNames[this.vertices]+' "dancing" in a circle'}draw(){this.clear();var i=Math.max(this.canvas.width,this.canvas.height)/3*this.scale;this.ctx.translate(this.canvas.width/2,this.canvas.height/2);for(let t=0;t<this.shapes;++t){var e=t/this.shapes*2*Math.PI,s=(this.distanceBase+this.distanceRange*Math.cos(6*e+Math.cos(8*e+this.time/2)))*i,a=Math.cos(e)*s,s=Math.sin(e)*s,r=9*e-this.time,n=(this.sizeBase+this.sizeRange*Math.cos(r))*i,r=(Math.cos((r+this.colorsShift)*this.colorsScale)+1)/2;this.rainbowColors?this.ctx.strokeStyle=`hsl(${360*r}, 100%, 75%)`:this.ctx.strokeStyle=d.lerpColor(this.colorA,this.colorB,r),this.ctx.lineWidth=1,this.ctx.beginPath(),0===this.vertices&&d.pathCircle(this.ctx,a,s,n),1===this.vertices?d.pathCircle(this.ctx,a,s,1):d.pathPolygon(this.ctx,a,s,n,this.vertices,e*this.rotateShapes),this.ctx.stroke()}this.ctx.resetTransform()}getSettings(){return[{prop:"vertices",icon:'<i class="fa-solid fa-shapes"></i>',name:"vertices per shape",type:"int",min:0,max:8,toCall:"updateName"},{prop:"shapes",name:"number of shapes",type:"int",min:0,max:2500},{prop:"rotateShapes",icon:'<i class="fa-solid fa-rotate"></i>',type:"bool"},{prop:"distanceRange",type:"float",min:0,max:this.distanceBase},{prop:"sizeRange",type:"float",min:0,max:this.sizeBase},{prop:"scale",icon:'<i class="fa-solid fa-maximize"></i>',type:"float",min:.05,max:1.95},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.1,min:-4,max:4},{prop:"colorsShift",type:"float",min:0,max:3.14},{prop:"colorsScale",type:"float",min:.05,max:2},{prop:"rainbowColors",icon:'<i class="fa-solid fa-rainbow"></i>',type:"bool"}]}}i.exports=a},{"../animation":2,"../utils":40}],30:[function(t,i,e){var s=t("../animation");let c=t("../utils");class a extends s{constructor(t,i,e,s,a=4e3,r=2,n="random",h=!0,o=1,l=!1){super(t,i,e,s,"spirograph","spirograph.js",`
Virtual spirograph created with 2-5 configurable gears.
Spirograph is a drawing toy that use gears to create patterns. I used to play with it a lot as a kid.

You can read about in on
[Wikipedia](https://en.wikipedia.org/wiki/Spirograph).
I also recommend to check this awesome [website] (http://www.eddaardvark.co.uk/v2/spirograph/spirograph2.html),
which is the source of inspiration for this animation.
And also this great [blogpost](https://www.bit-101.com/blog/2022/12/coding-curves-09-roulette-curves/)
that step by step how it works.

Try play with the gears' settings or hit reset button few times 
to get different random configurations.

Coded with no external dependencies, using only canvas API.
`),this.vertices=a,this.lineLength=r,this.maxGears=5,this.rescaleToFit=h,this.scale=o,this.speed=1,this.rainbowColors=l,this.gearCount=this.assignIfRandom(n,c.randomInt(2,this.maxGears)),this.gearNames=["zero","one","two","three","four","five"],this.updateName(),this.setup()}setup(){this.gears=[];for(let t=0;t<this.maxGears;++t)this.gears.push({radius:c.round(c.randomRange(0,100),2),rate:c.round(c.randomRange(-100,100),2),phase:.005*t})}updateName(){this.name="spirograph with "+this.gearNames[this.gearCount]+" gears"}getXY(i,e,s=1){let a=0,r=0;for(let t=0;t<this.gearCount;++t){var n=this.gears[t];a+=n.radius*s*Math.cos(n.rate*(i+e*n.phase)),r+=n.radius*s*Math.sin(n.rate*(i+e*n.phase))}return{x:a,y:r}}draw(){this.clear();let e=1;if(this.rescaleToFit){let i=0;for(let t=0;t<this.gearCount;++t)i+=this.gears[t].radius;e=Math.min(this.canvas.width,this.canvas.height)/2/i}this.ctx.translate(this.canvas.width/2,this.canvas.height/2),this.ctx.scale(this.scale,this.scale);var s=Math.PI*this.lineLength/this.vertices;let a=this.getXY(0,this.time,e);for(let i=1;i<this.vertices;++i){var r=this.getXY(i*s,this.time,e);let t=null;t=this.rainbowColors?"hsl("+i/this.vertices*360+", 100%, 75%)":c.lerpColor(this.colorA,this.colorB,i/this.vertices),c.drawLine(this.ctx,a.x,a.y,r.x,r.y,1,t),a=r}this.ctx.resetTransform()}getSettings(){let i=[{prop:"vertices",icon:'<i class="fa-solid fa-draw-polygon"></i>',type:"int",min:100,max:32e3},{prop:"lineLength",icon:'<i class="fa-solid fa-ruler"></i>',type:"float",step:.25,min:1,max:16},{prop:"gearCount",icon:'<i class="fa-solid fa-gears"></i>',type:"int",min:2,max:this.maxGears,toCall:"updateName"},{prop:"rescaleToFit",icon:'<i class="fa-solid fa-expand"></i>',type:"bool"},{prop:"scale",icon:'<i class="fa-solid fa-up-right-and-down-left-from-center"></i>',type:"float",min:.25,max:4},{prop:"speed",icon:'<i class="fa-solid fa-gauge-high"></i>',type:"float",step:.1,min:-4,max:4},{prop:"rainbowColors",icon:'<i class="fa-solid fa-rainbow"></i>',type:"bool"},{type:"separator"}];for(let t=0;t<this.maxGears;++t)i=i.concat([{prop:`gears[${t}].radius`,icon:'<i class="fa-solid fa-gear"></i>',type:"float",step:.01,min:0,max:100},{prop:`gears[${t}].rate`,icon:'<i class="fa-solid fa-gear"></i>',type:"float",step:.01,min:-100,max:100},{prop:`gears[${t}].phase`,icon:'<i class="fa-solid fa-gear"></i>',type:"float",step:.001,min:-.1,max:.1}]);return i}}i.exports=a},{"../animation":2,"../utils":40}],31:[function(t,i,e){var s=t("../animation");let l=t("../utils");class a extends s{constructor(t,i,e,s,a=4,r=2,n=6,h=30,o="random"){super(t,i,e,s,"tree visualization","tree-vizualization.js",`
Visualization of the tree using different algorithms.

Coded with no external dependencies, using only canvas API.
`),this.maxDepth=a,this.maxChildren=n,this.minChildren=r,this.radius=h,this.treeAlgoNames=["proportional space","equal space"],this.treeAlgorithm=this.assignIfRandom(o,l.randomChoice(this.treeAlgoNames)),this.nodes=[],this.treeRoot=null,this.restart()}calNodesXY(){}proportionalSpace(){this.treeRoot.theta=90;let i=0,e=[[this.treeRoot]];for(;0<e[i].length;){var s=[];for(let t=0;t<e[i].length;++t){var a=e[i][t];for(let t=0;t<a.children.length;++t){var r=a.children[t];r.theta=a.theta-180/a.parentsChildren+360*(t+.5)/a.children.length/a.parentsChildren,r.parentsChildren=a.parentsChildren*a.children.length,s.push(r)}}++i,e.push(s)}for(var t of this.nodes)t.x=t.depth*this.radius*Math.cos(t.theta*Math.PI/180),t.y=t.depth*this.radius*Math.sin(t.theta*Math.PI/180)}equalSpace(){this.treeRoot.theta=90;let r=0,n=[[this.treeRoot]];for(;0<n[r].length;){let i=[],t=0,s=129600,a=s-1;for(let t=0;t<n[r].length;++t)i.push(...n[r][t].children);if(0==i.length)break;for(let t=0;t<i.length;++t)i[t].theta=360*t/i.length;for(let e=0;e<360;++e){a=0;for(var h of n[r]){let i=0;for(var o of h.children){let t=Math.abs(o.theta+e-o.parent.theta);180<(t%=360)&&(t=360-t),i=Math.max(i,t)}i*=i,a+=i}(a/=n[r].length)<s&&(s=a,t=e)}for(var e of i)e.theta+=t;++r,n.push(i)}for(var t of this.nodes)t.x=t.depth*this.radius*Math.cos(t.theta*Math.PI/180),t.y=t.depth*this.radius*Math.sin(t.theta*Math.PI/180)}plante(){let r=0,e=[[this.treeRoot]];for(;0<e[r].length;){var n=[];for(let i=0;i<e[r].length;++i){let s=e[r][i],a=1,t=s;for(;null!=t.parent;)t=t.parent,a*=t.children.length;for(let e=0;e<s.children.length;++e){let t=s.children[e],i=360*e/(s.children.length-1)/a;0==r&&(i=360*e/s.children.length/a),1==s.children.length?t.theta=s.theta:r<2?t.theta=s.theta-180/a+i:1==s.children.length?t.theta=s.theta:s.theta<s.parent.theta?t.theta=s.theta+i:s.theta>s.parent.theta?t.theta=s.theta-i:t.theta=s.theta-180/a+i,t.x=s.x+this.radius*Math.cos(t.theta*Math.PI/180),t.y=s.y+this.radius*Math.sin(t.theta*Math.PI/180),n.push(t)}}++r,e.push(n)}}restart(){this.nodes=[],this.treeRoot=this.genNode(null,0),"equal space"==this.treeAlgorithm?this.equalSpace():"proportional space"==this.treeAlgorithm&&this.proportionalSpace()}genNode(t,i){var e={parent:t,children:[],x:0,y:0,theta:0,depth:i,parentsChildren:1};if(this.nodes.push(e),i<this.maxDepth){var s=l.randomInt(this.minChildren,this.maxChildren);for(let t=0;t<s;++t)e.children.push(this.genNode(e,i+1))}return e}draw(){this.clear(),this.ctx.translate(this.canvas.width/2,this.canvas.height/2);for(var t of this.nodes){for(var i of t.children)l.drawLine(this.ctx,t.x,t.y,i.x,i.y,1,"#000");l.fillCircle(this.ctx,t.x,t.y,5,this.colors[t.depth])}this.ctx.resetTransform()}getSettings(){return[{prop:"maxDepth",type:"int",min:1,max:6,toCall:"restart"},{prop:"minChildren",type:"int",min:0,max:8,toCall:"restart"},{prop:"maxChildren",type:"int",min:1,max:8,toCall:"restart"},{prop:"radius",type:"int",min:10,max:300,toCall:"restart"},{prop:"treeAlgorithm",type:"select",values:this.treeAlgoNames,toCall:"restart"},this.getSeedSettings()]}}i.exports=a},{"../animation":2,"../utils":40}],32:[function(t,i,e){var s=t("../animation");let o=t("../utils");class a extends s{constructor(t,i,e,s,a=64){super(t,i,e,s,"vectors","vectors.js",`
Vectors.

Coded with no external dependencies, using only canvas API.
`),this.distance=a,this.mouseRange=2*a,this.dashLenght=16,this.mousePoint=o.createVec2d(0,0)}draw(){this.clear(),this.ctx.translate(this.canvas.width/2,this.canvas.height/2);var t,e=Math.floor(this.canvas.width/this.distance),s=Math.floor(this.canvas.height/this.distance),a=[],r=[];for(let i=0;i<e;++i)for(let t=0;t<s;++t){var n=(i-(e-1)/2)*this.distance,h=(t-(s-1)/2)*this.distance,n=o.createVec2d(n,h);a.push(n),o.distVec2d(this.mousePoint,n)<this.mouseRange&&r.push(n)}this.ctx.strokeStyle=this.colors[0],this.ctx.setLineDash([this.dashLenght]),this.ctx.lineDashOffset=-this.dashLenght*(this.time%30);for(t of a)for(var i of r)o.drawLine(this.ctx,t.x,t.y,i.x,i.y,.25);this.ctx.setLineDash([]),this.ctx.resetTransform()}mouseAction(t,i){"move"===i&&(this.mousePoint=o.createVec2d(t.x-this.canvas.width/2,t.y-this.canvas.height/2))}getSettings(){return[{prop:"distance",type:"int",min:32,max:256},{prop:"mouseRange",type:"int",min:32,max:512}]}}i.exports=a},{"../animation":2,"../utils":40}],33:[function(t,i,e){var S;function C(t,i,e,s){var a,r,n,h,o,l,c,d=t[i][0],p=t[i][1],m=t[e][0],u=t[e][1],g=t[s][0],t=t[s][1],f=Math.abs(p-u),x=Math.abs(u-t);if(f<S&&x<S)throw new Error("Eek! Coincident points!");return d=f<S?(n=-(g-m)/(t-u))*((a=(m+d)/2)-(o=(m+g)/2))+(c=(u+t)/2):x<S?(r=-(m-d)/(u-p))*((a=(g+m)/2)-(h=(d+m)/2))+(l=(p+u)/2):(a=((r=-(m-d)/(u-p))*(h=(d+m)/2)-(n=-(g-m)/(t-u))*(o=(m+g)/2)+(c=(u+t)/2)-(l=(p+u)/2))/(r-n),x<f?r*(a-h)+l:n*(a-o)+c),{i:i,j:e,k:s,x:a,y:d,r:(g=m-a)*g+(t=u-d)*t}}S=1/1048576,void 0!==i&&(i.exports={triangulate:function(s,t){var i,e,a,r,n,h,o,l,c,d,p,m=s.length;if(m<3)return[];if(s=s.slice(0),t)for(i=m;i--;)s[i]=s[i][t];for(a=new Array(m),i=m;i--;)a[i]=i;for(a.sort(function(t,i){var e=s[i][0]-s[t][0];return 0!=e?e:t-i}),r=function(t){for(var i,e,s,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY,o=t.length;o--;)t[o][0]<a&&(a=t[o][0]),t[o][0]>n&&(n=t[o][0]),t[o][1]<r&&(r=t[o][1]),t[o][1]>h&&(h=t[o][1]);return s=h-r,[[(e=a+.5*(i=n-a))-20*(i=Math.max(i,s)),(s=r+.5*s)-i],[e,s+20*i],[e+20*i,s-i]]}(s),s.push(r[0],r[1],r[2]),n=[C(s,m+0,m+1,m+2)],h=[],o=[],i=a.length;i--;o.length=0){for(p=a[i],e=n.length;e--;)0<(l=s[p][0]-n[e].x)&&l*l>n[e].r?(h.push(n[e]),n.splice(e,1)):l*l+(l=s[p][1]-n[e].y)*l-n[e].r>S||(o.push(n[e].i,n[e].j,n[e].j,n[e].k,n[e].k,n[e].i),n.splice(e,1));v=x=f=g=y=u=w=void 0;for(var u,g,f,x,v,w=o,y=w.length;y;)for(f=w[--y],g=w[--y],u=y;u;)if(v=w[--u],g===(x=w[--u])&&f===v||g===v&&f===x){w.splice(y,2),w.splice(u,2);break}for(e=o.length;e;)d=o[--e],c=o[--e],n.push(C(s,c,d,p))}for(i=n.length;i--;)h.push(n[i]);for(n.length=0,i=h.length;i--;)h[i].i<m&&h[i].j<m&&h[i].k<m&&n.push(h[i].i,h[i].j,h[i].k);return n},contains:function(t,i){var e,s,a,r,n;return i[0]<t[0][0]&&i[0]<t[1][0]&&i[0]<t[2][0]||i[0]>t[0][0]&&i[0]>t[1][0]&&i[0]>t[2][0]||i[1]<t[0][1]&&i[1]<t[1][1]&&i[1]<t[2][1]||i[1]>t[0][1]&&i[1]>t[1][1]&&i[1]>t[2][1]||(e=t[1][0]-t[0][0],n=t[2][0]-t[0][0],s=t[1][1]-t[0][1],0==(a=e*(r=t[2][1]-t[0][1])-n*s))||(r=(r*(i[0]-t[0][0])-n*(i[1]-t[0][1]))/a,n=(e*(i[1]-t[0][1])-s*(i[0]-t[0][0]))/a,r<0)||n<0||1<r+n?null:[r,n]}})},{}],34:[function(t,i,e){t=t("./animation");class s extends t{constructor(t,i,e,s,a="",r="",n="",h="random"){super(t,i,e,s,a,r,n,h),this.gridWidth=0,this.gridHeight=0,this.grid=null,this.gridNext=null}getIdx(t,i){return t+i*this.gridWidth}getIdxWrap(t,i){return(t+this.gridWidth)%this.gridWidth+(i+this.gridHeight)%this.gridHeight*this.gridWidth}getVal(t,i){return this.grid[this.getIdx(t,i)]}getValWrap(t,i){return this.grid[this.getIdxWrap(t,i)]}newCellState(t,i){return 0}resize(){var t=Math.ceil(this.canvas.width/this.cellSize),i=Math.ceil(this.canvas.height/this.cellSize);this.resizeGrid(t,i)}resizeGrid(e,t){var s=new Array(e*t);for(let i=0;i<t;++i)for(let t=0;t<e;++t){var a=t+i*e;t<this.gridWidth&&i<this.gridHeight?s[a]=this.grid[this.getIdx(t,i)]:s[a]=this.newCellState(t,i)}delete this.grid,delete this.gridNext,this.grid=s,this.gridNext=[...this.grid],this.gridWidth=e,this.gridHeight=t}restart(){this.gridWidth=0,this.gridHeight=0,super.restart()}}i.exports=s},{"./animation":2}],35:[function(require,module,exports){let Utils=require("./utils"),ThreeNPlusOne=require("./animations/3n+1"),BriansBrainAutomata=require("./animations/brians-brain-automata"),Cardioids=require("./animations/cardioids"),CircularWaves=require("./animations/circular-waves"),Coding=require("./animations/coding"),DayAndNightAutomata=require("./animations/day-and-night-automata"),FiguresSpiral=require("./animations/figures-spiral"),GameOfLife=require("./animations/game-of-life"),GameOfLifeIsometric=require("./animations/game-of-life-isometric"),GlitchAutomata=require("./animations/glitch-automata"),GradientDescent=require("./animations/gradient-descent"),Matrix=require("./animations/matrix"),MLinPL=require("./animations/mlinpl"),Network=require("./animations/network"),NoisyLines=require("./animations/noisy-lines"),ParticlesAndAttractors=require("./animations/particles-and-attractors"),ParticlesVortex=require("./animations/particles-vortex"),ParticlesWaves=require("./animations/particles-waves"),PerlinNoiseParticles=require("./animations/perlin-noise-particles"),RockPaperScissorsAutomata=require("./animations/rock-paper-scissors-automata"),SandAutomata=require("./animations/sand-automata"),Quadtree=require("./animations/quadtree"),RecursiveSquares=require("./animations/recursive-squares"),ShortestPath=require("./animations/shortest-path"),SineWaves=require("./animations/sine-waves"),Sorting=require("./animations/sorting"),SpinningShapes=require("./animations/spinning-shapes"),Spirograph=require("./animations/spirograph"),Vectors=require("./animations/vectors"),TestThreejs=require("./threejs-animations/test"),TreeVisualization=require("./animations/tree-visualization"),fps=30,framesInterval=1e3/fps,then=0,paused=!1,width=0,height=0,lastWidth=0,lastHeight=0,resolution="fit",fixedWidth=0,fixedHeight=0,sampleSize=30,frames=0,avgDrawTime=0,avgElapsedTime=0,trueThen=0,bgColors={black:"#000000",white:"#FFFFFF"},bgColor="#FFFFFF",colors=["#349BA9","#41B8AD","#73D4AD","#AEEABF","#73D4AD","#41B8AD"],colorsAlt=["#602180","#B6245C","#E14F3B","#EC8C4D","#FFF202","#99F32B","#106AA6","#283B93"],canvas=document.getElementById("background"),container=document.getElementById("background-container"),content=document.getElementById("me"),elemBgShow=document.getElementById("background-show"),elemBgName=document.getElementById("background-name"),elemBgDesc=document.getElementById("background-description"),elemBgPrev=document.getElementById("background-previous"),elemBgNext=document.getElementById("background-next"),elemBgCode=document.getElementById("background-code"),elemBgReset=document.getElementById("background-reset"),elemBgRestart=document.getElementById("background-restart"),elemBgPlayPause=document.getElementById("background-play-pause"),elemBgSettings=document.getElementById("background-settings"),elemBgSettingsControls=document.getElementById("background-settings-controls"),elemBgSettingsClose=document.getElementById("background-settings-close"),elemBgStats=document.getElementById("background-stats"),elemBgAnimationSelect=document.getElementById("background-settings-animation-select"),elemBgAnimationFps=document.getElementById("background-settings-animation-fps"),elemBgAnimationResolution=document.getElementById("background-settings-animation-resolution"),elemBgColor=document.getElementById("background-settings-bg-color"),elemBgGetSettingsURL=document.getElementById("background-copy-settings-url");if(canvas){let allAnimations=[{class:ThreeNPlusOne,name:"3n+1"},{class:BriansBrainAutomata,name:"brian's brain automata"},{class:Cardioids,name:"cardioids"},{class:CircularWaves,name:"circular waves"},{class:Coding,name:"coding"},{class:DayAndNightAutomata,name:"day and night automata"},{class:FiguresSpiral,name:"figures spiral",hide:!0},{class:GameOfLife,name:"game of life"},{class:GameOfLifeIsometric,name:"isometric game of life"},{class:GlitchAutomata,name:"glitch automata",startAnimation:!1},{class:GradientDescent,name:"gradient descent"},{class:Matrix,name:"matrix rain"},{class:MLinPL,name:"ml in pl"},{class:Network,name:"network"},{class:NoisyLines,name:"noisy lines"},{class:ParticlesAndAttractors,name:"particles and attractors"},{class:ParticlesVortex,name:"particles vortex"},{class:ParticlesWaves,name:"particles waves"},{class:PerlinNoiseParticles,name:"perlin noise"},{class:RockPaperScissorsAutomata,name:"rock-paper-scissors automata"},{class:SandAutomata,name:"sand automata"},{class:Quadtree,name:"quadtree",startAnimation:!1},{class:RecursiveSquares,name:"recursive squares",startAnimation:!1},{class:SineWaves,name:"sine waves"},{class:ShortestPath,name:"shortest path"},{class:Sorting,name:"sorting"},{class:SpinningShapes,name:"spinning shapes"},{class:Spirograph,name:"spirograph"},{class:Vectors,name:"vectors",hide:!0},{class:TestThreejs,name:"threejs test"},{class:TreeVisualization,name:"tree visualization",hide:!0}];function getTime(){return Date.now()}function updateAnimation(t,i=null){frames=0,avgDrawTime=0,avgElapsedTime=0,animationId=t;t=canvas.cloneNode(!1);canvas.parentNode.replaceChild(t,canvas),canvas=t,animation=new animations[animationId].class(canvas,colors,colorsAlt,bgColor),i&&animation.setSettings(i),then=getTime(),trueThen=then,animation.resize(),updateUI()}function updateAnimationResolution(t){"fit"!==(resolution=t)?(fixedWidth=parseInt(resolution.split("x")[0]),fixedHeight=parseInt(resolution.split("x")[1]),canvas.classList.add("fixed-size")):canvas.classList.remove("fixed-size")}function updateAnimationFps(t){fps=parseInt(t),framesInterval=1e3/fps}function checkResize(){"fit"===resolution?(width=Math.max(container.parentElement.offsetWidth-canvas.offsetLeft),height=Math.max(container.parentElement.offsetHeight-canvas.offsetTop),width===lastWidth&&height===lastHeight||(canvas.width=width,canvas.height=height,animation.resize())):canvas.width===fixedWidth&&canvas.height===fixedHeight||(canvas.width=fixedWidth,canvas.height=fixedHeight,animation.resize()),lastWidth=canvas.width,lastHeight=canvas.height}function updateStats(t,i){elemBgStats&&(++frames,avgElapsedTime=(avgElapsedTime*(sampleSize-1)+t)/sampleSize,avgDrawTime=(avgDrawTime*(sampleSize-1)+i)/sampleSize,frames%fps==0)&&(elemBgStats.innerHTML=`canvas resolution: ${canvas.width} x ${canvas.height}</br>
                                        <i class="fa-solid fa-crosshairs"></i><i class="fa-solid fa-stopwatch"></i> target frames interval: ${Math.round(framesInterval)} ms</br>
                                        <i class="fa-solid fa-crosshairs"></i> target fps: ${fps}</br>
                                        <i class="fa-solid fa-stopwatch"></i> avg. frames interval: ${Math.round(avgElapsedTime)} ms</br>
                                        avg. fps: ${Math.round(1e3/avgElapsedTime)}</br>
                                        avg. draw time: ${Math.round(avgDrawTime)} ms`)}function render(){if(!paused){var i,e=getTime();let t=e-then;document.hidden&&(trueThen=e,then=e,t=0),t>=framesInterval&&(then=e-t%framesInterval,i=getTime(),checkResize(),animation.update(t),animation.draw(),i=getTime()-i,updateStats(e-trueThen,i),trueThen=e),requestAnimationFrame(render)}}let animations=allAnimations.filter(t=>!t.hide),animationCount=animations.length,animationId=Utils.randomInt(0,animationCount);for(;!1===animations[animationId].startAnimation;)animationId=Utils.randomInt(0,animationCount);let urlParams=new URLSearchParams(window.location.search);if(urlParams.has("animation")){let animationParam=urlParams.get("animation").replaceAll("-"," ").replaceAll("_"," ");for(let i=0;i<animationCount;++i)animationParam===animations[i].name&&(animationId=i)}urlParams.has("resolution")&&updateAnimationResolution(urlParams.get("resolution")),urlParams.has("fps")&&updateAnimationFps(urlParams.get("fps")),urlParams.has("bgColor")&&(bgColor=urlParams.get("bgColor"));let animation=null,order=Array.from({length:animationCount},(t,i)=>i);Utils.randomShuffle(order);for(let i=0;i<animationCount;++i)animations[order[i]].prev=order[(i+animationCount-1)%animationCount],animations[order[i]].next=order[(i+1)%animationCount];function getRelativeCursorPosition(t,i){i.touches&&(i=i.touches[0]);var e=t.getBoundingClientRect();return{x:(i.clientX-e.left)/(e.right-e.left)*t.width,y:(i.clientY-e.top)/(e.bottom-e.top)*t.height}}updateAnimation(animationId,urlParams),render();let eventNames={click:"click",mousedown:"down",touchstart:"down",mousemove:"move",touchmove:"move",mouseup:"up",touchend:"up"};function play(){elemBgPlayPause.innerHTML='<i class="fas fa-pause"></i> pause',paused=!1,then=getTime(),render()}function pause(){elemBgPlayPause.innerHTML='<i class="fas fa-play"></i> play',paused=!0}function hideBackground(){content.classList.remove("fade-out"),content.classList.add("fade-in"),canvas.classList.remove("show-from-25"),canvas.classList.add("fade-to-25"),elemBgShow.innerHTML='<i class="fas fa-eye"></i> show'}function showBackground(){content.classList.remove("fade-in"),content.classList.add("fade-out"),canvas.classList.remove("faded-25"),canvas.classList.remove("fade-to-25"),canvas.classList.add("show-from-25"),elemBgShow.innerHTML='<i class="fas fa-eye-slash"></i> hide'}function buildOptionList(t,i){let e="",s=!1;for(var a of t)e+="<option ",a===i&&(e+="selected ",s=!0),e+=`value="${a}">${a}</option>`;return s||(e+=`<option selected value="${i}">custom (${i})</option>`),e}if(["click","mousedown","touchstart","mousemove","touchmove","mouseup","touchend"].forEach(function(i){canvas.addEventListener(i,function(t){getRelativeCursorPosition(canvas,t);animation.mouseAction(getRelativeCursorPosition(canvas,t),eventNames[i])})}),elemBgShow&&elemBgShow.addEventListener("click",function(){(content.classList.contains("fade-out")?hideBackground:showBackground)()}),elemBgPrev&&elemBgPrev.addEventListener("click",function(){updateAnimation(animations[animationId].prev),play()}),elemBgNext&&elemBgNext.addEventListener("click",function(){updateAnimation(animations[animationId].next),play()}),elemBgReset&&elemBgReset.addEventListener("click",function(){updateAnimation(animationId),play()}),elemBgRestart&&elemBgRestart.addEventListener("click",function(){animation.restart(),play()}),elemBgPlayPause&&elemBgPlayPause.addEventListener("click",function(){(!1===paused?pause:play)()}),elemBgAnimationSelect&&elemBgAnimationSelect.addEventListener("input",function(t){updateAnimation(parseInt(t.target.value))}),elemBgGetSettingsURL&&elemBgGetSettingsURL.addEventListener("click",function(){let t=window.location.href.split("?")[0];t+="?animation="+animations[animationId].name.replaceAll(" ","-"),"fit"!==resolution&&(t+="&resolution="+resolution),30!==fps&&(t+="&fps="+fps),"#FFFFFF"!==bgColor&&(t+="&bgColor="+bgColor),t+="&"+animation.getURLParams(),navigator.clipboard.writeText(t),alert("URL copied to clipboard!")}),elemBgAnimationResolution){let animationSizes=["fit","512x512","800x600","1024x768","1024x1024","1280x720","1600x1200","1920x1080","2048x2048"];elemBgAnimationResolution.innerHTML=buildOptionList(animationSizes,resolution),elemBgAnimationResolution.addEventListener("input",function(t){updateAnimationResolution(t.target.value)})}if(elemBgAnimationFps){let fpsOptions=[5,15,30,60];elemBgAnimationFps.innerHTML=buildOptionList(fpsOptions,fps),elemBgAnimationFps.addEventListener("input",function(t){updateAnimationFps(t.target.value)})}function closeSettings(){elemBgSettingsControls.classList.remove("fade-in"),elemBgSettingsControls.classList.add("fade-out")}function showSettings(){elemBgSettingsControls.classList.remove("fade-out"),elemBgSettingsControls.classList.add("fade-in"),elemBgSettingsControls.style.display="block"}function setMaxHeight(){elemBgSettingsControls.style.maxHeight=elemBgSettingsControls.parentNode.offsetHeight-parseInt(elemBgSettingsControls.style.top)+"px"}function checkIfFits(){elemBgSettingsControls.parentNode.offsetWidth<376&&(elemBgSettingsControls.style.left="0px")}function processDescription(t){var i,e=(t,i,e,s)=>t+`<span class="nowrap">[<a href="${i}" target="_blank" rel="noopener noreferrer">${e}</a>]</span>`+s;for(i of[{replaceStr:e("$1","$3",'<i class="fa fa-wikipedia-w"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?en\.wikipedia\.org\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:e("$1","$3",'<i class="fa fa-youtube"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?youtube\.com\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:e("$1","$3",'<i class="fa fa-github"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?github\.com\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:e("$1","$3","$2","$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?mwydmuch\.pl\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:e("$1","$3",'<i class="fas fa-link"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:e("$1","$2",'<i class="fas fa-link"></i> $2',"$3"),regexp:/(.*)[^"](https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))[^"](.*)/g}])t=t.replaceAll(i.regexp,i.replaceStr);return t="<p>"+(t=(t=t.replaceAll("\n- ","</br>- ")).trim().replaceAll("\n\n","</p><p>"))+"</p>"}function getPropId(t){return t.split(/(?=[A-Z])/).join(" ").toLowerCase().replaceAll(/\.|\]|s\[/g,"-")}function updateUI(){elemBgName&&(elemBgName.innerHTML=animation.getName()),elemBgCode&&(elemBgCode.href=animation.getCodeUrl()),elemBgDesc&&(elemBgDesc.innerHTML=processDescription(animation.getDescription()));let animationSelectOptions="";for(let i=0;i<animations.length;++i){let name=animations[i].name;animations[animationId].name===name?animationSelectOptions+=`<option selected value="${i}">${name}</option>`:animationSelectOptions+=`<option value="${i}">${name}</option>`}elemBgAnimationSelect.innerHTML=animationSelectOptions;let settings=animation.getSettings(),elemBgSettingsList=document.getElementById("background-settings-controls-list");elemBgSettingsControls&&elemBgSettingsList&&(elemBgSettingsList.innerHTML="",0===settings.length&&(elemBgSettingsList.innerHTML="There are no settings (yet) for this animation"),settings.forEach(function(setting,index){if("separator"===setting.type)elemBgSettingsList.innerHTML+='<div class="setting-separator"></div>';else{let value=eval("animation."+setting.prop),elemId=getPropId(setting.prop)+"-controls",name="",optionControls=(setting.icon&&(name+=setting.icon+" "),setting.name?name+=setting.name:name+=getPropId(setting.prop).replaceAll("-"," "),`<div><span class="setting-name">${name}</span><span class="nowrap setting-value-control">`);if(["int","float","bool"].includes(setting.type)){let inputParams=`name="${setting.prop}" id="${elemId}" value="${value}"`;["int","float"].includes(setting.type)&&(setting.step?inputParams+=` step="${setting.step}"`:"float"===setting.type?inputParams+=' step="0.01"':inputParams+=' step="1"',inputParams+=` min="${setting.min}" max="${setting.max}"`),"bool"===setting.type&&value&&(inputParams+=" checked"),"bool"===setting.type?optionControls+=`<label class="form-checkbox setting-input"><input type="checkbox" ${inputParams}><i class="form-icon"></i></label>`:optionControls+=`<input type="range" class="setting-input slider" ${inputParams}">`,optionControls+=`[<output class="setting-value">${value}</output>]`}else if("select"===setting.type){optionControls+=`<select class="form-select setting-select" name="${setting.prop}" id="${elemId}">`;for(var v of setting.values)v===value?optionControls+=`<option selected value="${v}">${v}</option>`:optionControls+=`<option value="${v}">${v}</option>`;optionControls+="</select>"}else"text"===setting.type&&(optionControls+=`<span class="setting-text">${setting.value.replaceAll("<","&lt;").replaceAll(">","&gt;")}</span>`);optionControls+="</span></div>",elemBgSettingsList.innerHTML+=optionControls}}),settings.forEach(function(setting,index){if(!["text","separator"].includes(setting.type)){let elemId=getPropId(setting.prop)+"-controls",elem=document.getElementById(elemId);elem&&elem.addEventListener("input",function(e){if("checkbox"===e.target.type)null!==e.target.parentNode.nextElementSibling&&"output"===e.target.parentNode.nextElementSibling.type&&(e.target.parentNode.nextElementSibling.value=e.target.checked),eval(`animation.${setting.prop} = e.target.checked;`);else{null!==e.target.nextElementSibling&&"output"===e.target.nextElementSibling.type&&(e.target.nextElementSibling.value=e.target.value);let value=e.target.value;"int"===setting.type?value=parseInt(value):"float"===setting.type&&(value=parseFloat(value)),eval(`animation.${setting.prop} = value;`)}setting.toCall&&animation[setting.toCall](),elemBgName.innerHTML=animation.getName(),play()})}}))}elemBgColor&&(elemBgColor.innerHTML='<option value="#FFFFFF" selected>white</option><option value="#000000">black</option>',elemBgColor.addEventListener("input",function(t){bgColor=t.target.value,animation.updateColors(colors,colorsAlt,bgColor)})),elemBgSettings&&elemBgSettingsControls&&elemBgSettingsClose&&(checkIfFits(),setMaxHeight(),elemBgSettings.addEventListener("click",function(){(elemBgSettingsControls.classList.contains("fade-out")||"none"===elemBgSettingsControls.style.display?showSettings:closeSettings)()}),elemBgSettingsClose.addEventListener("click",function(){closeSettings()}),["mousedown","touchstart"].forEach(function(t){elemBgSettingsControls.addEventListener(t,function(t){t.target===t.currentTarget&&((t=t.touches?t.touches[0]:t).target.classList.add("moving"),t.target.clickAnchorX=t.clientX-parseInt(t.target.style.left),t.target.clickAnchorY=t.clientY-parseInt(t.target.style.top))})}),["mousemove","touchmove"].forEach(function(t){addEventListener(t,function(e){if(elemBgSettingsControls.classList.contains("moving")){let t=(e=e.touches?e.touches[0]:e).clientX-elemBgSettingsControls.clickAnchorX,i=e.clientY-elemBgSettingsControls.clickAnchorY;t<0&&(t=0),i<0&&(i=0),elemBgSettingsControls.style.left=t+"px",elemBgSettingsControls.style.top=i+"px",setMaxHeight()}})}),["mouseup","touchend"].forEach(function(t){addEventListener(t,function(t){elemBgSettingsControls.classList.remove("moving")})}))}},{"./animations/3n+1":3,"./animations/brians-brain-automata":4,"./animations/cardioids":5,"./animations/circular-waves":6,"./animations/coding":7,"./animations/day-and-night-automata":8,"./animations/figures-spiral":9,"./animations/game-of-life":11,"./animations/game-of-life-isometric":10,"./animations/glitch-automata":12,"./animations/gradient-descent":13,"./animations/matrix":14,"./animations/mlinpl":15,"./animations/network":16,"./animations/noisy-lines":17,"./animations/particles-and-attractors":18,"./animations/particles-vortex":19,"./animations/particles-waves":20,"./animations/perlin-noise-particles":21,"./animations/quadtree":22,"./animations/recursive-squares":23,"./animations/rock-paper-scissors-automata":24,"./animations/sand-automata":25,"./animations/shortest-path":26,"./animations/sine-waves":27,"./animations/sorting":28,"./animations/spinning-shapes":29,"./animations/spirograph":30,"./animations/tree-visualization":31,"./animations/vectors":32,"./threejs-animations/test":39,"./utils":40}],36:[function(t,i,e){var s=this;function a(t,i,e){this.x=t,this.y=i,this.z=e}s=s.noise={},a.prototype.dot2=function(t,i){return this.x*t+this.y*i},a.prototype.dot3=function(t,i,e){return this.x*t+this.y*i+this.z*e};var r=[new a(1,1,0),new a(-1,1,0),new a(1,-1,0),new a(-1,-1,0),new a(1,0,1),new a(-1,0,1),new a(1,0,-1),new a(-1,0,-1),new a(0,1,1),new a(0,-1,1),new a(0,1,-1),new a(0,-1,-1)],n=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],C=new Array(512),b=new Array(512),d=(s.seed=function(t){0<t&&t<1&&(t*=65536),(t=Math.floor(t))<256&&(t|=t<<8);for(var i=0;i<256;i++){var e=1&i?n[i]^255&t:n[i]^t>>8&255;C[i]=C[i+256]=e,b[i]=b[i+256]=r[e%12]}},s.seed(0),.5*(Math.sqrt(3)-1)),p=(3-Math.sqrt(3))/6,M=1/6;function m(t){return t*t*t*(t*(6*t-15)+10)}function u(t,i,e){return(1-e)*t+e*i}s.simplex2=function(t,i){var e=(t+i)*d,s=Math.floor(t+e),e=Math.floor(i+e),a=(s+e)*p,t=t-s+a,i=i-e+a,a=i<t?(c=1,0):(c=0,1),r=t-c+p,n=i-a+p,h=t-1+2*p,o=i-1+2*p,l=b[(s&=255)+C[e&=255]],c=b[s+c+C[e+a]],a=b[1+s+C[1+e]],s=.5-t*t-i*i,e=s<0?0:(s*=s)*s*l.dot2(t,i),s=.5-r*r-n*n,l=s<0?0:(s*=s)*s*c.dot2(r,n),t=.5-h*h-o*o,i=t<0?0:(t*=t)*t*a.dot2(h,o);return 70*(e+l+i)},s.simplex3=function(t,i,e){var s=(t+i+e)*(1/3),a=Math.floor(t+s),r=Math.floor(i+s),s=Math.floor(e+s),n=(a+r+s)*M,t=t-a+n,i=i-r+n,e=e-s+n,n=i<=t?e<=i?(S=y=x=1,w=v=0):y=e<=t?(S=w=v=0,x=1):(S=v=x=0,w=1):i<e?(y=v=x=0,S=w=1):t<e?(y=w=x=0,S=v=1):(S=y=v=1,w=x=0),h=t-x+M,o=i-v+M,l=e-w+M,c=t-y+2*M,d=i-S+2*M,p=e-n+2*M,m=t-1+.5,u=i-1+.5,g=e-1+.5,f=b[(a&=255)+C[(r&=255)+C[s&=255]]],x=b[a+x+C[r+v+C[s+w]]],v=b[a+y+C[r+S+C[s+n]]],w=b[1+a+C[1+r+C[1+s]]],y=.6-t*t-i*i-e*e,S=y<0?0:(y*=y)*y*f.dot3(t,i,e),n=.6-h*h-o*o-l*l,a=n<0?0:(n*=n)*n*x.dot3(h,o,l),r=.6-c*c-d*d-p*p,s=r<0?0:(r*=r)*r*v.dot3(c,d,p),y=.6-m*m-u*u-g*g,f=y<0?0:(y*=y)*y*w.dot3(m,u,g);return 32*(S+a+s+f)},s.perlin2=function(t,i){var e=Math.floor(t),s=Math.floor(i),a=(t-=e,i-=s,b[(e&=255)+C[s&=255]].dot2(t,i)),r=b[e+C[1+s]].dot2(t,i-1),n=b[1+e+C[s]].dot2(t-1,i),e=b[1+e+C[1+s]].dot2(t-1,i-1),s=m(t);return u(u(a,n,s),u(r,e,s),m(i))},s.perlin3=function(t,i,e){var s=Math.floor(t),a=Math.floor(i),r=Math.floor(e),n=(t-=s,i-=a,e-=r,b[(s&=255)+C[(a&=255)+C[r&=255]]].dot3(t,i,e)),h=b[s+C[a+C[1+r]]].dot3(t,i,e-1),o=b[s+C[1+a+C[r]]].dot3(t,i-1,e),l=b[s+C[1+a+C[1+r]]].dot3(t,i-1,e-1),c=b[1+s+C[a+C[r]]].dot3(t-1,i,e),d=b[1+s+C[a+C[1+r]]].dot3(t-1,i,e-1),p=b[1+s+C[1+a+C[r]]].dot3(t-1,i-1,e),s=b[1+s+C[1+a+C[1+r]]].dot3(t-1,i-1,e-1),a=m(t),r=m(i),t=m(e);return u(u(u(n,c,a),u(h,d,a),t),u(u(o,p,a),u(l,s,a),t),r)}},{}],37:[function(t,i,e){i.exports=class{constructor(t=32,i=!1,e=function(t,i){return t.value<i.value}){this.array=new Array(t),this.elemComperator=e,this.priorityQueue=i,this.first=0,this.size=0}getArrayIdx(t){return(this.first+t)%this.array.length}push(t){if(this.size>=this.array.length){var i=new Array(2*this.size);for(let t=0;t<this.size;t++)i[t]=this.array[(this.first+t)%this.size];this.first=0,this.array=i}if(this.array[this.getArrayIdx(this.size)]=t,++this.size,this.priorityQueue&&1<this.size)for(let t=this.size-1;0<t;--t){var e=this.getArrayIdx(t),s=this.getArrayIdx(t-1);if(!this.elemComperator(this.array[e],this.array[s]))break;[this.array[e],this.array[s]]=[this.array[s],this.array[e]]}}pop(){if(0===this.size)return null;this.size--;var t=this.array[this.first];return this.first=(this.first+1)%this.array.length,t}clear(){this.size=0,this.first=0}size(){return this.size}}},{}],38:[function(t,i,e){t=t("./animation");class s extends t{constructor(t,i,e,s,a="",r="",n="",h="random"){super(t,i,e,s,a,r,n,h,null),this.renderer=new THREE.WebGLRenderer({antialias:!0,canvas:t}),this.renderer.setSize(t.width/t.height),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(75,t.width/t.height,1,1e3),this.camera.position.set(0,0,5)}update(t){super.update(t)}draw(){this.renderer.render(this.scene,this.camera)}resize(){var t=this.canvas.width,i=this.canvas.height;this.renderer.setSize(t,i),this.camera.aspect=t/i,this.camera.updateProjectionMatrix()}getCodeUrl(){return"https://github.com/mwydmuch/mwydmuch.github.io/blob/master/js/threejs-animations"+this.file}}i.exports=s},{"./animation":2}],39:[function(t,i,e){t=t("../threejs-animation");class s extends t{constructor(t,i,e,s){super(t,i,e,s,"Test Three.js animation","test.js",`
Just test animation.
`);t=new THREE.AmbientLight(2236962),t.position.set(0,0,0),this.scene.add(t),i=new THREE.PointLight(16777215,1),i.position.set(200,200,200),this.scene.add(i),e=new THREE.BoxGeometry,s=new THREE.MeshPhysicalMaterial,t=new THREE.Mesh(e,s);t.position.set(0,0,0),this.scene.add(t)}update(t){super.update(t),this.scene.traverse(t=>{t.isMesh&&(t.rotation.x+=.01,t.rotation.y+=.01)})}}i.exports=s},{"../threejs-animation":38}],40:[function(require,module,exports){module.exports={Lcg(t){return function(){return(2147483647&(t=0|Math.imul(48271,t)))/2147483648}},Mulberry32(i){return function(){i=(i|=0)+1831565813|0;var t=Math.imul(i^i>>>15,1|i);return(((t=t+Math.imul(t^t>>>7,61|t)^t)^t>>>14)>>>0)/4294967296}},randomRange(t,i,e=Math.random){return e()*(i-t)+t},randomInt(t,i,e=Math.random){return Math.floor(this.randomRange(t,i,e))},randomChoice(t,i=Math.random){return t[Math.floor(i()*t.length)]},randomBoxMuller(t=Math.random){return Math.sqrt(-2*Math.log(1-t()))*Math.cos(2*Math.PI*t())},randomNormal(t,i,e=Math.random){return t+this.randomBoxMuller(e)*i},randomArray(t,i,e,s=Math.random){return Array(t).fill().map(()=>this.randomRange(i,e,s))},randomShuffle(i,e=Math.random){for(let t=i.length-1;0<t;--t){var s=Math.floor(e()*(t+1));[i[t],i[s]]=[i[s],i[t]]}},randomRulletChoice(t,i=Math.random){let e=0;for(var s in t)e+=t[s];let a=i()*e;for(var r in t)if((a-=t[r])<0)return r},round(t,i=2){i=Math.pow(10,i);return Math.round(t*i)/i},argMax(t){return[].reduce.call(t,(t,i,e,s)=>i>s[t]?e:t,0)},addArrays(t,e){return t.map((t,i)=>t+e[i])},subArrays(t,e){return t.map((t,i)=>t-e[i])},mulArrays(t,e){return t.map((t,i)=>t*e[i])},clip(t,i,e){return Math.max(i,Math.min(e,t))},remap(t,i,e,s,a){return s+(t-i)/(e-i)*(a-s)},sum(t){let i=0;for(var e of t)i+=a;return i},lerp(t,i,e){return(1-e)*t+e*i},conv(s,a,r,n,h,t,o,l){for(var i=new Array(s.length);y<r;++y)for(;x<a;++x){let e=0;for(let i=0;i<t;++i)for(let t=0;t<h;++t){var c=0+t-o,d=0+i-l;0<=c&&c<a&&0<=d&&d<r&&(e+=s[d*a+c]*n[i*h+t])}i[0*a+0]=e}return i},lerpColor(t,i,e){var t=parseInt(t.replace("#","0x"),16),s=t>>16,a=t>>8&255,t=255&t,i=parseInt(i.replace("#","0x"),16);return"#"+((1<<24)+(s+e*((i>>16)-s)<<16)+(a+e*((i>>8&255)-a)<<8)+(t+e*((255&i)-t))|0).toString(16).slice(1)},lerpColorsPallet(t,i){var e=1/(t.length-1),s=Math.floor(i/e);return this.lerpColor(t[s%t.length],t[(s+1)%t.length],(i-s*e)/e)},createVec2d(t,i){return{x:t,y:i}},rotateVec2d(t,i){var e=Math.cos(i),i=Math.sin(i),s={...t};return s.x=t.x*e-t.y*i,s.y=t.x*i+t.y*e,s},mulVec2d(t,i){t={...t};return t.x*=i,t.y*=i,t},distVec2d(t,i){return Math.sqrt(Math.pow(t.x-i.x,2)+Math.pow(t.y-i.y,2))},linear(t){return t},easeInSine(t){return 1-Math.cos(t*Math.PI/2)},easeOutSine(t){return Math.sin(t*Math.PI/2)},easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2},easeInQuad(t){return t*t},easeOutQuad(t){return 1-(1-t)*(1-t)},easeInOutQuad(t){return t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2},easeInCubic(t){return t*t*t},easeOutCubic(t){return 1-Math.pow(1-t,3)},easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2},easeInQuart(t){return t*t*t*t},easeOutQuart(t){return 1-Math.pow(1-t,4)},easeInOutQuart(t){return t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2},clear(t,i){t.fillStyle=i,t.fillRect(0,0,t.canvas.width,t.canvas.height)},pathLine(t,i,e,s,a){t.moveTo(i,e),t.lineTo(s,a)},drawLine(t,i,e,s,a,r=1,n){t.lineWidth=r,void 0!==n&&(t.strokeStyle=n),t.beginPath(),t.moveTo(i,e),t.lineTo(s,a),t.stroke()},drawDashedLine(t,i,e,s,a,r,n=0,h=1,o){t.setLineDash(r),t.lineDashOffset=n,this.drawLine(t,i,e,s,a,h,o)},pathPolygon(i,e,s,a,r,n=0){var h=2*Math.PI/r;i.moveTo(e+a*Math.cos(n),s+a*Math.sin(n));for(let t=1;t<=r;t++)i.lineTo(e+a*Math.cos(n+t*h),s+a*Math.sin(n+t*h))},pathCircle(t,i,e,s){t.moveTo(i+s,e),t.arc(i,e,s,0,2*Math.PI,!1)},fillCircle(t,i,e,s,a){void 0!==a&&(t.fillStyle=a),t.beginPath(),t.arc(i,e,s,0,2*Math.PI,!1),t.fill()},strokeCircle(t,i,e,s,a){void 0!==a&&(t.strokeStyle=a),t.beginPath(),t.arc(i,e,s,0,2*Math.PI,!1),t.stroke()},fillAndStrokeText(t,i,e,s){t.strokeText(i,e,s),t.fillText(i,e,s)},pathShape(i,e){if(e.length)if(e[0].hasOwnProperty("x")&&e[0].hasOwnProperty("y")){i.moveTo(e[0].x,e[0].y);for(let t=1;t<e.length;++t)i.lineTo(e[t].x,e[t].y)}else{i.moveTo(e[0][0],e[0][1]);for(let t=1;t<e.length;++t)i.lineTo(e[t][0],e[t][1])}},pathClosedShape(t,i){i.length&&this.pathShape(t,i.concat([i[0]]))},blendColor(t,i,e=1,s="source-over"){t.save(),t.globalCompositeOperation=s,t.globalAlpha=e,t.fillStyle=i,t.fillRect(0,0,t.canvas.width,t.canvas.height),t.restore()},rgbToHex(t,i,e){return"#"+((1<<24)+(t<<16)+(i<<8)+e).toString(16).slice(1)},createOffscreenCanvas(t,i){var e=document.createElement("canvas");return e.width=t,e.height=i,e},isSuperset(t,i){for(var e of i)if(!t.has(e))return!1;return!0},setsUnion(t,i){var e,s=new Set(t);for(e of i)s.add(e);return s},setsIntersection(t,i){var e,s=new Set;for(e of i)t.has(e)&&s.add(e);return _intersection},setsSymmetricDifference(t,i){var e,s=new Set(t);for(e of i)s.has(e)?s.delete(e):s.add(e);return s},setsDifference(t,i){var e,s=new Set(t);for(e of i)s.delete(e);return s},isStrictMode(){return eval("var __temp = null"),"undefined"==typeof __temp?"strict":"non-strict"},getKeys(t){var i,e=[];for(i in t)e.push(i);return e},getValues(t){var i,e=[];for(i in t)e.push(t[i]);return e},addMultipleEventListener(i,t,e){t.forEach(t=>i.addEventListener(t,e))}}},{}]},{},[35]);