/*!
 * mwydmuch.pl v17
 * Copyright 2023 Marek Wydmuch
 */

!function s(a,r,h){function n(i,t){if(!r[i]){if(!a[i]){var e="function"==typeof require&&require;if(!t&&e)return e(i,!0);if(o)return o(i,!0);throw new Error("Cannot find module '"+i+"'")}t=r[i]={exports:{}};a[i][0].call(t.exports,function(t){var e=a[i][1][t];return n(e||t)},t,t.exports,s,a,r,h)}return r[i].exports}for(var o="function"==typeof require&&require,t=0;t<h.length;t++)n(h[t]);return n}({1:[function(t,e,i){"use strict";var s=t("./animation");t("./utils");class a extends s{constructor(t,e,i,s,a=30,r=8,h=-20,n=!1,o=1,l=!1){super(t,e,i,s,"3n + 1 (Collatz Conjecture) visualization","3n+1.js",`
3n + 1 (Collatz Conjecture) visualization 
inspired by this Veritasium's [video](https://www.youtube.com/watch?v=094y1Z2wpJg).
You can also read about the conjecture on [Wikipedia](https://en.wikipedia.org/wiki/Collatz_conjecture).

Each tic Collatz sequence is generated for the next number.
Following the generated sequence from its end (1), 
for each number, the line is drawn from the point of the previous line's end.
The next line is drawn at the angle of the previous line, rotated by the angle 
that depends if the following number in the sequence is even or odd.

Coded with no external dependencies, using only canvas API.
`),this.length=a,this.evenAngle=r,this.oddAngle=h,this.scale=o,this.drawNumbers=n,this.showStats=l,this.seqences=[],this.max=0}generateNextSequence(){let t=this.seqences.length+1,e=[t];for(;1!==t;)t%2?t=3*t+1:t/=2,t>this.max&&(this.max=t),e.push(t),t<this.seqences.length&&(this.seqences[t-1]=null);this.seqences.push(e)}update(t){for(let t=0;t<this.speed;++t)this.generateNextSequence()}drawSequence(a){if(null!==a){let e=0,i=0,s=270*Math.PI/180;var t=this.colors[this.frame%this.colors.length];this.ctx.strokeStyle=t,this.ctx.lineWidth=2,this.ctx.font="12px sans-serif",this.ctx.fillStyle=t,this.ctx.beginPath(),this.ctx.moveTo(e,i);for(let t=a.length-2;0<=t;--t){var r,h,n=a[t];s+=n%2?this.oddAngleRad:this.evenAngleRad,this.drawNumbers?(r=Math.cos(s),h=Math.sin(s),e+=this.length/2*r,i+=this.length/2*h,this.ctx.fillText(n,e+10,i),e+=this.length/2*r,i+=this.length/2*h):(e+=this.length*Math.cos(s),i+=this.length*Math.sin(s)),this.ctx.lineTo(e,i)}this.ctx.stroke()}}draw(){for(this.evenAngleRad=this.evenAngle*Math.PI/180,this.oddAngleRad=this.oddAngle*Math.PI/180,this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height),this.ctx.scale(this.scale,this.scale);this.frame<this.seqences.length;)this.drawSequence(this.seqences[this.frame]),++this.frame;var t;this.ctx.resetTransform(),this.showStats&&(t=["Current starting number: "+this.seqences.length,"Highest reached number: "+this.max],this.resetFont(),this.drawTextLines(t,this.lineHeight,this.ctx.canvas.height-(t.length+1)*this.lineHeight))}resize(){this.frame=0,this.clear()}restart(){this.seqences=[],this.max=0,super.restart()}getSettings(){return[{prop:"length",type:"int",min:1,max:100,toCall:"resize"},{prop:"evenAngle",type:"int",min:-45,max:45,toCall:"resize"},{prop:"oddAngle",type:"int",min:-45,max:45,toCall:"resize"},{prop:"speed",type:"int",min:1,max:16},{prop:"drawNumbers",type:"bool",toCall:"resize"},{prop:"scale",type:"float",min:.05,max:1.95,toCall:"resize"},{prop:"showStats",type:"bool"}]}}e.exports=a},{"./animation":3,"./utils":36}],2:[function(t,e,i){e.exports=class{constructor(){this.queue=[]}push(t){this.queue.push({step:t,time:0})}step(t){let e=t;for(;this.queue.length&&0<e;){var i=this.queue[0];i.time+=t,0<=(e=i.step(i.time))&&this.queue.shift()}return e}clear(){this.queue=[]}}},{}],3:[function(t,e,i){"use strict";const o=t("./noise"),l=t("./utils");e.exports=class{constructor(t,e,i,s,a="",r="",h="",n="random"){this.ctx=t.getContext("2d",{alpha:!1}),this.bgColor=s,this.colors=e,this.colorsAlt=i,this.colorA=e[0],this.colorB=e[3],this.name=a,this.file=r,this.description=h,this.time=0,this.frame=0,this.speed=1,this.fps=30,this.noise=o.noise,this.rand=null,this.maxSeedValue=999999,this.seed=this.assignIfRandom(n,Math.round(Math.random()*this.maxSeedValue)),this.setSeed(this.seed),this.lineHeight=20,this.resetFont(),this.debug=!1}resetFont(){this.ctx.font="14px sans-serif",this.ctx.lineWidth=2,this.ctx.textAlign="left",this.ctx.textBaseline="alphabetic",this.ctx.fillStyle=this.colors[0],this.ctx.strokeStyle=this.bgColor,this.lineHeight=20}drawTextLines(e,i,s,a=!1){for(let t=0;t<e.length;++t){var r,h=e[t],n=this.ctx.measureText(h),o=s+(t+1)*this.lineHeight;a&&(r=this.ctx.fillStyle,this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(i,o-this.lineHeight,n.width,this.lineHeight),this.ctx.fillStyle=r),l.fillAndStrokeText(this.ctx,h,i,o)}}setSeed(t){this.noise.seed(t/this.maxSeedValue),this.rand=l.Mulberry32(t)}assignIfRandom(t,e){return"random"===t?e:t}clear(){l.clear(this.ctx,this.bgColor)}fadeOut(t){"#000000"==this.bgColor?this.blendColorAlpha(this.bgColor,t,"darker"):this.blendColorAlpha(this.bgColor,t,"lighter")}blendColorAlpha(t,e,i){e<=5e-4&&this.frame%20==0?l.blendColor(this.ctx,t,20*e,i):e<=.001&&this.frame%10==0?l.blendColor(this.ctx,t,10*e,i):e<=.005&&this.frame%2==0?l.blendColor(this.ctx,t,2*e,i):l.blendColor(this.ctx,t,e,i)}getFPS(){return this.fps}getName(){return this.name}getCodeUrl(){return"https://github.com/mwydmuch/mwydmuch.github.io/blob/master/js/"+this.file}getDescription(){return this.description}update(t){this.time+=t/1e3*this.speed,++this.frame}resize(){}restart(){this.time=0,this.frame=0,this.setSeed(this.seed),this.resize()}getSettings(){return[]}getSeedSettings(t="restart"){return{prop:"seed",type:"int",min:0,max:this.maxSeedValue,toCall:t}}mouseAction(t,e){}}},{"./noise":19,"./utils":36}],4:[function(t,e,i){"use strict";var s=t("./animation");const a=t("./utils");class r extends s{constructor(t,e,i,s,a=400,r=1,h=.05,n=!1){super(t,e,i,s,"cardioids with a pencil of lines","cardioids.js",`
Modified method of L. Cremona for drawing cardioid with a pencil of lines,
as described in section "cardioid as envelope of a pencil of lines" 
of this Wikipedia [article](https://en.wikipedia.org/wiki/Cardioid).

Here the shift of the second point for each line is determined by time passed
from the beginning of the animation.

To see what is really happening, try to set the number of lines to small number.

Playing with both number of lines and speed, allow to notice different interesting patterns.

Coded with no external dependencies, using only canvas API.
`),this.lines=a,this.scale=r,this.speed=h,this.rainbowColors=n,this.radius=0}getVec(t){t=a.remap(t,0,this.lines,0,2*Math.PI);return a.rotateVec2d(a.createVec2d(this.radius,0),Math.PI+t)}draw(){this.clear(),this.radius=Math.max(this.ctx.canvas.width,this.ctx.canvas.height)/3*this.scale,this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),a.strokeCircle(this.ctx,0,0,this.radius,this.colors[0]);for(let e=0;e<=this.lines;++e){var i=this.getVec(e),s=this.getVec(e*this.time);let t;t=this.rainbowColors?"hsl("+e/this.lines*360+", 100%, 75%)":a.lerpColorsPallet([this.colorA,this.colorB,this.colorA],e/this.lines),this.ctx.strokeStyle=t,a.drawLine(this.ctx,i.x,i.y,s.x,s.y,1,t)}this.ctx.resetTransform()}getSettings(){return[{prop:"lines",type:"int",min:1,max:2500},{prop:"speed",type:"float",min:-2,max:2},{prop:"scale",type:"float",min:.25,max:1.75},{prop:"rainbowColors",type:"bool"}]}}e.exports=r},{"./animation":3,"./utils":36}],5:[function(t,e,i){"use strict";var s=t("./animation");const h=t("./utils");class a extends s{constructor(t,e,i,s,a=180,r=.5,h=.4,n=1.2,o=.001,l=!1){super(t,e,i,s,"circular waves","circular-waves.js",`
This animation draw a circle as a set of vertices and edges,
noise is added to the position of each vertex to create a wave effect. 

Coded with no external dependencies, using only canvas API.
`),this.vertices=a,this.noiseScale=r,this.radiusScaleMin=h,this.radiusScaleMax=n,this.fadingSpeed=o,this.rainbowColors=l,this.radiusMin=0,this.radiusMax=0}draw(){this.fadeOut(this.fadingSpeed);var e=.005*this.frame,i=2*Math.PI/this.vertices;this.rainbowColors?this.ctx.strokeStyle="hsl("+360*Math.abs(Math.sin(5*e))+", 100%, 50%)":this.ctx.strokeStyle=h.lerpColor(this.colorA,this.colorB,Math.abs(Math.sin(5*e))),this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),this.ctx.beginPath();for(let t=0;t<=this.vertices;++t){var s=t*i,a=Math.cos(s)*this.noiseScale,r=Math.sin(s)*this.noiseScale,a=this.noise.simplex3(a,r,e),r=h.remap(a,-1,1,this.radiusMin,this.radiusMax),a=r*Math.cos(s),r=r*Math.sin(s);0===t?this.ctx.moveTo(a,r):this.ctx.lineTo(a,r)}this.ctx.stroke(),this.ctx.resetTransform()}resize(){this.radiusMin=Math.min(this.ctx.canvas.width,this.ctx.canvas.height)/2*this.radiusScaleMin,this.radiusMax=Math.max(this.ctx.canvas.width,this.ctx.canvas.height)/2*this.radiusScaleMax,this.radiusMin>this.radiusMax&&([this.radiusMin,this.radiusMax]=[this.radiusMax,this.radiusMin]),this.clear()}getSettings(){return[{prop:"vertices",type:"int",min:3,max:720,toCall:"resize"},{prop:"radiusScaleMin",type:"float",min:0,max:2,toCall:"resize"},{prop:"radiusScaleMax",type:"float",min:0,max:2,toCall:"resize"},{prop:"noiseScale",type:"float",min:0,max:2,toCall:"resize"},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},{prop:"rainbowColors",type:"bool"},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],6:[function(t,e,i){"use strict";var s=t("./animation");const h=t("./utils");class a extends s{constructor(t,e,i,s,a=20,r=4){super(t,e,i,s,"Code writing animation","codding.js",`
Work in progress.

Code writing animation inspired by: https://openprocessing.org/sketch/1219550
It's only light themed to match website colors, personally I always use dark IDE.

Coded with no external dependencies, using only canvas API.
`),this.charSize=a,this.lineX=this.padding,this.lineY=this.padding,this.tabSize=r,this.maxLines=0,this.line=0,this.tabs=0,this.words=0,this.wordLen=0,this.editorTheme={keyword:"#33C5E1",typeName:"#F52D73",argument:"#F9A857",variable:"#030303",numericValue:"#B693FB",stringValue:"#F0763B",comment:"#737373"},this.firstWordColors=[this.editorTheme.keyword,this.editorTheme.typeName,this.editorTheme.variable,this.editorTheme.comment],this.afterTypeName=[this.editorTheme.argument,this.editorTheme.typeName,this.editorTheme.variable],this.afterVariable=h.getValues(this.editorTheme),this.otherCases=[this.editorTheme.keyword,this.editorTheme.typeName,this.editorTheme.variable,this.editorTheme.comment,this.editorTheme.numericValue,this.editorTheme.stringValue],this.currentColor=null,this.imageData=null,this.updateCharSize(),this.newLine(),this.newWord()}updateCharSize(){this.padding=this.charSize/2,this.lineHeight=1.25*this.charSize,this.charWidth=Math.ceil(this.charSize/1.618),this.charHeight=this.charSize,this.imageData=null,this.line=0,this.resize(),this.newWord()}newWord(){(this.wordLen=0)===this.words?this.currentColor=h.randomChoice(this.firstWordColors):this.currentColor===this.editorTheme.typeName?this.currentColor=h.randomChoice(this.afterTypeName):this.currentColor===this.editorTheme.variable?this.currentColor=h.randomChoice(this.afterVariable):this.currentColor===this.editorTheme.comment?this.currentColor=this.editorTheme.comment:this.currentColor=h.randomChoice(this.otherCases)}newLine(){var t;this.line>this.maxLines&&(t=(this.maxLines-this.line)*this.lineHeight,this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,t),this.line=this.maxLines),this.words=0,this.lineX=this.padding+this.tabs*this.tabSize*this.charWidth,this.lineY=this.padding+this.line*this.lineHeight}draw(){var t;this.rand()<Math.pow(.9,this.wordLen-2)||this.wordLen<3?(this.lineX+=this.charWidth,++this.wordLen,this.ctx.fillStyle=this.currentColor,this.ctx.fillRect(this.lineX,this.lineY,this.charWidth,this.charHeight)):(this.rand()<Math.pow(.5,this.words-1)||this.words<2?(++this.words,this.lineX+=this.charWidth):("inc"===(t=h.randomChoice(["inc","inc","dec","dec","keep","keep","reset","keep+newline"]))&&this.tabs<4?++this.tabs:"keep+newline"===t?++this.line:"dec"===t&&0<this.tabs?(++this.line,--this.tabs):"reset"===t&&0<this.tabs&&(++this.line,this.tabs=0),++this.line,this.newLine()),this.newWord()),this.imageData=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}resize(){this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.maxLines=Math.floor((this.ctx.canvas.height-2*this.padding)/this.lineHeight)-1,this.newLine()}getSettings(){return[{prop:"charSize",type:"int",min:8,max:72,toCall:"updateCharSize"},{prop:"tabSize",type:"int",min:1,max:16}]}}e.exports=a},{"./animation":3,"./utils":36}],7:[function(t,e,i){"use strict";var S;function C(t,e,i,s){var a,r,h,n,o,l,c,d=t[e][0],p=t[e][1],m=t[i][0],u=t[i][1],g=t[s][0],t=t[s][1],f=Math.abs(p-u),x=Math.abs(u-t);if(f<S&&x<S)throw new Error("Eek! Coincident points!");return d=f<S?(h=-(g-m)/(t-u))*((a=(m+d)/2)-(o=(m+g)/2))+(c=(u+t)/2):x<S?(r=-(m-d)/(u-p))*((a=(g+m)/2)-(n=(d+m)/2))+(l=(p+u)/2):(a=((r=-(m-d)/(u-p))*(n=(d+m)/2)-(h=-(g-m)/(t-u))*(o=(m+g)/2)+(c=(u+t)/2)-(l=(p+u)/2))/(r-h),x<f?r*(a-n)+l:h*(a-o)+c),{i:e,j:i,k:s,x:a,y:d,r:(g=m-a)*g+(t=u-d)*t}}S=1/1048576,void 0!==e&&(e.exports={triangulate:function(s,t){var e,i,a,r,h,n,o,l,c,d,p,m=s.length;if(m<3)return[];if(s=s.slice(0),t)for(e=m;e--;)s[e]=s[e][t];for(a=new Array(m),e=m;e--;)a[e]=e;for(a.sort(function(t,e){var i=s[e][0]-s[t][0];return 0!=i?i:t-e}),r=function(t){for(var e,i,s,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY,o=t.length;o--;)t[o][0]<a&&(a=t[o][0]),t[o][0]>h&&(h=t[o][0]),t[o][1]<r&&(r=t[o][1]),t[o][1]>n&&(n=t[o][1]);return s=n-r,[[(i=a+.5*(e=h-a))-20*(e=Math.max(e,s)),(s=r+.5*s)-e],[i,s+20*e],[i+20*e,s-e]]}(s),s.push(r[0],r[1],r[2]),h=[C(s,m+0,m+1,m+2)],n=[],o=[],e=a.length;e--;o.length=0){for(p=a[e],i=h.length;i--;)0<(l=s[p][0]-h[i].x)&&l*l>h[i].r?(n.push(h[i]),h.splice(i,1)):l*l+(l=s[p][1]-h[i].y)*l-h[i].r>S||(o.push(h[i].i,h[i].j,h[i].j,h[i].k,h[i].k,h[i].i),h.splice(i,1));v=x=f=g=y=u=w=void 0;for(var u,g,f,x,v,w=o,y=w.length;y;)for(f=w[--y],g=w[--y],u=y;u;)if(v=w[--u],g===(x=w[--u])&&f===v||g===v&&f===x){w.splice(y,2),w.splice(u,2);break}for(i=o.length;i;)d=o[--i],c=o[--i],h.push(C(s,c,d,p))}for(e=h.length;e--;)n.push(h[e]);for(h.length=0,e=n.length;e--;)n[e].i<m&&n[e].j<m&&n[e].k<m&&h.push(n[e].i,n[e].j,n[e].k);return h},contains:function(t,e){var i,s,a,r,h;return e[0]<t[0][0]&&e[0]<t[1][0]&&e[0]<t[2][0]||e[0]>t[0][0]&&e[0]>t[1][0]&&e[0]>t[2][0]||e[1]<t[0][1]&&e[1]<t[1][1]&&e[1]<t[2][1]||e[1]>t[0][1]&&e[1]>t[1][1]&&e[1]>t[2][1]||(i=t[1][0]-t[0][0],h=t[2][0]-t[0][0],s=t[1][1]-t[0][1],0==(a=i*(r=t[2][1]-t[0][1])-h*s))||(r=(r*(e[0]-t[0][0])-h*(e[1]-t[0][1]))/a,h=(i*(e[1]-t[0][1])-s*(e[0]-t[0][0]))/a,r<0)||h<0||1<r+h?null:[r,h]}})},{}],8:[function(t,e,i){"use strict";var s=t("./animation");const n=t("./utils");class a extends s{constructor(t,e,i,s,a=500,r=50,h="random"){super(t,e,i,s,"figures spiral","figures-spiral.js",`
Very simple of figures spinning in the spiral.

Coded with no external dependencies, using only canvas API.
`),this.shapeSides=[0,1,2,3,4,5,6,8],this.shapeNames=["circles","points","lines","triangles","rectangles","pentagons","hexagons","octagons"],this.sides=this.assignIfRandom(h,n.randomChoice(this.shapeSides)),this.updateName(),this.size=r,this.number=a}updateName(){this.name=this.shapeNames[this.shapeSides.indexOf(this.sides)]+" spinning in spiral"}draw(){this.clear(),this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),this.ctx.scale(this.scale,this.scale),this.ctx.strokeStyle=this.colors[0];for(let t=0;t<this.number;++t)this.ctx.rotate(Math.PI*(.001*this.time+1e-6*t)),this.ctx.beginPath(),0===this.sides&&n.pathCircle(this.ctx,t,t,this.size),1===this.sides?n.pathCircle(this.ctx,t,t,1):n.pathPolygon(this.ctx,t,t,this.size,this.sides,0),this.ctx.stroke();this.ctx.resetTransform()}getSettings(){return[{prop:"sides",type:"int",min:0,max:8,toCall:"updateName"},{prop:"number",type:"int",min:1,max:1024},{prop:"size",type:"int",min:1,max:128},{prop:"speed",type:"float",step:.1,min:-4,max:4}]}}e.exports=a},{"./animation":3,"./utils":36}],9:[function(t,e,i){"use strict";var s=t("./game-of-life");const p=t("./utils");class a extends s{constructor(t,e,i,s,a=14,r=0,h=.4,n=!0,o=!0,l=!0,c=.75){super(t,e,i,s,a,r,h,l),this.name="isometric Conway's game of life",this.file="game-of-life-isometric.js",this.description=`
Conway's game of life visualization with isometric rendering.
You can read about the game of life on
[Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).
Game of life is one of the first programs I wrote in my life.

As in the top-down version, cells leave 
a trace for a few steps after they die to achieve a nice effect.
Especially, cells that died in the previous step keep the appearance 
of the life cell resulting in a stable image 
since flickering is not that good for a background image.

Coded with no external dependencies, using only canvas API.
`,this.fadeDeadCells=n,this.drawCellsGrid=o,this.gridSize=c,this.sqrt3=Math.sqrt(3),this.xShift=this.cellSize*this.sqrt3/2,this.yShift=this.cellSize/2,this.renderedGrid=null,this.renderedCubes=[];var d=p.createOffscreenCanvas(4*this.xShift,4*this.yShift).getContext("2d");this.drawIsoCube(d,0,3*this.yShift,!0,!0,this.colors,0,this.cellSize),this.renderedCubes.push(d.canvas);for(let t=1;t<this.cellSize;++t)d=p.createOffscreenCanvas(4*this.xShift,4*this.yShift).getContext("2d"),this.drawIsoCube(d,0,3*this.yShift,!0,!0,this.colorsAlt,-t,this.cellSize),this.renderedCubes.push(d.canvas)}drawIsoCube(t,e,i,s,a,r,h,n){var o=n*this.sqrt3/2,n=n/2;h*=-1,t.strokeStyle=r[0],t.fillStyle=r[3],t.beginPath(),p.pathClosedShape(t,[[e,i-2*n+h],[e+o,i-n+h],[e+2*o,i-2*n+h],[e+o,i-3*n+h]]),t.fill(),t.stroke(),s&&(t.fillStyle=r[2],t.beginPath(),p.pathClosedShape(t,[[e,i],[e+o,i+n],[e+o,i-n+h],[e,i-2*n+h]]),t.fill(),t.stroke()),a&&(t.fillStyle=r[1],t.beginPath(),p.pathClosedShape(t,[[e+o,i+n],[e+2*o,i],[e+2*o,i-2*n+h],[e+o,i-n+h]]),t.fill(),t.stroke())}drawCube(t,e,i,s=0,a=0){var r=t*this.xShift-e*this.xShift,h=(t+e+1)*this.yShift;this.drawIsoCube(this.ctx,r,h,!this.isAlive(t,e+1),!this.isAlive(t+1,e),i,s,this.cellSize-2*a)}drawGrid(e,i,s){var a=this.gridHeight*-this.xShift,r=this.gridHeight*this.yShift,h=this.gridWidth*this.xShift,n=this.gridWidth*this.yShift,t=(-this.gridHeight+this.gridWidth)*this.xShift,o=(this.gridHeight+this.gridWidth)*this.yShift,l=this.colors[0];for(let t=0;t<this.gridHeight;++t){const i=t*-this.xShift,s=t*this.yShift;p.drawLine(e,i,s,i+h,s+n,1,l),p.drawLine(e,-i,s,-i+a,s+r,1,l)}p.drawLine(e,0,0,h,n,3,l),p.drawLine(e,0,0,a,r,3,l),p.drawLine(e,a,r,t,o,3,l),p.drawLine(e,h,n,t,o,3,l)}drawPrerenderedCube(t,e,i){var s=t*this.xShift-e*this.xShift,t=(t+e+1)*this.yShift;this.ctx.drawImage(this.renderedCubes[i],s-+this.xShift,t-3*this.yShift)}draw(){var t;this.clear(),this.drawCellsGrid&&(this.renderedGrid||((t=p.createOffscreenCanvas(this.ctx.canvas.width,this.ctx.canvas.height).getContext("2d")).translate(this.ctx.canvas.width/2,(1-this.gridSize)/2*this.ctx.canvas.height),this.drawGrid(t,0,0),this.renderedGrid=t.canvas),this.ctx.drawImage(this.renderedGrid,0,0)),this.ctx.translate(this.ctx.canvas.width/2,(1-this.gridSize)/2*this.ctx.canvas.height);for(let e=0;e<this.gridHeight;++e)for(let t=0;t<this.gridWidth;++t){var i=this.getVal(t,e);this.fadeDeadCells&&i>-(this.cellSize-2*this.cellBasePadding)?this.drawPrerenderedCube(t,e,Math.max(0,-i)):0<i&&this.drawPrerenderedCube(t,e,0)}this.ctx.resetTransform()}resize(){var t=Math.min(this.ctx.canvas.width,this.ctx.canvas.height),t=Math.ceil(this.gridSize*t/this.cellSize);this.resizeGrid(t,t),this.renderedGrid=null}getSettings(){return[{prop:"loopGrid",type:"bool"},{prop:"fadeDeadCells",type:"bool"},{prop:"drawCellsGrid",type:"bool"},{prop:"gridSize",type:"float",step:.01,min:0,max:2,toCall:"resize"},{prop:"spawnProb",type:"float",step:.01,min:0,max:1,toCall:"restart"},this.getSeedSettings()]}}e.exports=a},{"./game-of-life":10,"./utils":36}],10:[function(t,e,i){"use strict";var s=t("./grid");const c=t("./utils");class a extends s{constructor(t,e,i,s,a=12,r=1,h=.4,n=!0,o="random",l=5){super(t,e,i,s,"Conway's game of life","game-of-life.js",`
Voisualization of Conway's game of life - probably the most famous cellular automaton.
You can read about the game of life on
[Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).
Game of life is one of the first programs I wrote in my life.

In this version, cells leave a trace for 
a few steps after they die to achieve a nice effect.
Especially, cells that died in the previous step keep the appearance 
of the life cell resulting in a stable image 
since flickering is not that good for a background image.

You can pause the animation and set the cell states by clicking/touching the canvas.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.cellBasePadding=r,this.initialPaterns=["random","R Pentomino"],this.spawnProb=h,this.cellStyles=["square","circle"],this.cellStyle=this.assignIfRandom(o,c.randomChoice(this.cellStyles)),this.deadCellsFadingSteps=l,this.loopGrid=n,this.mouseDown=!1,this.mouseVal=0}isAlive(t,e){return this.loopGrid?1<=this.getVal(t%this.gridWidth,e%this.gridHeight)?1:0:!(t<0||t>=this.gridWidth||e<0||e>=this.gridHeight)&&1<=this.getVal(t,e)?1:0}update(t){super.update(t);for(let e=0;e<this.gridHeight;++e)for(let t=0;t<this.gridWidth;++t){var i=this.isAlive(t-1,e-1)+this.isAlive(t,e-1)+this.isAlive(t+1,e-1)+this.isAlive(t-1,e)+this.isAlive(t+1,e)+this.isAlive(t-1,e+1)+this.isAlive(t,e+1)+this.isAlive(t+1,e+1),s=this.getIdx(t,e);2===i&&1<=this.grid[s]?this.gridNext[s]=this.grid[s]+1:this.gridNext[s]=3===i?Math.max(1,this.grid[s]+1):Math.min(0,this.grid[s]-1)}[this.grid,this.gridNext]=[this.gridNext,this.grid]}drawSquareCell(t,e,i){this.ctx.fillRect(t*this.cellSize+i,e*this.cellSize+i,this.cellSize-2*i,this.cellSize-2*i)}drawCircleCell(t,e,i){this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,e*this.cellSize+this.cellSize/2,this.cellSize/2-i,0,2*Math.PI,!1),this.ctx.fill()}draw(){this.clear(),this.ctx.translate(-(this.mapWidth*this.cellSize-this.ctx.canvas.width)/2,-(this.mapHeight*this.cellSize-this.ctx.canvas.height)/2),"square"===this.cellStyle?this.drawCell=this.drawSquareCell:this.drawCell=this.drawCircleCell;var r=(this.cellSize/2-this.cellBasePadding)/(this.deadCellsFadingSteps+1);for(let a=0;a<this.gridHeight;++a)for(let t=0;t<this.gridWidth;++t){var h=this.getVal(t,a);let e=this.cellBasePadding,i=null,s=-1;if(0<h)i=this.colors[0];else for(let t=0;t<this.deadCellsFadingSteps;++t){if(h>s){i=this.colors[Math.min(t,this.colors.length-1)],e+=t*r;break}s*=2}i&&(this.ctx.fillStyle=i,this.drawCell(t,a,e))}this.ctx.resetTransform()}newCellState(t,e){return this.rand()<this.spawnProb?1:-99999}resize(){var t=Math.ceil(this.ctx.canvas.width/this.cellSize),e=Math.ceil(this.ctx.canvas.height/this.cellSize);this.resizeGrid(t,e)}mouseAction(t,e){"down"===e?this.mouseDown=!0:"up"===e&&(this.mouseDown=!1),("down"===e||"move"===e&&this.mouseDown)&&(t=Math.floor(t.x/this.cellSize)+Math.floor(t.y/this.cellSize)*this.gridWidth,"down"===e&&(1===this.grid[t]?this.mouseVal=-99999:this.mouseVal=1),this.grid[t]!==this.mouseVal)&&(this.grid[t]=this.mouseVal,this.draw())}getSettings(){return[{prop:"changeGrid",type:"text",value:"<click/touch>"},{prop:"loopGrid",type:"bool"},{prop:"cellSize",type:"int",min:4,max:32,toCall:"restart"},{prop:"cellStyle",type:"select",values:this.cellStyles},{prop:"deadCellsFadingSteps",type:"int",min:0,max:8},{prop:"spawnProb",type:"float",step:.01,min:0,max:1,toCall:"restart"},this.getSeedSettings()]}}e.exports=a},{"./grid":13,"./utils":36}],11:[function(t,e,i){"use strict";var s=t("./grid");const n=t("./utils");class a extends s{constructor(t,e,i,s,a=7,r="random",h=.0051){super(t,e,i,s,"Glitch animation","glitch.js",`
The animation is just cellular automata that apply to the cell 
a state of one of the neighbor cells based on a noise function.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.noiseScale=h,this.initialPaterns=["1x1 checkerboard","2x2 checkerboard","4x4 checkerboard","vertical lines","horizontal lines"],this.initialPatern=this.assignIfRandom(r,n.randomChoice(this.initialPaterns))}update(t){super.update(t);for(let e=0;e<this.gridWidth;++e)for(let t=0;t<this.gridHeight;++t){var i=this.noise.simplex3(e*this.noiseScale,t*this.noiseScale,this.frame*this.noiseScale),i=Math.round(20*i)%5,s=this.getIdx(e,t);switch(i){case 0:this.gridNext[s]=this.grid[this.getIdxWrap(e-1,t)];break;case 1:this.gridNext[s]=this.grid[this.getIdxWrap(e+1,t)];break;case 2:this.gridNext[s]=this.grid[this.getIdxWrap(e,t-1)];break;case 3:this.gridNext[s]=this.grid[this.getIdxWrap(e,t+1)];break;case 4:this.gridNext[s]=this.grid[s]}}[this.grid,this.gridNext]=[this.gridNext,this.grid]}draw(){this.clear(),this.ctx.fillStyle=this.colors[0];for(let e=0;e<this.gridWidth;++e)for(let t=0;t<this.gridHeight;++t)0<this.grid[this.getIdx(e,t)]&&this.ctx.fillRect(e*this.cellSize,t*this.cellSize,this.cellSize,this.cellSize)}newCellState(t,e){return"1x1 checkerboard"==this.initialPatern?(t+e)%2?1:0:"2x2 checkerboard"==this.initialPatern?(Math.floor(t/2)+Math.floor(e/2))%2?1:0:"4x4 checkerboard"==this.initialPatern?(Math.floor(t/4)+Math.floor(e/4))%2?1:0:"vertical lines"==this.initialPatern?t%4?0:1:"horizontal lines"==this.initialPatern?e%4?0:1:Math.round(Math.random())}resize(){var t=Math.ceil(this.ctx.canvas.width/this.cellSize),e=Math.ceil(this.ctx.canvas.height/this.cellSize);this.resizeGrid(t,e)}getSettings(){return[{prop:"cellSize",type:"int",min:4,max:12,toCall:"resize"},{prop:"initialPatern",type:"select",values:this.initialPaterns,toCall:"restart"},{prop:"noiseScale",type:"float",step:1e-4,min:.001,max:.05},this.getSeedSettings()]}}e.exports=a},{"./grid":13,"./utils":36}],12:[function(t,e,i){"use strict";var s=t("./animation");const w=t("./utils");class a{constructor(t){this.name=t}update(t){return 0}init(t){this.w=[...t]}getName(){return this.name}}class n extends a{constructor(t=.001){super("SGD"),this.eta=t}update(e){for(let t=0;t<this.w.length;++t)this.w[t]-=this.eta*e[t]}}class o extends a{constructor(t=.001,e=.9){super("Momentum"),this.eta=t,this.beta=e}init(t){super.init(t),this.m=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta*this.m[t]+(1-this.beta)*e[t],this.w[t]-=this.eta*this.m[t]}}class l extends a{constructor(t=.1){super("AdaGrad"),this.eta=t}init(t){super.init(t),this.v=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.v[t]+=e[t]*e[t],this.w[t]-=this.eta/Math.sqrt(this.v[t]+1e-6)*e[t]}}class c extends a{constructor(t=.01,e=.9){super("RMSProp"),this.eta=t,this.beta=e}init(t){super.init(t),this.v=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.v[t]=this.beta*this.v[t]+(1-this.beta)*e[t]*e[t],this.w[t]-=this.eta/Math.sqrt(this.v[t]+1e-6)*e[t]}}class d extends a{constructor(t=.01,e=.9,i=.999){super("Adam"),this.eta=t,this.beta1=e,this.beta2=i}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*e[t],this.v[t]=this.beta2*this.v[t]+(1-this.beta2)*e[t]*e[t],this.w[t]-=this.eta/(Math.sqrt(this.v[t]/(1-this.beta2))+1e-6)*this.m[t]/(1-this.beta1)}}class p extends a{constructor(t=.002,e=.9,i=.999){super("AdaMax"),this.alpha=t,this.beta1=e,this.beta2=i}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*e[t],this.v[t]=Math.max(this.beta2*this.v[t],Math.abs(e[t])),this.w[t]-=this.alpha/(this.v[t]+1e-6)*this.m[t]/(1-this.beta1)}}class m extends a{constructor(t=.002,e=.9,i=.999){super("AMSGrad"),this.alpha=t,this.beta1=e,this.beta2=i}init(t){super.init(t),this.m=new Array(t.length).fill(0),this.v=new Array(t.length).fill(0)}update(e){for(let t=0;t<this.w.length;++t)this.m[t]=this.beta1*this.m[t]+(1-this.beta1)*e[t],this.v[t]=Math.max(this.beta2*this.v[t]+(1-this.beta2)*e[t]*e[t],this.v[t]),this.w[t]-=this.alpha/(Math.sqrt(this.v[t])+1e-6)*this.m[t]}}class r{constructor(t,e,i,s,a=[0,0],r=1e3){this.name=t,this.globalMin=e,this.startPoints=i,this.scale=s,this.steps=r,this.shift=a}val(t){return 0}grad(t){return t}hasGlobalMin(){return null!==this.globalMin}getGlobalMin(){return w.subArrays(this.globalMin,this.shift)}getStartPoint(){return w.subArrays(w.randomChoice(this.startPoints),this.shift)}getScale(){return this.scale}getSteps(){return this.steps}getName(){return this.name}}class u extends r{constructor(){super("Two-dimensional non-convex function with saddle point: f(x) = x[0]^2 - x[1]^2",null,[[-1,.001],[-1,-1e-4],[1,.01],[1,-.001]],1.1)}val(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1];return e*e-t*t}grad(t){return[2*(t[0]+this.shift[0]),-2*(t[1]+this.shift[1])]}}class g extends r{constructor(){super("Two-dimensional non-convex BEALE function",[3,.5],[[.2,.7],[2,2],[-1,-1.3],[-1.4,-1.7],[4,-1.1]],2.2,[2,0])}val(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1];return Math.pow(1.5-e+e*t,2)+Math.pow(2.25-e+e*t*t,2)+Math.pow(2.625-e+e*Math.pow(t,3),2)}grad(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1],i=t*t,s=i*t,a=s*t,r=a*t;return[2*e*(r*t+a-2*s-i-2*t+3)+5.25*s+4.5*i+3*t-12.75,6*e*(e*(r+2/3*s-i-1/3*t-1/3)+2.625*i+1.5*t+.5)]}}class f extends r{constructor(){super("Two variables non-convex Stybliski-Tang function",[-2.903534,-2.903534],[[0,5],[0,-5],[5,0],[-5,0],[-.5,-5],[-5,-.5],[-5,-5]],5.5)}val(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1],i=e*e,s=t*t;return(i*i-16*i+5*e+(s*s-16*s+5*t))/2+78.33233}grad(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1];return[2*Math.pow(e,3)-16*e+2.5,2*Math.pow(t,3)-16*t+2.5]}}class x extends r{constructor(){super("Two-dimensional non-convex Rosenbrock function",[1,1],[[-2.5,-2.5],[2.5,-2.5],[0,2.5]],3.072)}val(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1];return 100*Math.pow(t-e*e,2)+Math.pow(1-e,2)}grad(t){var e=t[0]+this.shift[0],t=t[1]+this.shift[1],i=e*e;return[2*(-1+e+200*(i*e)-200*e*t),200*(-i+t)]}}class h extends s{constructor(t,e,i,s,a="random",r=!0,h=5){super(t,e,i,s,"visualization of gradient descent algorithms","gradient-descent.js",`
Visualization of gradient descent-based optimizers.
Default hyperparameters are set to recommended values.

The functions were taken from this very nice 
[website](https://www.sfu.ca/~ssurjano/optimization.html).

You can select the starting point by clicking/touching the canvas.

Coded with no external dependencies, using only canvas API.
`),this.funcNames=["with saddle point","Beale","Rosenbrock","Styblinski-Tang"],this.functionToOptimize=this.assignIfRandom(a,w.randomChoice(this.funcNames)),this.funcClasses=[u,g,x,f],this.autoRestart=r,this.rounding=h,this.scale=0,this.optims=null,this.imageData=null,this.functionImageData=null,this.functionImageDataName="",this.sgd=new n,this.momentum=new o,this.adagrad=new l,this.rmsprop=new c,this.adam=new d,this.adamax=new p,this.amsgrad=new m,this.optims=[this.sgd,this.momentum,this.adagrad,this.rmsprop,this.adam,this.adamax,this.amsgrad]}draw(){this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2);for(let t=0;t<this.optims.length;++t){var e,i,s,a=this.optims[t];[e,i]=a.w,a.update(this.func.grad(a.w)),[a,s]=a.w,isFinite(e)&&isFinite(i)&&isFinite(a)&&isFinite(s)&&(isNaN(e)||isNaN(i)||isNaN(a)||isNaN(s)||1e4<Math.abs(e)||1e4<Math.abs(i)||1e4<Math.abs(a)||1e4<Math.abs(s)||w.drawLine(this.ctx,e*this.scale,-i*this.scale,a*this.scale,-s*this.scale,2,this.colorsAlt[t]))}this.ctx.resetTransform(),this.imageData=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height),this.resetFont();let r=this.textYOffset+2*this.lineHeight;w.fillAndStrokeText(this.ctx,"Steps: "+this.frame,this.textXOffset,r),r+=this.lineHeight,w.fillAndStrokeText(this.ctx,"Optimizers:",this.textXOffset,r);for(let t=0;t<this.optims.length;++t){r+=this.lineHeight,this.ctx.fillStyle=this.colorsAlt[t];var h=this.optims[t].w[0].toFixed(this.rounding),n=this.optims[t].w[1].toFixed(this.rounding),h=this.optims[t].getName()+`: f(${h}, ${n}) = `+this.func.val([h,n]).toFixed(this.rounding);w.fillAndStrokeText(this.ctx,h,this.textXOffset+16,r),w.fillCircle(this.ctx,this.textXOffset+3,r-4,3,this.colorsAlt[t])}this.frame>=this.func.getSteps()&&this.autoRestart&&this.resize()}drawFunction(){this.clear();var t=this.funcClasses[this.funcNames.indexOf(this.functionToOptimize)];if(this.func=new t,this.functionImageData&&this.functionImageDataName===this.func.getName()&&this.functionImageData.width===this.ctx.canvas.width&&this.functionImageData.height===this.ctx.canvas.height)this.ctx.putImageData(this.functionImageData,0,0);else{this.functionImageDataName=this.func.getName();var h,n=this.ctx.canvas.width,o=this.ctx.canvas.height,l=n/2,c=o/2,d=(this.scale=Math.min(n,o)/this.func.getScale()/2,this.ctx.fillStyle=this.colors[0],this.ctx.strokeStyle=this.bgColor,this.ctx.font="12px sans-serif",new Array(n*o));let i,s,a,r=0;a=this.func.hasGlobalMin()?(r=this.func.val(this.func.getGlobalMin()),i=[0,.125],s=1.5,0):(r=0,t=this.func.getScale(),t=[this.func.val([0,0]),this.func.val([t,0]),this.func.val([0,t]),this.func.val([-t,0]),this.func.val([0,-t]),this.func.val([t,t]),this.func.val([-t,-t]),this.func.val([t,-t]),this.func.val([-t,t])],h=Math.min(...t),t=Math.max(...t),i=[h],s=1,(t-h)/15);for(let e=0;e<n;++e)for(let t=0;t<o;++t){for(var p=(e-l)/this.scale,m=-(t-c)/this.scale,u=this.func.val([p,m]),g=e+t*n;u>r+i[i.length-1];)i.push(i[i.length-1]*s+a);for(let t=1;t<i.length;++t)if(u<r+i[t]){d[g]=t-1;break}}var f=[];for(let t=0;t<i.length;++t)f.push(w.lerpColor(this.colors[0],this.colors[3],(t+1)/(i.length+1)));for(let e=0;e<n;++e)for(let t=0;t<o;++t){var x=e+t*n,v=-3*d[x]+d[x+1]+d[x+n]+d[x+1+n];this.ctx.fillStyle=f[d[x]],0!==v&&4!==v&&this.ctx.fillRect(e,t,1,1)}this.ctx.fillStyle=this.colors[0];let e=.5;3<this.scale&&(e=1);for(let t=0;t<l/this.scale;t+=e)this.ctx.fillText(t.toFixed(1),l+t*this.scale,o-22),0!==t&&this.ctx.fillText((-t).toFixed(1),l-t*this.scale,o-22);for(let t=0;t<c/this.scale;t+=e)this.ctx.fillText((-t).toFixed(1),10,c+t*this.scale),0!==t&&this.ctx.fillText(t.toFixed(1),10,c-t*this.scale);this.functionImageData=this.ctx.getImageData(0,0,n,o)}}drawLegend(t){var e,i=this.ctx.canvas.width,s=this.ctx.canvas.height,a=i/2,r=s/2;this.textYOffset=22,this.textXOffset=50,this.resetFont(),this.ctx.fillText(this.func.getName(),this.textXOffset,this.textYOffset),this.func.hasGlobalMin()&&(this.textYOffset+=this.lineHeight,e=this.func.getGlobalMin(),w.fillAndStrokeText(this.ctx,`Optimum: f(x*) = ${this.func.val(e).toFixed(this.rounding)}, at x* =  (${e[0]}, ${e[1]})`,this.textXOffset,this.textYOffset,2),w.fillCircle(this.ctx,a+e[0]*this.scale,r+-e[1]*this.scale,2,this.colors[0])),this.textYOffset+=this.lineHeight,w.fillAndStrokeText(this.ctx,`Starting point: x0 = (${t[0].toFixed(this.rounding)}, ${t[1].toFixed(this.rounding)})`,this.textXOffset,this.textYOffset),this.imageData=this.ctx.getImageData(0,0,i,s)}mouseAction(t,e){"click"===e&&(e=[(t.x-this.ctx.canvas.width/2)/this.scale,-(t.y-this.ctx.canvas.height/2)/this.scale],this.resize(e))}resize(t=null){this.frame=0,this.drawFunction(),null===t&&(t=this.func.getStartPoint());for(var e of this.optims)e.init(t);this.drawLegend(t)}getSettings(){return[{prop:"functionToOptimize",type:"select",values:this.funcNames,toCall:"resize"},{prop:"selectStartingPoint",type:"text",value:"<click/touch>"},{prop:"autoRestart",type:"bool"},{prop:"sgd.eta",type:"float",step:1e-5,min:0,max:.1},{prop:"momentum.eta",type:"float",step:1e-5,min:0,max:.1},{prop:"momentum.beta",type:"float",step:1e-4,min:0,max:1},{prop:"adagrad.eta",type:"float",step:1e-5,min:0,max:1},{prop:"rmsprop.eta",type:"float",step:1e-5,min:0,max:1},{prop:"adam.eta",type:"float",step:1e-5,min:0,max:1},{prop:"adam.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"adam.beta2",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.alpha",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"adamax.beta2",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.alpha",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.beta1",type:"float",step:1e-5,min:0,max:1},{prop:"amsgrad.beta2",type:"float",step:1e-5,min:0,max:1}]}}e.exports=h},{"./animation":3,"./utils":36}],13:[function(t,e,i){"use strict";class s extends t("./animation"){constructor(t,e,i,s,a="",r="",h="",n="random"){super(t,e,i,s,a,r,h,n),this.gridWidth=0,this.gridHeight=0,this.grid=null,this.gridNext=null}getIdx(t,e){return t+e*this.gridWidth}getIdxWrap(t,e){return(t+this.gridWidth)%this.gridWidth+(e+this.gridHeight)%this.gridHeight*this.gridWidth}getVal(t,e){return this.grid[this.getIdx(t,e)]}getValWrap(t,e){return this.grid[this.getIdxWrap(t,e)]}newCellState(t,e){return 0}resizeGrid(i,t){var s=new Array(i*t);for(let e=0;e<t;++e)for(let t=0;t<i;++t){var a=t+e*i;t<this.gridWidth&&e<this.gridHeight?s[a]=this.grid[this.getIdx(t,e)]:s[a]=this.newCellState(t,e)}delete this.grid,delete this.gridNext,this.grid=s,this.gridNext=[...this.grid],this.gridWidth=i,this.gridHeight=t}restart(){this.gridWidth=0,this.gridHeight=0,super.restart()}}e.exports=s},{"./animation":3}],14:[function(require,module,exports){"use strict";const Utils=require("./utils"),ThreeNPlusOne=require("./3n+1"),Cardioids=require("./cardioids"),CircularWaves=require("./circular-waves"),Coding=require("./coding"),FiguresSpiral=require("./figures-spiral"),GameOfLife=require("./game-of-life"),GameOfLifeIsometric=require("./game-of-life-isometric"),Glitch=require("./glitch"),GradientDescent=require("./gradient-descent"),Matrix=require("./matrix"),MLinPL=require("./mlinpl"),Network=require("./network"),NeuralNetwork=require("./neural-network"),NoisyLines=require("./noisy-lines"),ParticlesAndAttractors=require("./particles-and-attractors"),ParticlesVortex=require("./particles-vortex"),ParticlesWaves=require("./particles-waves"),PerlinNoiseParticles=require("./perlin-noise-particles"),RockPaperScissorsAutomata=require("./rock-paper-scissors-automata"),SandAutomata=require("./sand-automata"),Quadtree=require("./quadtree"),RecursiveRectangles=require("./recursive-rectangles"),ShortestPath=require("./shortest-path"),SineWaves=require("./sine-waves"),Sorting=require("./sorting"),SpinningShapes=require("./spinning-shapes"),Spirograph=require("./spirograph"),TreeVisualization=require("./tree-visualization"),canvas=document.getElementById("background"),container=document.getElementById("background-container");let fps=30,framesInterval=1e3/fps,then=0,paused=!1,width=0,height=0,lastWidth=0,lastHeight=0,resizeMode="fit",fixedWidth=0,fixedHeight=0,sampleSize=30,frames=0,avgDrawTime=0,avgElapsedTime=0,trueThen=0;const bgColors={black:"#000000",white:"#FFFFFF"};let bgColor="#FFFFFF",colors=["#349BA9","#41B8AD","#73D4AD","#AEEABF","#73D4AD","#41B8AD"],colorsAlt=["#602180","#B6245C","#E14F3B","#EC8C4D","#FFF202","#99F32B","#106AA6","#283B93"];const content=document.getElementById("me"),elemBgShow=document.getElementById("background-show"),elemBgName=document.getElementById("background-name"),elemBgDesc=document.getElementById("background-description"),elemBgPrev=document.getElementById("background-previous"),elemBgNext=document.getElementById("background-next"),elemBgCode=document.getElementById("background-code"),elemBgReset=document.getElementById("background-reset"),elemBgRestart=document.getElementById("background-restart"),elemBgPlayPause=document.getElementById("background-play-pause"),elemBgSettings=document.getElementById("background-settings"),elemBgSettingsControls=document.getElementById("background-settings-controls"),elemBgSettingsClose=document.getElementById("background-settings-close"),elemBgStats=document.getElementById("background-stats"),elemBgAnimationSelect=document.getElementById("background-settings-animation-select"),elemBgAnimationFps=document.getElementById("background-settings-animation-fps"),elemBgAnimationSize=document.getElementById("background-settings-animation-size"),elemBgColor=document.getElementById("background-settings-bg-color");if(canvas){let animations=[{class:ThreeNPlusOne,name:"3n+1"},{class:Cardioids,name:"cardioids"},{class:CircularWaves,name:"circular waves"},{class:GameOfLife,name:"game of life"},{class:GameOfLifeIsometric,name:"isometric game of life"},{class:Glitch,name:"glitch",startAnimation:!1},{class:GradientDescent,name:"gradient descent"},{class:Matrix,name:"matrix rain"},{class:MLinPL,name:"mlinpl"},{class:Network,name:"network"},{class:NoisyLines,name:"noisy lines"},{class:ParticlesAndAttractors,name:"particles and attractors"},{class:ParticlesVortex,name:"particles vortex"},{class:ParticlesWaves,name:"particles waves"},{class:PerlinNoiseParticles,name:"perlin noise"},{class:RockPaperScissorsAutomata,name:"rock-paper-scissors automata"},{class:SandAutomata,name:"sand automata"},{class:Quadtree,name:"quadtree",startAnimation:!1},{class:RecursiveRectangles,name:"recursive rectangles",startAnimation:!1},{class:ShortestPath,name:"shortest path"},{class:Sorting,name:"sorting"},{class:SpinningShapes,name:"spinning shapes"},{class:Spirograph,name:"spirograph"},{class:SineWaves,name:"sine waves"}];const animationCount=animations.length;let animationId=Utils.randomInt(0,animationCount);for(;!1===animations[animationId].startAnimation;)animationId=Utils.randomInt(0,animationCount);const urlParams=new URLSearchParams(window.location.search);if(urlParams.has("animation")){const animationParam=urlParams.get("animation").replaceAll("-"," ");for(let i=0;i<animationCount;++i)animationParam===animations[i].name&&(animationId=i)}let animation=null,order=Array.from({length:animationCount},(t,e)=>e);Utils.randomShuffle(order);for(let i=0;i<animationCount;++i)animations[order[i]].prev=order[(i+animationCount-1)%animationCount],animations[order[i]].next=order[(i+1)%animationCount];function getTime(){return Date.now()}function updateAnimation(t){frames=0,avgDrawTime=0,avgElapsedTime=0,animationId=t,animation=new animations[animationId].class(canvas,colors,colorsAlt,bgColor),then=getTime(),trueThen=then,animation.resize(),updateUI()}function checkResize(){"fit"===resizeMode?(width=Math.max(container.parentElement.offsetWidth-canvas.offsetLeft),height=Math.max(container.parentElement.offsetHeight-canvas.offsetTop),width===lastWidth&&height===lastHeight||(canvas.width=width,canvas.height=height,animation.resize())):canvas.width===fixedWidth&&canvas.height===fixedHeight||(canvas.width=fixedWidth,canvas.height=fixedHeight,animation.resize()),lastWidth=canvas.width,lastHeight=canvas.height}function updateStats(t,e){elemBgStats&&(++frames,avgElapsedTime=(avgElapsedTime*(sampleSize-1)+t)/sampleSize,avgDrawTime=(avgDrawTime*(sampleSize-1)+e)/sampleSize,frames%fps==0)&&(elemBgStats.innerHTML=`canvas resolution: ${canvas.width} x ${canvas.height}</br>
                                        target frames interval: ${Math.round(framesInterval)} ms</br>
                                        target fps: ${fps}</br>
                                        avg. frames interval: ${Math.round(avgElapsedTime)} ms</br>
                                        avg. fps: ${Math.round(1e3/avgElapsedTime)}</br>
                                        avg. draw time: ${Math.round(avgDrawTime+1)} ms</br>
                                        possible fps: `+Math.round(1e3/avgDrawTime+1))}function render(){if(!paused){var e,i=getTime();let t=i-then;document.hidden&&(trueThen=i,then=i,t=0),t>=framesInterval&&(then=i-t%framesInterval,e=getTime(),checkResize(),animation.update(t),animation.draw(),e=getTime()-e,updateStats(i-trueThen,e),trueThen=i),requestAnimationFrame(render)}}function getRelativeCursorPosition(t,e){e.touches&&(e=e.touches[0]);var i=t.getBoundingClientRect();return{x:(e.clientX-i.left)/(i.right-i.left)*t.width,y:(e.clientY-i.top)/(i.bottom-i.top)*t.height}}updateAnimation(animationId),render();let eventNames={click:"click",mousedown:"down",touchstart:"down",mousemove:"move",touchmove:"move",mouseup:"up",touchend:"up"};function play(){elemBgPlayPause.innerHTML='<i class="fas fa-pause"></i> pause',paused=!1,then=getTime(),render()}function pause(){elemBgPlayPause.innerHTML='<i class="fas fa-play"></i> play',paused=!0}function hideBackground(){content.classList.remove("fade-out"),content.classList.add("fade-in"),canvas.classList.remove("show-from-25"),canvas.classList.add("fade-to-25"),elemBgShow.innerHTML='<i class="fas fa-eye"></i> show'}function showBackground(){content.classList.remove("fade-in"),content.classList.add("fade-out"),canvas.classList.remove("faded-25"),canvas.classList.remove("fade-to-25"),canvas.classList.add("show-from-25"),elemBgShow.innerHTML='<i class="fas fa-eye-slash"></i> hide'}if(["click","mousedown","touchstart","mousemove","touchmove","mouseup","touchend"].forEach(function(e){canvas.addEventListener(e,function(t){getRelativeCursorPosition(canvas,t);animation.mouseAction(getRelativeCursorPosition(canvas,t),eventNames[e])})}),elemBgShow&&elemBgShow.addEventListener("click",function(){(content.classList.contains("fade-out")?hideBackground:showBackground)()}),elemBgPrev&&elemBgPrev.addEventListener("click",function(){updateAnimation(animations[animationId].prev),play()}),elemBgNext&&elemBgNext.addEventListener("click",function(){updateAnimation(animations[animationId].next),play()}),elemBgReset&&elemBgReset.addEventListener("click",function(){updateAnimation(animationId),play()}),elemBgRestart&&elemBgRestart.addEventListener("click",function(){animation.restart(),play()}),elemBgPlayPause&&elemBgPlayPause.addEventListener("click",function(){(!1===paused?pause:play)()}),elemBgAnimationSelect&&elemBgAnimationSelect.addEventListener("input",function(t){updateAnimation(parseInt(t.target.value))}),elemBgAnimationSize){const animationSizes=["fit","512x512","800x600","1024x768","1024x1024","1280x720","1600x1200","1920x1080","2048x2048"],animationSizeDefault="fit";elemBgAnimationSize.innerHTML="";for(var size of animationSizes)size===animationSizeDefault?elemBgAnimationSize.innerHTML+=`<option selected value="${size}">${size}</option>`:elemBgAnimationSize.innerHTML+=`<option value="${size}">${size}</option>`;elemBgAnimationSize.addEventListener("input",function(t){"fit"!==(resizeMode=t.target.value)?(fixedWidth=parseInt(resizeMode.split("x")[0]),fixedHeight=parseInt(resizeMode.split("x")[1]),canvas.classList.add("fixed-size")):canvas.classList.remove("fixed-size")})}function closeSettings(){elemBgSettingsControls.classList.remove("fade-in"),elemBgSettingsControls.classList.add("fade-out")}function showSettings(){elemBgSettingsControls.classList.remove("fade-out"),elemBgSettingsControls.classList.add("fade-in"),elemBgSettingsControls.style.display="block"}function setMaxHeight(){elemBgSettingsControls.style.maxHeight=elemBgSettingsControls.parentNode.offsetHeight-parseInt(elemBgSettingsControls.style.top)+"px"}function checkIfFits(){elemBgSettingsControls.parentNode.offsetWidth<376&&(elemBgSettingsControls.style.left="0px")}function processDescription(t){var e,i=(t,e,i,s)=>t+`<span class="nowrap">[<a href="${e}" target="_blank" rel="noopener noreferrer">${i}</a>]</span>`+s;for(e of[{replaceStr:i("$1","$3",'<i class="fa fa-wikipedia-w"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?en\.wikipedia\.org\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:i("$1","$3",'<i class="fa fa-youtube"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?youtube\.com\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:i("$1","$3",'<i class="fa fa-github"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?github\.com\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:i("$1","$3",'<i class="fas fa-link"></i> $2',"$4"),regexp:/(.*)\[(.*)\]\((https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))\)(.*)/g},{replaceStr:i("$1","$2",'<i class="fas fa-link"></i> $2',"$3"),regexp:/(.*)[^"](https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*))[^"](.*)/g}])t=t.replaceAll(e.regexp,e.replaceStr);return t="<p>"+(t=t.trim().replaceAll("\n\n","</p><p>"))+"</p>"}function getPropId(t){return t.split(/(?=[A-Z])/).join(" ").toLowerCase().replaceAll(/\.|\]|s\[/g,"-")}function updateUI(){elemBgName&&(elemBgName.innerHTML=animation.getName()),elemBgCode&&(elemBgCode.href=animation.getCodeUrl()),elemBgDesc&&(elemBgDesc.innerHTML=processDescription(animation.getDescription()));let animationSelectOptions="";for(let i=0;i<animations.length;++i){const name=animations[i].name;animations[animationId].name===name?animationSelectOptions+=`<option selected value="${i}">${name}</option>`:animationSelectOptions+=`<option value="${i}">${name}</option>`}elemBgAnimationSelect.innerHTML=animationSelectOptions;const settings=animation.getSettings();let elemBgSettingsList=document.getElementById("background-settings-controls-list");elemBgSettingsControls&&elemBgSettingsList&&(elemBgSettingsList.innerHTML="",0===settings.length&&(elemBgSettingsList.innerHTML="There are no settings (yet) for this animation"),settings.forEach(function(setting,index){const value=eval("animation."+setting.prop),name=getPropId(setting.prop).replaceAll("-"," "),elemId=getPropId(setting.prop)+"-controls";let optionControls=`<div><span class="setting-name">${name}</span><span class="nowrap setting-value-control">`;if(["int","float","bool"].includes(setting.type)){let inputParams=`name="${setting.prop}" id="${elemId}" value="${value}"`;["int","float"].includes(setting.type)&&(setting.step?inputParams+=` step="${setting.step}"`:"float"===setting.type?inputParams+=' step="0.01"':inputParams+=' step="1"',inputParams+=` min="${setting.min}" max="${setting.max}"`),"bool"===setting.type&&value&&(inputParams+=" checked"),"bool"===setting.type?optionControls+=`<label class="form-checkbox setting-input"><input type="checkbox" ${inputParams}><i class="form-icon"></i></label>`:optionControls+=`<input type="range" class="setting-input slider" ${inputParams}">`,optionControls+=`[<output class="setting-value">${value}</output>]`}else if("select"===setting.type){optionControls+=`<select class="form-select setting-select" name="${setting.prop}" id="${elemId}">`;for(var v of setting.values)v===value?optionControls+=`<option selected value="${v}">${v}</option>`:optionControls+=`<option value="${v}">${v}</option>`;optionControls+="</select>"}else"text"===setting.type&&(optionControls+=`<span class="setting-text">${setting.value.replaceAll("<","&lt;").replaceAll(">","&gt;")}</span>`);optionControls+="</span></div>",elemBgSettingsList.innerHTML+=optionControls}),settings.forEach(function(setting,index){const elemId=getPropId(setting.prop)+"-controls";let elem=document.getElementById(elemId);elem&&elem.addEventListener("input",function(e){if("checkbox"===e.target.type)null!==e.target.parentNode.nextElementSibling&&"output"===e.target.parentNode.nextElementSibling.type&&(e.target.parentNode.nextElementSibling.value=e.target.checked),eval(`animation.${setting.prop} = e.target.checked;`);else{null!==e.target.nextElementSibling&&"output"===e.target.nextElementSibling.type&&(e.target.nextElementSibling.value=e.target.value);let value=e.target.value;"int"===setting.type?value=parseInt(e.target.value):"float"===setting.type&&(value=parseFloat(e.target.value)),eval(`animation.${setting.prop} = value;`)}setting.toCall&&animation[setting.toCall](),elemBgName.innerHTML=animation.getName(),play()})}))}elemBgAnimationFps&&(elemBgAnimationFps.innerHTML='<option value="15">15</option><option selected value="30">30</option><option value="60">60</option>',elemBgAnimationFps.addEventListener("input",function(t){fps=parseInt(t.target.value),framesInterval=1e3/fps})),elemBgColor&&(elemBgColor.innerHTML='<option value="#FFFFFF" selected>white</option><option value="#000000">black</option>',elemBgColor.addEventListener("input",function(t){bgColor=t.target.value,animation.bgColor=t.target.value})),elemBgSettings&&elemBgSettingsControls&&elemBgSettingsClose&&(checkIfFits(),setMaxHeight(),elemBgSettings.addEventListener("click",function(){(elemBgSettingsControls.classList.contains("fade-out")||"none"===elemBgSettingsControls.style.display?showSettings:closeSettings)()}),elemBgSettingsClose.addEventListener("click",function(){closeSettings()}),["mousedown","touchstart"].forEach(function(t){elemBgSettingsControls.addEventListener(t,function(t){t.target===t.currentTarget&&((t=t.touches?t.touches[0]:t).target.classList.add("moving"),t.target.clickAnchorX=t.clientX-parseInt(t.target.style.left),t.target.clickAnchorY=t.clientY-parseInt(t.target.style.top))})}),["mousemove","touchmove"].forEach(function(t){addEventListener(t,function(i){if(elemBgSettingsControls.classList.contains("moving")){let t=(i=i.touches?i.touches[0]:i).clientX-elemBgSettingsControls.clickAnchorX,e=i.clientY-elemBgSettingsControls.clickAnchorY;t<0&&(t=0),e<0&&(e=0),elemBgSettingsControls.style.left=t+"px",elemBgSettingsControls.style.top=e+"px",setMaxHeight()}})}),["mouseup","touchend"].forEach(function(t){addEventListener(t,function(t){elemBgSettingsControls.classList.remove("moving")})}))}},{"./3n+1":1,"./cardioids":4,"./circular-waves":5,"./coding":6,"./figures-spiral":8,"./game-of-life":10,"./game-of-life-isometric":9,"./glitch":11,"./gradient-descent":12,"./matrix":15,"./mlinpl":16,"./network":17,"./neural-network":18,"./noisy-lines":20,"./particles-and-attractors":21,"./particles-vortex":22,"./particles-waves":23,"./perlin-noise-particles":24,"./quadtree":25,"./recursive-rectangles":27,"./rock-paper-scissors-automata":28,"./sand-automata":29,"./shortest-path":30,"./sine-waves":31,"./sorting":32,"./spinning-shapes":33,"./spirograph":34,"./tree-visualization":35,"./utils":36}],15:[function(t,e,i){"use strict";var s=t("./animation");const a=t("./utils");class r extends s{constructor(t,e,i,s,a=20,r=.6,h=.01,n=!1){super(t,e,i,s,"Matrix digital rain","matrix.js",`
Recreation of matrix digital rain based on this analysis
of the original effect on this 
[website](https://carlnewton.github.io/digital-rain-analysis/).

I'm a huge fan of the first movie.

Coded with no external dependencies, using only canvas API.
`),this.dropsSize=a,this.dropsSpeed=r,this.fadingSpeed=h,this.originalMatrixColors=n,this.flipProp=.25,this.errorProp=.1,this.cellWidth=0,this.cellHeight=0,this.columns=0,this.columnHeight=0,this.drops=[],this.textColor=null,this.imageData=null,this.textColor=this.colors[0];this.characters='0123456789*+:=.<>#@!?^~"'}dropSpawnPoint(t){return a.randomInt(0,Math.min(t-1,this.columnHeight/2),this.rand)-1}dropDespawn(t){return this.rand()<.1*Math.pow(t/this.columnHeight,2)||t>this.columnHeight}drawCharacter(t,e,i,s){this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(e-this.cellWidth/2,i,this.cellWidth,this.cellHeight),this.ctx.fillStyle=s,this.rand()<this.flipProp?(this.ctx.save(),this.ctx.translate(e,i),this.ctx.scale(-1,1),this.ctx.fillText(t,0,0),this.ctx.restore()):this.ctx.fillText(t,e,i)}draw(){this.fadeOut(this.fadingSpeed),this.ctx.font=this.dropsSize+"px monospace",this.ctx.textAlign="center",this.ctx.textBaseline="top";for(var t of this.drops){var e,i;Math.floor(t.y)!==Math.floor(t.y+this.dropsSpeed)?(t.y+=this.dropsSpeed,e=t.x*this.cellWidth+this.cellWidth/2,i=Math.floor(t.y)*this.cellHeight,this.drawCharacter(t.char,e,i,this.textColor),t.char=a.randomChoice(this.characters,this.rand),this.dropDespawn(t.y)&&(t.y=this.dropSpawnPoint(t.y)),this.rand()<this.errorProp&&(i=a.randomInt(-8,8,this.rand),this.drawCharacter(a.randomChoice(this.characters,this.rand),e,Math.floor(i+t.y)*this.cellHeight,this.textColor))):t.y+=this.dropsSpeed}this.imageData=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}resize(){if(this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0),this.cellHeight=this.dropsSize,this.cellWidth=Math.ceil(this.dropsSize/1.618),this.columns=this.ctx.canvas.width/this.cellWidth,this.columnHeight=this.ctx.canvas.height/this.cellHeight,this.drops.length<this.columns)for(let t=this.drops.length;t<this.columns;++t)this.drops.push({char:a.randomChoice(this.characters,this.rand),x:t,y:this.dropSpawnPoint(this.columnHeight)})}restart(){this.drops=[],super.restart()}getSettings(){return[{prop:"dropsSize",type:"int",min:8,max:64,toCall:"resize"},{prop:"dropsSpeed",type:"float",min:0,max:1},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.5},this.getSeedSettings()]}}e.exports=r},{"./animation":3,"./utils":36}],16:[function(t,e,i){"use strict";var s=t("./animation");const o=t("./utils");class a extends s{constructor(t,e,i,s,a=1,r=125,h=!1){super(t,e,i,s,"ML in PL Network","mlinpl.js",`
Simple network animation, I created for ML in PL.

For the first time used on
[ML in PL Conference 2023 website](https://conference2023.mlinpl.org/).
and [MLSS^S 2023 website](https://mlss2023.mlinpl.org/).

Coded with no external dependencies, using only canvas API.
`),this.particlesDensity=a,this.connectionThreshold=r,this.originalColors=h,this.width=0,this.height=0,this.logo=new Image,this.logo.src="assets/logo-mlinpl.png",this.particlesColors=[this.colors[0],"#000","#222","#444","#AAA","#EEE"],this.bgParticles=[],this.mgParticles=[],this.fgParticles=[],this.bgParticlesCfg={colors:{5:1},lineColors:{5:1},sizeMin:4,sizeRange:3,speedMax:.5,groups:[[0,1],[0,2],[1,2]],density:15e-5},this.mgParticlesCfg={colors:{4:1},lineColors:{4:1},sizeMin:2,sizeRange:2,speedMax:.75,groups:[[]],density:15e-5},this.fgParticlesCfg={colors:{0:.4,1:.6},lineColors:{1:.3,2:.3,3:.3},sizeMin:2,sizeRange:5,speedMax:1,groups:[[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[0],[1],[2],[3],[4],[0],[1],[2],[3],[4]],density:3e-4}}updateParticles(t,e){for(var i of t){var s=Math.sin(i.x/i.freq)*i.amp,a=(i.x+=i.velX*e/33,Math.sin(i.x/i.freq)*i.amp);i.y+=i.velY*(s-a)*e/33,i.x<-this.connectionThreshold?i.x=this.width+this.connectionThreshold:i.x>this.width+this.connectionThreshold&&(i.x=-this.connectionThreshold),i.y+i.size>=this.height&&(i.velY*=-1)}}createParticles(e,i,s,a,r){var h=s*a*r.density*this.particlesDensity,n=[];for(let t=0;t<h;t++)n.push({x:this.rand()*(s+2*this.connectionThreshold)+e-this.connectionThreshold,y:+o.randomNormal(0,1,this.rand)/2*a+i,velX:(2*this.rand()-1)*r.speedMax,velY:(2*this.rand()-1)*r.speedMax,freq:100*this.rand()+100,amp:200*this.rand(),size:this.rand()*r.sizeRange+r.sizeMin,color:o.randomRulletChoice(r.colors,this.rand),lineColor:o.randomRulletChoice(r.lineColors,this.rand),groups:o.randomChoice(r.groups,this.rand)});return n}spawnParticles(t,e,i,s){this.bgParticles.push(...this.createParticles(t,e,i,s,this.bgParticlesCfg)),this.mgParticles.push(...this.createParticles(t,e,i,s,this.mgParticlesCfg)),this.fgParticles.push(...this.createParticles(t,e,i,s,this.fgParticlesCfg))}update(t){super.update(t),this.updateParticles(this.bgParticles,t),this.updateParticles(this.mgParticles,t),this.updateParticles(this.fgParticles,t)}drawParticles(i){for(let e=0;e<i.length-1;e++)if(0!==i[e].groups.length)for(let t=e+1;t<i.length;t++){var s=i[e],a=i[t];if(!(o.distVec2d(s,a)>this.connectionThreshold))for(var r of s.groups)if(a.groups.includes(r)){o.drawLine(this.ctx,s.x,s.y,a.x,a.y,1,this.particlesColors[s.lineColor]);break}}for(var t of i)o.fillCircle(this.ctx,t.x,t.y,t.size,this.particlesColors[t.color])}draw(){this.originalColors?this.particlesColors[0]="#E7322A":this.particlesColors[0]=this.colors[0],this.bgColor="#FFFFFF",this.clear(),this.drawParticles(this.bgParticles),this.drawParticles(this.mgParticles),this.drawParticles(this.fgParticles),this.originalColors&&this.ctx.drawImage(this.logo,(this.width-this.logo.width)/2,(this.height-this.logo.height)/2)}resize(){this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height,this.bgParticles=[],this.mgParticles=[],this.fgParticles=[],this.spawnParticles(0,0,this.width,this.height)}getSettings(){return[{prop:"particlesDensity",type:"float",min:0,max:2,step:.1,toCall:"resize"},{prop:"connectionThreshold",type:"float",min:0,max:250,step:1},{prop:"originalColors",type:"bool"},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],17:[function(t,e,i){"use strict";var s=t("./animation");const h=t("./utils"),r=t("./delaunay");class a extends s{constructor(t,e,i,s,a=2e-4,r=!0,h=!1,n=125){super(t,e,i,s,"Delaunay triangulation for a cloud of particles","network.js",`
In this animation, the Delaunay triangulation algorithm 
is applied to a set of moving particles (points).
Then if the edge length between two points is below a threshold value,
a line is drawn between them, creating a network-like structure.

You can read about the Delaunay triangulation on [Wikipedia](https://en.wikipedia.org/wiki/Delaunay_triangulation)

Source of Delaunay triangulation implementation used in this animation
can be found in this [repository](https://github.com/darkskyapp/delaunay-fast).
`),this.particlesDensity=a,this.fillTriangles=r,this.drawParticles=h,this.distanceThreshold=n,this.width=0,this.height=0,this.particles=[],this.mouseDown=!1,this.mouseParticle={x:0,y:0,color:null}}drawTriangle(t,e,i){var s=Math.max(h.distVec2d(t,e),h.distVec2d(t,e),h.distVec2d(e,i));s>this.distanceThreshold||(this.ctx.beginPath(),h.pathClosedShape(this.ctx,[t,e,i]),e=h.lerpColor(t.color,this.bgColor,h.easeInSine(s/this.distanceThreshold)),this.fillTriangles?(this.ctx.fillStyle=e,this.ctx.fill()):(this.ctx.lineWidth=1,this.ctx.strokeStyle=e,this.ctx.stroke()))}update(t){super.update(t);for(var e of this.particles)e.x+=e.velX*t*this.speed,e.y+=e.velY*t*this.speed,(e.x<0||e.x>this.width)&&(e.velX*=-1),(e.y<0||e.y>this.height)&&(e.velY*=-1)}draw(){if(this.clear(),this.mouseDown&&this.particles.push(this.mouseParticle),0<this.particles.length){var e=r.triangulate(this.particles.map(function(t){return[t.x,t.y]}));for(let t=0;t<e.length;t+=3){var i=this.particles[e[t]],s=this.particles[e[t+1]],a=this.particles[e[t+2]];this.drawTriangle(i,s,a)}}if(this.drawParticles)for(var t of this.particles)h.fillCircle(this.ctx,t.x,t.y,2,t.color);this.mouseDown&&this.particles.pop()}spawnParticles(e,i,s,a){var r=s*a*this.particlesDensity;for(let t=0;t<r;t++)this.particles.push({x:this.rand()*s+e,y:this.rand()*a+i,velY:(2*this.rand()-1)/30,velX:(2*this.rand()-1)/30,color:h.randomChoice(this.colors,this.rand)})}restart(){this.particles=[],this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height,this.spawnParticles(0,0,this.width,this.height)}resize(){var t=this.ctx.canvas.width-this.width,e=this.ctx.canvas.height-this.height;0<t&&this.spawnParticles(this.width,0,t,this.height),0<e&&this.spawnParticles(0,this.height,this.width,e),(0<t||0<e)&&this.spawnParticles(this.width,this.height,t,e),this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height;const i=this.width,s=this.height;this.particles=this.particles.filter(function(t){return!(t.x<0||t.x>i||t.y<0||t.y>s)})}mouseAction(t,e){"down"===e?(this.mouseDown=!0,this.mouseParticle.color=h.randomChoice(this.colors,this.rand)):"up"===e?this.mouseDown=!1:("down"===e||"move"===e&&this.mouseDown)&&(this.mouseParticle.x=t.x,this.mouseParticle.y=t.y)}getSettings(){return[{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.002,toCall:"restart"},{prop:"fillTriangles",type:"bool"},{prop:"drawParticles",type:"bool"},{prop:"distanceThreshold",type:"int",min:0,max:200},{prop:"speed",type:"float",step:.1,min:-4,max:4},{prop:"addAParticle",type:"text",value:"<hold mouse button/touch>"},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./delaunay":7,"./utils":36}],18:[function(t,e,i){"use strict";var s=t("./animation");const c=t("./utils");class a extends s{constructor(t,e,i,s){super(t,e,i,s,"visualization of simple neural network","neural-network.js"),this.network=[],this.nLayers=0,this.baseNodeSize=3,this.baseLineSize=1,this.fps=1.5}update(t){if(0!==this.network.length){for(var e of this.network[0])e.v=c.randomRange(-1,1);for(let e=1;e<this.nLayers;e++)for(var i of this.network[e]){for(let t=i.v=0;t<this.network[e-1].length;++t)i.v+=this.network[e-1][t].v*i.w[t];e===this.nLayers-1?i.nlv=1/(1+Math.exp(-i.v)):i.nlv=Math.max(0,i.v)}}}draw(){this.clear();for(let t=0;t<this.nLayers-1;t++){var e,i=this.network[t],s=this.network[t+1];for(e of i)for(var a of s){var r=c.clip(e.v,0,1),h=this.colors[this.colors.length-1-Math.floor(r*this.colors.length)];this.ctx.globalAlpha=r,c.drawLine(this.ctx,e.x,e.y,a.x,a.y,1+r,h)}}this.ctx.globalAlpha=1;for(let e=0;e<this.nLayers;++e){var n;for(n of this.network[e]){var o=c.clip(n.nlv,0,1),l=c.clip(2*n.nlv,0,4),o=this.colors[this.colors.length-1-Math.floor(o*this.colors.length)],l=this.baseNodeSize+l;c.fillCircle(this.ctx,n.x,n.y,l,o),this.ctx.font="12px sans-serif",this.ctx.textAlign="center";let t=`ReLU(${c.round(n.v,2)}) = `+c.round(n.nlv,2);0===e?t=""+c.round(n.v,2):e===this.nLayers-1&&(t=`Sigmoid(${c.round(n.v,2)}) = `+c.round(n.nlv,2)),this.ctx.fillText(t,n.x,n.y-3*this.baseNodeSize)}}}resize(){this.clear();var t=this.ctx.canvas.width,a=this.ctx.canvas.height,e=(this.network=[],this.nLayers=c.clip(Math.floor(t/150),3,7),50*t/500),r=(t-2*e)/(this.nLayers-1),h=a/17;let n=e;for(let s=0;s<this.nLayers;s++){var o=[];let e=0,i=(e=0==s||s==this.nLayers-1?Math.floor(c.randomRange(4,16)):c.randomChoice([8,12,16]),a/2-Math.floor(e/2)*h);e%2==0&&(i+=h/2);for(let t=0;t<e;t++){var l={x:n,y:i,v:0,nlv:0,w:null};0<s&&(l.w=c.randomArray(this.network[s-1].length,-1,1)),o.push(l),i+=h}this.network.push(o),n+=r}this.update(0),this.draw()}getSettings(){return[]}}e.exports=a},{"./animation":3,"./utils":36}],19:[function(t,e,i){"use strict";var s=this;function a(t,e,i){this.x=t,this.y=e,this.z=i}s=s.noise={},a.prototype.dot2=function(t,e){return this.x*t+this.y*e},a.prototype.dot3=function(t,e,i){return this.x*t+this.y*e+this.z*i};var r=[new a(1,1,0),new a(-1,1,0),new a(1,-1,0),new a(-1,-1,0),new a(1,0,1),new a(-1,0,1),new a(1,0,-1),new a(-1,0,-1),new a(0,1,1),new a(0,-1,1),new a(0,1,-1),new a(0,-1,-1)],h=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],C=new Array(512),b=new Array(512),d=(s.seed=function(t){0<t&&t<1&&(t*=65536),(t=Math.floor(t))<256&&(t|=t<<8);for(var e=0;e<256;e++){var i=1&e?h[e]^255&t:h[e]^t>>8&255;C[e]=C[e+256]=i,b[e]=b[e+256]=r[i%12]}},s.seed(0),.5*(Math.sqrt(3)-1)),p=(3-Math.sqrt(3))/6,M=1/6;function m(t){return t*t*t*(t*(6*t-15)+10)}function u(t,e,i){return(1-i)*t+i*e}s.simplex2=function(t,e){var i=(t+e)*d,s=Math.floor(t+i),i=Math.floor(e+i),a=(s+i)*p,t=t-s+a,e=e-i+a,a=e<t?(c=1,0):(c=0,1),r=t-c+p,h=e-a+p,n=t-1+2*p,o=e-1+2*p,l=b[(s&=255)+C[i&=255]],c=b[s+c+C[i+a]],a=b[1+s+C[1+i]],s=.5-t*t-e*e,i=s<0?0:(s*=s)*s*l.dot2(t,e),s=.5-r*r-h*h,l=s<0?0:(s*=s)*s*c.dot2(r,h),t=.5-n*n-o*o,e=t<0?0:(t*=t)*t*a.dot2(n,o);return 70*(i+l+e)},s.simplex3=function(t,e,i){var s=(t+e+i)*(1/3),a=Math.floor(t+s),r=Math.floor(e+s),s=Math.floor(i+s),h=(a+r+s)*M,t=t-a+h,e=e-r+h,i=i-s+h,h=e<=t?i<=e?(S=y=x=1,w=v=0):y=i<=t?(S=w=v=0,x=1):(S=v=x=0,w=1):e<i?(y=v=x=0,S=w=1):t<i?(y=w=x=0,S=v=1):(S=y=v=1,w=x=0),n=t-x+M,o=e-v+M,l=i-w+M,c=t-y+2*M,d=e-S+2*M,p=i-h+2*M,m=t-1+.5,u=e-1+.5,g=i-1+.5,f=b[(a&=255)+C[(r&=255)+C[s&=255]]],x=b[a+x+C[r+v+C[s+w]]],v=b[a+y+C[r+S+C[s+h]]],w=b[1+a+C[1+r+C[1+s]]],y=.6-t*t-e*e-i*i,S=y<0?0:(y*=y)*y*f.dot3(t,e,i),h=.6-n*n-o*o-l*l,a=h<0?0:(h*=h)*h*x.dot3(n,o,l),r=.6-c*c-d*d-p*p,s=r<0?0:(r*=r)*r*v.dot3(c,d,p),y=.6-m*m-u*u-g*g,f=y<0?0:(y*=y)*y*w.dot3(m,u,g);return 32*(S+a+s+f)},s.perlin2=function(t,e){var i=Math.floor(t),s=Math.floor(e),a=(t-=i,e-=s,b[(i&=255)+C[s&=255]].dot2(t,e)),r=b[i+C[1+s]].dot2(t,e-1),h=b[1+i+C[s]].dot2(t-1,e),i=b[1+i+C[1+s]].dot2(t-1,e-1),s=m(t);return u(u(a,h,s),u(r,i,s),m(e))},s.perlin3=function(t,e,i){var s=Math.floor(t),a=Math.floor(e),r=Math.floor(i),h=(t-=s,e-=a,i-=r,b[(s&=255)+C[(a&=255)+C[r&=255]]].dot3(t,e,i)),n=b[s+C[a+C[1+r]]].dot3(t,e,i-1),o=b[s+C[1+a+C[r]]].dot3(t,e-1,i),l=b[s+C[1+a+C[1+r]]].dot3(t,e-1,i-1),c=b[1+s+C[a+C[r]]].dot3(t-1,e,i),d=b[1+s+C[a+C[1+r]]].dot3(t-1,e,i-1),p=b[1+s+C[1+a+C[r]]].dot3(t-1,e-1,i),s=b[1+s+C[1+a+C[1+r]]].dot3(t-1,e-1,i-1),a=m(t),r=m(e),t=m(i);return u(u(u(h,c,a),u(n,d,a),t),u(u(o,p,a),u(l,s,a),t),r)}},{}],20:[function(t,e,i){"use strict";var s=t("./animation");const l=t("./utils");class a extends s{constructor(t,e,i,s,a=100,r=.07,h=.06,n=.5,o=1){super(t,e,i,s,"noisy lines","noisy-lines.js",`
Another animation based on Perlin noise. 
The lines are disorted by adding noise to the position of each vertex.
The disortion are larger as the vertices are further from the center.

Coded with no external dependencies, using only canvas API.
`),this.noiseXIncr=r,this.noiseYIncr=h,this.noiseRange=n,this.lines=a,this.speed=o,this.margin=.1}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var t=this.ctx.canvas.width/2,e=this.ctx.canvas.height/2,s=t*(1-this.margin),a=e*(1-this.margin),r=2*a/(this.lines-1);this.ctx.translate(t,e);let h=.3*this.time;for(let t=0;t<this.lines;++t){let e=-a+t*r,i=.3*this.time;h+=this.noiseYIncr,this.ctx.beginPath();for(let t=-s;t<=s;t+=5){i+=this.noiseXIncr;var n=l.remap(this.noise.perlin2(i,h),-1,1,1-this.noiseRange,1),o=t*n,n=e*n;t==-s?this.ctx.moveTo(o,n):this.ctx.lineTo(o,n)}this.ctx.stroke()}this.ctx.resetTransform()}getSettings(){return[{prop:"lines",type:"int",min:2,max:250},{prop:"noiseXIncr",type:"float",min:-.2,max:.2,step:.001},{prop:"noiseYIncr",type:"float",min:-.2,max:.2,step:.001},{prop:"noiseRange",type:"float",min:0,max:1,step:.01},{prop:"speed",type:"float",min:-8,max:8},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],21:[function(t,e,i){"use strict";var s=t("./animation");const u=t("./utils");class a extends s{constructor(t,e,i,s,a=1e4,r="random",h=.03,n="random",o="random",l="random",c="random",d=!1,p=1,m=!1){super(t,e,i,s,"system of particles and attractors","particles-and-attractors.js",`
Very simple particle system with attractors.
In this system, distance and momentum are ignored.
The new velocity vector of a particle is calculated as the sum of angles
between the particle and all attractors.
Because the velocity does not depend on the distance to the attractors,
and momentum is not preserved, the particles are not "catapulted" away from the attractors.
This results in a system that is mesmerizing to watch.

Coded with no external dependencies, using only canvas API.
`),this.particles=[],this.numParticles=a,this.particlesSpeed=this.assignIfRandom(r,u.round(u.randomRange(.25,.5))),this.fadingSpeed=h,this.nextFadeStep=0,this.attractors=[],this.drawAttractors=d,this.numAttractors=this.assignIfRandom(n,u.randomInt(3,7)),this.centralAttractor=this.assignIfRandom(o,u.randomChoice([!1,!0])),this.attractorsSystems=["orbits","eights","circle"],this.attractorsSystem=this.assignIfRandom(l,u.randomChoice(this.attractorsSystems)),this.attractorsSpeed=this.assignIfRandom(c,u.round(u.randomRange(.05,.1)*u.randomChoice([-1,1]))),this.attractorsPosition=0,this.startingPosition=u.randomRange(0,10),this.directionScale=1,this.scale=p,this.rainbowColors=m,this.mouseDown=!1,this.mouseAttractor={x:0,y:0},this.setup()}setup(){this.particles=[];for(let t=0;t<this.numParticles;++t)this.particles.push(u.rotateVec2d({x:u.randomRange(1,100,this.rand),y:0,prevX:0,prevY:0},t))}update(e){super.update(e),this.nextFadeStep=this.fadingSpeed*e/33,this.attractorsPosition+=e/1e3*this.attractorsSpeed;var i,s=this.startingPosition+this.attractorsPosition,a=this.numAttractors+1-this.centralAttractor,r=1-this.centralAttractor;if(this.attractors=[],"orbits"===this.attractorsSystem){var h=Math.max(this.ctx.canvas.width,this.ctx.canvas.height)/(2*(this.numAttractors-1));for(let t=r;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(t*h,0),s*t))}else if("eights"===this.attractorsSystem){var n=Math.max(this.ctx.canvas.width,this.ctx.canvas.height)/this.numAttractors;for(let t=r;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(t*Math.sin(s*Math.PI/2)*n,0),s*t))}else if("circle"===this.attractorsSystem){this.centralAttractor&&this.attractors.push({x:0,y:0});var o=.4*Math.min(this.ctx.canvas.width,this.ctx.canvas.height);for(let t=1;t<a;++t)this.attractors.push(u.rotateVec2d(u.createVec2d(o,0),2*(s+t)*Math.PI/(a-1)))}this.mouseDown&&this.attractors.push(this.mouseAttractor);for(i of this.particles){let t=0;for(var l of this.attractors)t+=Math.atan2(l.y-i.y,l.x-i.x)*this.directionScale;i.prevX=i.x,i.prevY=i.y,i.x+=Math.cos(t)*this.particlesSpeed*e,i.y+=Math.sin(t)*this.particlesSpeed*e}}draw(){this.fadeOut(this.nextFadeStep),this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),this.ctx.scale(this.scale,this.scale);var t,e=this.rainbowColors?`hsl(${this.time/5*360}, 100%, 75%)`:this.colors[0];for(t of this.particles)u.drawLine(this.ctx,t.prevX,t.prevY,t.x,t.y,1,e);if(this.drawAttractors)for(var i of this.attractors)u.fillCircle(this.ctx,i.x,i.y,5,this.colorsAlt[2]);this.ctx.resetTransform()}resize(){this.clear()}restart(){super.restart(),this.attractorsPosition=0,this.setup()}mouseAction(t,e){"down"===e?this.mouseDown=!0:"up"===e?this.mouseDown=!1:("down"===e||"move"===e&&this.mouseDown)&&(console.log("attractor!"),this.mouseAttractor={x:(t.x-this.ctx.canvas.width/2)/this.scale,y:(t.y-this.ctx.canvas.height/2)/this.scale})}getSettings(){return[{prop:"numParticles",type:"int",min:1e3,max:2e4,toCall:"setup"},{prop:"particlesSpeed",type:"float",min:.1,max:1.5},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},{prop:"attractorsSystem",type:"select",values:this.attractorsSystems},{prop:"numAttractors",type:"int",min:3,max:7},{prop:"centralAttractor",type:"bool"},{prop:"attractorsSpeed",type:"float",min:-.25,max:.25},{prop:"directionScale",type:"float",min:0,max:4},{prop:"addAnAttractor",type:"text",value:"<hold mouse button/touch>"},{prop:"drawAttractors",type:"bool"},{prop:"scale",type:"float",min:.05,max:1.95},{prop:"rainbowColors",type:"bool"}]}}e.exports=a},{"./animation":3,"./utils":36}],22:[function(t,e,i){"use strict";var s=t("./animation");const d=t("./utils");class a extends s{constructor(t,e,i,s,a=1500,r="random",h="random",n="random",o="random",l="random",c=1){super(t,e,i,s,"vortex of particles","particles-vortex.js",`
Particles vortex with randomized speed and direction.
The illusion of a 3D vortex is created by calculating the 2D position 
of each particle, each frame, using simple trigonometry functions.

Coded with no external dependencies, using only canvas API.
`),this.particles=a,this.radiusMin=50,this.radiusMax=250,this.radius=this.assignIfRandom(r,d.round(d.randomRange(this.radiusMin,this.radiusMax),2)),this.speedMin=.02,this.speedMax=.05,this.speed=this.assignIfRandom(h,d.round(d.randomRange(this.speedMin,this.speedMax)*d.randomChoice([-1,1]),2)),this.rotationSpeedMin=.01,this.rotationSpeedMax=.02,this.rotationSpeed=this.assignIfRandom(n,d.round(d.randomRange(this.rotationSpeedMin,this.rotationSpeedMax)*d.randomChoice([-1,1]),2)),this.dirMax=.75,this.dirX=this.assignIfRandom(o,d.round(d.randomRange(-this.dirMax,this.dirMax),2)),this.dirY=this.assignIfRandom(l,d.round(d.randomRange(-this.dirMax,this.dirMax),2)),this.scale=c}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var t=Math.min(this.ctx.canvas.width,this.ctx.canvas.height)/4,e=this.ctx.canvas.width/2+this.dirX*t,t=this.ctx.canvas.height/2+this.dirY*t,i=Math.round(1e4*this.time)/10;this.ctx.translate(e,t),this.ctx.scale(this.scale,this.scale),this.ctx.beginPath();for(let t=1;t<=this.particles;t++){var s=this.radius+Math.pow(t/(this.particles/1.5),2)*t/2,a=100*this.noise.perlin2(.1*t+i,.1)+i*this.rotationSpeed,r=Math.cos(a)*s+Math.sqrt(t*this.radius)*this.dirX,a=Math.sin(a)*s+Math.sqrt(t*this.radius)*this.dirY;d.pathCircle(this.ctx,r,a,.01*t)}this.ctx.stroke(),this.ctx.resetTransform()}getSettings(){return[{prop:"particles",type:"int",min:1,max:3e3},{prop:"radius",type:"float",min:this.radiusMin,max:this.radiusMax},{prop:"speed",type:"float",min:-this.speedMax,max:this.speedMax},{prop:"rotationSpeed",type:"float",min:-this.rotationSpeedMax,max:this.rotationSpeedMax},{prop:"dirX",type:"float",min:-this.dirMax,max:this.dirMax},{prop:"dirY",type:"float",min:-this.dirMax,max:this.dirMax},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],23:[function(t,e,i){"use strict";var s=t("./animation");const a=t("./utils");class r extends s{constructor(t,e,i,s,a=.5,r=.01,h=.001,n=.02){super(t,e,i,s,"particles waves","particles-waves.js",`
"Particles waves" animation.
The effect was achieved by modifying Perlin noise animation.

Coded with no external dependencies, using only canvas API.
`),this.particlesSpeed=a,this.particlesDensity=r,this.noiseScale=h,this.fadingSpeed=n,this.nextFadeStep=0,this.particles=[],this.width=0,this.height=0}update(t){super.update(t),this.nextFadeStep=this.fadingSpeed*t/33;for(var e of this.particles){var i=2*this.noise.perlin3(e.x*this.noiseScale*2,e.y*this.noiseScale*3,this.frame*this.noiseScale*3)*Math.PI;e.x+=100*this.particlesSpeed*Math.tan(i)*t/1e3,e.y+=100*this.particlesSpeed*Math.sin(i)*t/1e3,e.x<0&&(e.x=this.width),e.x>this.width&&(e.x=0),e.y<0&&(e.y=this.height),e.y>this.height&&(e.y=0)}}draw(){this.fadeOut(this.nextFadeStep);for(var t of this.particles)this.ctx.fillStyle=t.color,this.ctx.fillRect(t.x,t.y,1,1)}resize(){this.clear(),this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height;var e=this.width*this.height*this.particlesDensity;this.particles=[];for(let t=0;t<e;t++){var i=this.rand()*this.width,s=this.rand()*this.height;this.particles.push({x:i,y:s,color:a.lerpColor(this.colorA,this.colorB,i/this.width)})}}getSettings(){return[{prop:"particlesSpeed",type:"float",step:.01,min:.1,max:2},{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.05,toCall:"resize"},{prop:"noiseScale",type:"float",step:.001,min:.001,max:.01},{prop:"fadingSpeed",type:"float",step:.001,min:0,max:.1},this.getSeedSettings()]}}e.exports=r},{"./animation":3,"./utils":36}],24:[function(t,e,i){"use strict";var s=t("./animation");const l=t("./utils");class a extends s{constructor(t,e,i,s,a=7e-4,r="random",h="random",n="random",o=0){super(t,e,i,s,"particles moving through Perlin noise","perlin-noise-particles.js",`
Particles moving through Perlin noise.

Coded with no external dependencies, using only canvas API.
`),this.particlesDensity=a,this.noiseScale=this.assignIfRandom(r,l.randomChoice([.001,.002,.003])),this.particlesSpeed=this.assignIfRandom(h,l.randomChoice([1,1.5,2])),this.particlesSize=this.assignIfRandom(n,l.randomChoice([1,1.5,2])),this.fadingSpeed=o,this.width=0,this.height=0,this.particles=[],this.imageData=null}update(t){this.time+=t/1e3,++this.frame;let e=1,i=this.particlesSpeed;for(;1<i;)i/=2,e*=2;for(var s of this.particles)s.prevX=s.x,s.prevY=s.y;for(let t=0;t<e;++t)for(var a of this.particles){var r=2*this.noise.perlin2(a.x*this.noiseScale,a.y*this.noiseScale)*Math.PI/this.noiseScale;a.x+=Math.cos(r)*a.speed*i,a.y+=Math.sin(r)*a.speed*i}}draw(){this.fadeOut(this.fadingSpeed);for(var t of this.particles)l.drawLine(this.ctx,t.prevX,t.prevY,t.x,t.y,2*t.radius*this.particlesSize,t.color);this.imageData=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}spawnParticles(e,i,s,a){var r=s*a*this.particlesDensity;for(let t=0;t<r;t++){var h=this.rand()*s+e,n=this.rand()*a+i;this.particles.push({x:h,y:n,prevX:h,prevY:n,speed:.2*this.rand()+.1,radius:.5*this.rand()+.5,color:l.randomChoice(this.colors)})}}restart(){super.restart(),this.clear(),this.particles=[],this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height,this.spawnParticles(0,0,this.width,this.height)}resize(){this.clear(),null!==this.imageData&&this.ctx.putImageData(this.imageData,0,0);var t=this.ctx.canvas.width-this.width,e=this.ctx.canvas.height-this.height;0<t&&this.spawnParticles(this.width,0,t,this.height),0<e&&this.spawnParticles(0,this.height,this.width,e),(0<t||0<e)&&this.spawnParticles(this.width,this.height,t,e),this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height;const i=this.width,s=this.height;this.particles=this.particles.filter(function(t){return!(t.x<0||t.x>i||t.y<0||t.y>s)})}getSettings(){return[{prop:"noiseScale",type:"float",step:.001,min:.001,max:.01,toCall:"restart"},{prop:"particlesDensity",type:"float",step:1e-4,min:1e-4,max:.005,toCall:"restart"},{prop:"particlesSpeed",type:"float",min:.25,max:32},{prop:"particlesSize",type:"float",step:.1,min:1,max:4},{prop:"fadingSpeed",type:"float",step:1e-4,min:0,max:.01},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],25:[function(t,e,i){"use strict";var s=t("./animation");const d=t("./utils");class a extends s{constructor(t,e,i,s,a=1,r=.4,h=!1,n=.002,o={x:"random",y:"random",z:1},l=.01,c=!0){super(t,e,i,s,"quadtree visualization","quadtree.js",`
Visualization of quadtree for points generated by thresholding Perlin noise.
Quadtree is a data structure that is 2-dimensional, special variant of k-d trees.

You can read about quadtree on [Wikipedia](https://en.wikipedia.org/wiki/Quadtree).

Coded with no external dependencies, using only canvas API.
`),this.pointsDensity=r,this.drawPoints=h,this.maxPointsInNode=a,this.noiseThreshold=l,this.drawLeafNodes=c,this.noiseScale=n,this.noiseSpeed=o,this.noiseSpeed.x=this.assignIfRandom(this.noiseSpeed.x,d.round(d.randomRange(-1,1),1)),this.noiseSpeed.y=this.assignIfRandom(this.noiseSpeed.y,d.round(d.randomRange(-1,1),1)),this.minNodeSize=4,this.width=0,this.height=0,this.noisePos={x:0,y:0,z:0}}update(t){this.noisePos.x+=this.noiseSpeed.x*t/1e3*10,this.noisePos.y+=this.noiseSpeed.y*t/1e3*10,this.noisePos.z+=this.noiseSpeed.z*t/1e3*.05,super.update(t)}generatePoints(){var i=[],s=1/this.pointsDensity,a=s/2,r=d.Mulberry32(this.seed);for(let e=a;e<this.width;e+=s)for(let t=a;t<this.height;t+=s){var h=this.noise.perlin3((e+this.noisePos.x)*this.noiseScale,(t+this.noisePos.y)*this.noiseScale,this.noisePos.z);Math.abs(h)<=this.noiseThreshold&&i.push({x:e-a+r()*s,y:t-a+r()*s})}return i}quadTree(t,e,i,s,a){var r=i/2,h=i/4;if(s.length<=this.maxPointsInNode||i<=this.minNodeSize)(i>this.minNodeSize||this.drawLeafNodes)&&this.ctx.strokeRect(t-r,e-r,i,i);else{var n,o=[],l=[],c=[],d=[];for(n of s)n.x<t&&n.y>=e?o.push(n):n.x>=t&&n.y>=e?l.push(n):n.x>=t&&n.y<e?d.push(n):n.x<t&&n.y<e&&c.push(n);this.quadTree(t+h,e+h,r,l,++a),this.quadTree(t+h,e-h,r,d,a),this.quadTree(t-h,e+h,r,o,a),this.quadTree(t-h,e-h,r,c,a)}}draw(){this.clear(),this.width=this.ctx.canvas.width,this.height=this.ctx.canvas.height;var t=Math.max(this.width,this.height),e=this.generatePoints();if(this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0],this.quadTree(this.width/2,this.height/2,t,e,0),this.drawPoints)if(this.ctx.fillStyle=this.colorsAlt[1],this.pointsDensity<.5)for(var i of e)d.fillCircle(this.ctx,i.x,i.y,2,this.colorsAlt[1]);else for(var s of e)this.ctx.fillRect(s.x,s.y,2,2)}restart(){this.noisePos={x:0,y:0,z:0},super.restart()}getSettings(){return[{prop:"maxPointsInNode",type:"int",min:1,max:16},{prop:"pointsDensity",type:"float",step:.1,min:.1,max:.7},{prop:"noiseScale",type:"float",step:1e-4,min:5e-4,max:.0125},{prop:"noiseSpeed.x",type:"float",step:.1,min:-10,max:10},{prop:"noiseSpeed.y",type:"float",step:.1,min:-10,max:10},{prop:"noiseSpeed.z",type:"float",step:.1,min:-10,max:10},{prop:"noiseThreshold",type:"float",min:0,max:.15,step:.001},{prop:"drawLeafNodes",type:"bool"},{prop:"drawPoints",type:"bool"},this.getSeedSettings()]}}e.exports=a},{"./animation":3,"./utils":36}],26:[function(t,e,i){"use strict";e.exports=class{constructor(t=32,e=!1,i=function(t,e){return t.value<e.value}){this.array=new Array(t),this.elemComperator=i,this.priorityQueue=e,this.first=0,this.size=0}getArrayIdx(t){return(this.first+t)%this.array.length}push(t){if(this.size>=this.array.length){var e=new Array(2*this.size);for(let t=0;t<this.size;t++)e[t]=this.array[(this.first+t)%this.size];this.first=0,this.array=e}if(this.array[this.getArrayIdx(this.size)]=t,++this.size,this.priorityQueue&&1<this.size)for(let t=this.size-1;0<t;--t){var i=this.getArrayIdx(t),s=this.getArrayIdx(t-1);if(!this.elemComperator(this.array[i],this.array[s]))break;[this.array[i],this.array[s]]=[this.array[s],this.array[i]]}}pop(){if(0===this.size)return null;this.size--;var t=this.array[this.first];return this.first=(this.first+1)%this.array.length,t}clear(){this.size=0,this.first=0}size(){return this.size}}},{}],27:[function(t,e,i){"use strict";var s=t("./animation");const a=t("./animation-queue"),m=t("./utils");class h{constructor(t,e){this.depth=null,this.rand=e,this.animQueue=new a,this.children=[],this.positions={0:{x:0,y:0,from:[1,2]},1:{x:1,y:0,from:[0,3]},2:{x:0,y:1,from:[0,3]},3:{x:1,y:1,from:[1,2]}},this.setDepth(t)}update(t){if(0!==this.children.length){for(var e of this.children)e.object.update(t);for(;0<this.animQueue.step(t);){var s,a,r=new Set;for(s of this.children)r.add(s.position);const h=new Set([0,1,2,3]),n=m.setsDifference(h,r).values().next().value,o=this.positions[n],l=m.randomChoice(o.from,this.rand);let i=null;for(a of this.children)if(a.position==l){i=a;break}const c=this.positions[i.position],d=this.depth/2,p=(i.position=n,m.easeInOutSine);this.animQueue.push(function(t){var e=Math.min(t,d)/d;return i.x=m.lerp(c.x,o.x,p(e)),i.y=m.lerp(c.y,o.y,p(e)),t-d})}}}setDepth(t){if(0===t&&this.children.length)this.children=[],this.animQueue.clear();else if(0<t)if(0===this.children.length){this.children=[{object:new h(t-1,this.rand),position:0},{object:new h(t-1,this.rand),position:1},{object:new h(t-1,this.rand),position:2}];for(var e of this.children)e.x=this.positions[e.position].x,e.y=this.positions[e.position].y}else for(var i of this.children)i.object.setDepth(t-1);this.depth=t}draw(t,e){var i=e/2;if(0===this.children.length)t.strokeRect(-.5*e,-.5*e,i,i),t.strokeRect(0,-.5*e,i,i),t.strokeRect(-.5*e,0,i,i),t.strokeRect(0,0,i,i);else{t.strokeRect(-.5*e,-.5*e,e,e);for(var s of this.children)t.save(),t.translate((-.5+s.x)*i,(-.5+s.y)*i),s.object.draw(t,i),t.restore()}}}class r extends s{constructor(t,e,i,s,a=7,r=1){super(t,e,i,s,"recursive rectangles","recursion-rectangles.js",`
Simple recursive animation. 
Each rectangle contains three smaller rectangles, which move around.
One randomly chosen rectangle is always moving to the empty space.

Coded with no external dependencies, using only canvas API.
`),this.depth=a,this.speed=r,this.object=new h(this.depth,this.rand)}update(t){t=t/1e3*this.speed,this.object.update(t)}draw(){this.clear();var t=Math.max(this.ctx.canvas.width,this.ctx.canvas.height);this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0],this.ctx.fillStyle=this.colors[0],this.ctx.translate(t/2,t/2),this.object.draw(this.ctx,t),this.ctx.resetTransform()}updateDepth(){this.object.setDepth(this.depth)}getSettings(){return[{prop:"depth",type:"int",min:3,max:9,toCall:"updateDepth"},{prop:"speed",type:"float",step:.25,min:.5,max:8},this.getSeedSettings()]}}e.exports=r},{"./animation":3,"./animation-queue":2,"./utils":36}],28:[function(t,e,i){"use strict";var s=t("./grid");const a=t("./utils");class r extends s{constructor(t,e,i,s,a=9,r=3,h=3){super(t,e,i,s,"rock-paper-scissors automata","rock-paper-scissors-automata.js",`
Rock-paper-scissors automata.

This cellular automata adapts the rules of the rock-paper-scissors game 
(one type beats one state but loses to another).
If the cell has more than a defined number of neighbors with the state it losses to, 
it changes its state to that state.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.states=r,this.minimumLosses=h}update(t){super.update(t);for(let e=0;e<this.gridWidth;++e)for(let t=0;t<this.gridHeight;++t){var i=this.getIdx(e,t),s=this.grid[i],a=(s+1)%this.states,r=Array(this.states).fill(0);++r[this.getValWrap(e-1,t-1)],++r[this.getValWrap(e,t-1)],++r[this.getValWrap(e+1,t-1)],++r[this.getValWrap(e-1,t)],++r[this.getValWrap(e+1,t)],++r[this.getValWrap(e-1,t+1)],++r[this.getValWrap(e,t+1)],++r[this.getValWrap(e+1,t+1)],r[a]>=this.minimumLosses?this.gridNext[i]=a:this.gridNext[i]=s}[this.grid,this.gridNext]=[this.gridNext,this.grid]}draw(){a.clear(this.ctx,this.colors[0]);for(let e=0;e<this.gridWidth;++e)for(let t=0;t<this.gridHeight;++t){var i=this.getVal(e,t);i&&(this.ctx.fillStyle=this.colors[i],this.ctx.fillRect(e*this.cellSize,t*this.cellSize,this.cellSize,this.cellSize))}}newCellState(t,e){return a.randomInt(0,this.states,this.rand)}resize(){var t=Math.ceil(this.ctx.canvas.width/this.cellSize),e=Math.ceil(this.ctx.canvas.height/this.cellSize);this.resizeGrid(t,e)}getSettings(){return[{prop:"cellSize",type:"int",min:4,max:12,toCall:"resize"},{prop:"states",type:"int",min:2,max:6,toCall:"restart"},{prop:"minimumLosses",type:"int",min:0,max:8},this.getSeedSettings()]}}e.exports=r},{"./grid":13,"./utils":36}],29:[function(t,e,i){"use strict";var s=t("./grid");const p=t("./utils");class a extends s{constructor(t,e,i,s,a=5,r=!0,h=5){super(t,e,i,s,"sand automata","sand-automata.js",`
Sand automata.

This cellular automata is a simple model of falling sand.
It generates random tetris blocks and lets them fall to demonstrate
the properties of automata.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.spawnTetrisBlocks=r,this.tetrisBlocksSize=h,this.maxBlockSize=12,this.updateOrder=null,this.fullRows=0,this.mouseDown=!1,this.mouseCellCord=0,this.mouseValue=0,this.blocksTemplates=[["XXXX"],["X","X","X","X"],["XX "," XX"],["X ","XX"," X"],[" XX","XX "],[" X","XX","X "],["XX","XX"],["XX","XX"],["XXX"," X "],[" X ","XXX"],["X ","XX","X "],[" X","XX"," X"],["XXX","  X"],["X  ","XXX"],["XX","X ","X "],[" X"," X","XX"],["XXX","X  "],["  X","XXX"],["X ","X ","XX"],["XX"," X"," X"]],this.generateBlocks()}generateBlocks(){this.blocks=[];for(var e of this.blocksTemplates){var s=[];for(let t=0;t<e.length*this.tetrisBlocksSize;++t)s.push([]);for(let i=0;i<e.length;++i)for(let t=0;t<e[i].length;++t){var a="X"==e[i][t];for(let e=0;e<this.tetrisBlocksSize;++e)for(let t=0;t<this.tetrisBlocksSize;++t)s[i*this.tetrisBlocksSize+e].push(a)}this.blocks.push(s)}}update(t){if(super.update(t),this.frame%30==0&&this.spawnTetrisBlocks){var i=p.randomChoice(this.blocks,this.rand),s=p.randomInt(0,this.gridWidth-i[0].length,this.rand),a=p.randomInt(0,this.colors.length,this.rand)+1;for(let e=0;e<i[0].length;++e)for(let t=0;t<i.length;++t){var r=this.getIdx(s+e,t),h=i[t][e];this.grid[r]=h*a-1}}this.mouseDown&&(this.grid[this.mouseCellCord]=this.mouseValue);let n=!(this.fullRows=0);for(let t=0;t<this.gridWidth;++t)if(this.getVal(t,this.gridHeight-1)<0){n=!1;break}n&&++this.fullRows;for(let e=this.gridHeight-2;0<=e;--e){n=!0,p.randomShuffle(this.updateOrder,this.rand);for(let t=0;t<this.gridWidth;++t){var o,l=this.updateOrder[t],c=this.getIdx(l,e),d=this.grid[c];d<0?n=!1:(o=this.getIdx(l,e+1),this.grid[o]<0?(this.grid[c]=-1,this.grid[o]=d):(o=this.getIdxWrap(l-1,e+1),this.grid[o]<0?(this.grid[c]=-1,this.grid[o]=d):(o=this.getIdxWrap(l+1,e+1),this.grid[o]<0&&(this.grid[c]=-1,this.grid[o]=d))))}n&&++this.fullRows}}draw(){this.ctx.fillStyle=this.bgColor,this.ctx.fillRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height-(this.fullRows-1)*this.cellSize);for(let e=0;e<this.gridWidth;++e)for(let t=4*this.tetrisBlocksSize;t<this.gridHeight-(this.fullRows-1);++t){var i=this.getVal(e,t),s=t-4*this.maxBlockSize;0<=i&&(this.ctx.fillStyle=this.colors[i],this.ctx.fillRect(e*this.cellSize,s*this.cellSize,this.cellSize,this.cellSize))}}resize(){var i=Math.ceil(this.ctx.canvas.width/this.cellSize),t=Math.ceil(this.ctx.canvas.height/this.cellSize)+4*this.maxBlockSize,s=new Array(i*t),a=(s.fill(-1),Math.min(this.gridHeight,t)),r=Math.min(this.gridWidth,i);for(let e=0;e<a;++e)for(let t=0;t<r;++t)s[t+e*i]=this.grid[this.getIdx(t,e)];delete this.grid,this.grid=s,this.gridWidth=i,this.gridHeight=t,this.updateOrder=new Array(this.gridWidth);for(let t=0;t<this.gridWidth;++t)this.updateOrder[t]=t;this.clear()}mouseAction(t,e){"down"===e?(this.mouseDown=!0,this.mouseValue=this.mouseValue%this.colors.length+1):"up"===e&&(this.mouseDown=!1),("down"===e||"move"===e&&this.mouseDown)&&(e=Math.floor(t.x/this.cellSize),t=Math.floor(t.y/this.cellSize),this.mouseCellCord=e+(t+4*this.maxBlockSize)*this.gridWidth,this.grid[this.mouseCellCord]!==this.mouseValue)&&(this.grid[this.mouseCellCord]=this.mouseValue,this.draw())}getSettings(){return[{prop:"cellSize",type:"int",min:2,max:12,toCall:"resize"},{prop:"spawnTetrisBlocks",type:"bool"},{prop:"tetrisBlocksSize",type:"int",min:1,max:this.maxBlockSize,toCall:"generateBlocks"},{prop:"spawnASand",type:"text",value:"<click/touch>"},this.getSeedSettings()]}}e.exports=a},{"./grid":13,"./utils":36}],30:[function(t,e,i){"use strict";var s=t("./animation");const d=t("./utils"),a=t("./queue");class r extends s{constructor(t,e,i,s,a=12,r="A*",h="random",n=1,o=!0,l="random",c=!1){super(t,e,i,s,"finding the shortest path","shortest-path.js",`
Animation showing the process of finding the shortest path
in the grid world by BFS or A* algorithm.

In the 8-way variant, horizontal or vertical moves have a length (cost) of 1 
while diagonal moves have a length of sqrt(2).

The map is generated by recursively dividing rectangular rooms.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.speed=n,this.startNewAfterFinish=o,this.showStats=c,this.searchAlgorithms=["BFS","A*"],this.searchAlgorithm=this.assignIfRandom(r,d.randomChoice(this.searchAlgorithms)),this.movementTypes=["4-dir","8-dir"],this.movementType=this.assignIfRandom(h,d.randomChoice(this.movementTypes)),this.cellStyles=["sharp","rounded"],this.cellStyle=this.assignIfRandom(l,d.randomChoice(this.cellStyles)),this.updateName(),this.queue=null,this.visited=0,this.mapWidth=0,this.mapHeight=0,this.map=null,this.dist=null,this.prev=null,this.pathLenght=0}updateName(){this.name=`finding the shortest path using ${this.searchAlgorithm} algorithm`}getIdx(t,e){return t+e*this.mapWidth}getXY(t){return d.createVec2d(t%this.mapWidth,Math.floor(t/this.mapWidth))}isWall(t,e){return t<0||t>=this.mapWidth||e<0||e>=this.mapHeight||1===this.map[this.getIdx(t,e)]}minDistance(t,e){var i=Math.abs(t.x-e.x),t=Math.abs(t.y-e.y);return"4-dir"===this.movementType?i+t:"8-dir"===this.movementType?(e=Math.min(i,t))*Math.sqrt(2)+i+t-2*e:0}expandNextNode(){var e=this.queue.pop();if(null!==e){++this.visited;var i,s=e.key,a=this.getXY(s),e=this.map[s];this.pathLenght=Math.max(this.pathLenght,this.dist[s]);let t=[];if("4-dir"===this.movementType&&(t=[this.getIdx(a.x-1,a.y),this.getIdx(a.x,a.y-1),this.getIdx(a.x+1,a.y),this.getIdx(a.x,a.y+1)]),"8-dir"===this.movementType&&(t=[this.getIdx(a.x-1,a.y),this.getIdx(a.x-1,a.y-1),this.getIdx(a.x,a.y-1),this.getIdx(a.x+1,a.y-1),this.getIdx(a.x+1,a.y),this.getIdx(a.x+1,a.y+1),this.getIdx(a.x,a.y+1),this.getIdx(a.x-1,a.y+1)]),2!==e&&3!==e)this.map[s]=5;else if(3===e){let t=this.prev[s];for(;0<=this.prev[t];)this.map[t]=6,t=this.prev[t];return this.pathLenght=this.dist[s],void this.queue.clear()}for(i of t){var r,h=this.map[i],n=this.getXY(i),o=this.dist[s]+this.minDistance(a,n);1!==h&&o<this.dist[i]&&("BFS"===this.searchAlgorithm?this.queue.push({key:i,value:o}):"A*"===this.searchAlgorithm&&(r=this.getXY(this.goalIdx),n=this.minDistance(n,r),this.queue.push({key:i,value:o+n})),3!==h&&(this.map[i]=4),this.dist[i]=o,this.prev[i]=s)}}}update(t){for(let t=0;t<this.speed;++t)this.expandNextNode(),++this.frame;this.startNewAfterFinish&&this.frame>=this.visited+300&&this.setupMaze()}drawWallCell(t,e,i){var s,a,r,h,n,o,l;"sharp"===this.cellStyle?(s=this.isWall(t-1,e)?0:i,a=this.isWall(t+1,e)?0:i,r=this.isWall(t,e-1)?0:i,h=this.isWall(t,e+1)?0:i,this.ctx.fillRect(t*this.cellSize+s,e*this.cellSize+r,this.cellSize-s-a,this.cellSize-r-h)):"rounded"===this.cellStyle&&(this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,e*this.cellSize+this.cellSize/2,this.cellSize/2-i,0,2*Math.PI,!1),this.ctx.fill(),s=this.cellSize/2,a=t*this.cellSize,r=e*this.cellSize,h=(t+.5)*this.cellSize,n=(e+.5)*this.cellSize,o=(t+1)*this.cellSize,l=(e+1)*this.cellSize,this.isWall(t-1,e)&&this.ctx.fillRect(a,r+i,s,this.cellSize-2*i),this.isWall(t+1,e)&&this.ctx.fillRect(h,r+i,s,this.cellSize-2*i),this.isWall(t,e-1)&&this.ctx.fillRect(a+i,r,this.cellSize-2*i,s),this.isWall(t,e+1)&&this.ctx.fillRect(a+i,n,this.cellSize-2*i,s),this.isWall(t-1,e)&&this.isWall(t,e-1)&&(this.ctx.beginPath(),this.isWall(t-1,e-1)?this.ctx.rect(a,r,i,i):(this.ctx.arc(a,r,i,0,Math.PI/2,!1),this.ctx.lineTo(a+i,r+i),this.ctx.lineTo(a+i,r)),this.ctx.fill()),this.isWall(t-1,e)&&this.isWall(t,e+1)&&(this.ctx.beginPath(),this.isWall(t-1,e+1)?this.ctx.rect(a,l-i,i,i):(this.ctx.arc(a,l,i,1.5*Math.PI,0,!1),this.ctx.lineTo(a+i,l-i),this.ctx.lineTo(a,l-i)),this.ctx.fill()),this.isWall(t+1,e)&&this.isWall(t,e-1)&&(this.ctx.beginPath(),this.isWall(t+1,e-1)?this.ctx.rect(o-i,r,i,i):(this.ctx.arc(o,r,i,Math.PI/2,Math.PI,!1),this.ctx.lineTo(o-i,r+i),this.ctx.lineTo(o,r+i)),this.ctx.fill()),this.isWall(t+1,e))&&this.isWall(t,e+1)&&(this.ctx.beginPath(),this.isWall(t+1,e+1)?this.ctx.rect(o-i,l-i,i,i):(this.ctx.arc(o,l,i,Math.PI,1.5*Math.PI,!1),this.ctx.lineTo(o-i,l-i),this.ctx.lineTo(o-i,l)),this.ctx.fill())}drawNodeCell(t,e,i){var s;"sharp"===this.cellStyle?this.ctx.fillRect(t*this.cellSize+i,e*this.cellSize+i,this.cellSize-2*i,this.cellSize-2*i):"rounded"===this.cellStyle&&(this.ctx.beginPath(),this.ctx.arc(t*this.cellSize+this.cellSize/2,e*this.cellSize+this.cellSize/2,this.cellSize/2-i,0,2*Math.PI,!1),this.ctx.fill()),this.debug&&(this.ctx.fillStyle="black",i=this.getXY(this.goalIdx),i=d.round(this.minDistance({x:t,y:e},i),1),s=d.round(this.dist[this.getIdx(t,e)],1),this.ctx.fillText(s+"+"+i,t*this.cellSize,e*this.cellSize),this.ctx.fillText("="+d.round(s+i),t*this.cellSize,e*this.cellSize+20))}drawNodeConnection(t){var e=this.getXY(t),t=this.getXY(this.prev[t]);this.ctx.beginPath(),this.ctx.moveTo((e.x+.5)*this.cellSize,(e.y+.5)*this.cellSize),this.ctx.lineTo((t.x+.5)*this.cellSize,(t.y+.5)*this.cellSize),this.ctx.stroke()}draw(){this.clear(),this.ctx.translate(-(this.mapWidth*this.cellSize-this.ctx.canvas.width)/2,-(this.mapHeight*this.cellSize-this.ctx.canvas.height)/2);for(let e=0;e<this.mapHeight;++e)for(let t=0;t<this.mapWidth;++t){var i=this.getIdx(t,e),s=this.map[i];0<=[4,5,6,3].indexOf(s)&&0<=this.prev[i]&&(4===s?this.ctx.strokeStyle=this.colors[2]:5===s?this.ctx.strokeStyle=this.colors[1]:6!==s&&3!==s||(this.ctx.strokeStyle=this.colorsAlt[2]),this.drawNodeConnection(i))}for(let e=0;e<this.mapHeight;++e)for(let t=0;t<this.mapWidth;++t){var a=this.getIdx(t,e),a=this.map[a];1===a?(this.ctx.fillStyle=this.colors[0],this.drawWallCell(t,e,this.cellSize/6)):2===a?(this.ctx.fillStyle=this.colorsAlt[0],this.drawNodeCell(t,e,1)):3===a?(this.ctx.fillStyle=this.colorsAlt[1],this.drawNodeCell(t,e,1)):4===a?(this.ctx.fillStyle=this.colors[2],this.drawNodeCell(t,e,this.cellSize/3)):5===a?(this.ctx.fillStyle=this.colors[1],this.drawNodeCell(t,e,this.cellSize/4)):6===a&&(this.ctx.fillStyle=this.colorsAlt[2],this.drawNodeCell(t,e,this.cellSize/6))}var t;this.ctx.resetTransform(),this.showStats&&(this.resetFont(),t=["Search algorithm: "+this.searchAlgorithm,"Number of visited nodes: "+this.visited,(0===this.queue.size?"Shortest path length: ":"Longest traveled path: ")+d.round(this.pathLenght)],this.drawTextLines(t,this.lineHeight,this.ctx.canvas.height-(t.length+1)*this.lineHeight))}recursiveMaze(e,i,s,a){var t=Math.floor(3),r=1-s/this.mapWidth,h=e+s,n=i+a,o=9<=s&&this.rand()>r*a/s,r=9<=a&&this.rand()>r;let l,c;if(o)for(;l=e+d.randomInt(t,s-t,this.rand),1!==this.map[this.getIdx(l,i-1)]||this.map[1!==this.getIdx(l,n)];);else l=e-1;if(r)for(;c=i+d.randomInt(t,a-t,this.rand),1!==this.map[this.getIdx(e-1,c)]||1!==this.map[this.getIdx(h,c)];);else c=n;if(o){for(let t=0;t<a;++t)this.map[this.getIdx(l,i+t)]=1;this.map[this.getIdx(l,d.randomInt(i,c,this.rand))]=0,r&&(this.map[this.getIdx(l,d.randomInt(c+1,n,this.rand))]=0),this.recursiveMaze(e,i,l-e,c-i),this.recursiveMaze(l+1,i,h-l-1,c-i)}if(r){for(let t=0;t<s;++t)this.map[this.getIdx(e+t,c)]=1;o&&(this.map[this.getIdx(d.randomInt(e,l,this.rand),c)]=0),this.map[this.getIdx(d.randomInt(l+1,h,this.rand),c)]=0,this.recursiveMaze(e,c+1,l-e,n-c-1),this.recursiveMaze(l+1,c+1,h-l-1,n-c-1)}}setupMaze(){this.mapWidth=Math.ceil(this.ctx.canvas.width/this.cellSize),this.mapHeight=Math.ceil(this.ctx.canvas.height/this.cellSize),this.mapSize=this.mapWidth*this.mapHeight,this.map=new Array(this.mapSize),this.dist=new Array(this.mapSize),this.prev=new Array(this.mapSize);for(let e=0;e<this.mapHeight;++e)for(let t=0;t<this.mapWidth;++t){var i=this.getIdx(t,e);0===t||t===this.mapWidth-1||0===e||e===this.mapHeight-1?this.map[i]=1:this.map[i]=0,this.dist[i]=999999,this.prev[i]=-1}for(this.recursiveMaze(1,1,this.mapWidth-2,this.mapHeight-2),this.startIdx=0,this.goalIdx=0;1===this.map[this.startIdx];)this.startIdx=this.getIdx(d.randomInt(1,this.mapWidth-1,this.rand),d.randomInt(1,this.mapHeight-1,this.rand));for(var t=this.getXY(this.startIdx),e=(this.mapHeight+this.mapWidth)/6;1===this.map[this.goalIdx]||this.minDistance(this.getXY(this.goalIdx),t)<e;)this.goalIdx=this.getIdx(d.randomInt(1,this.mapWidth-1,this.rand),d.randomInt(1,this.mapHeight-1,this.rand));this.setupStart()}resetMaze(){for(let e=0;e<this.mapHeight;++e)for(let t=0;t<this.mapWidth;++t){var i=this.getIdx(t,e);1!==this.map[i]&&(this.map[i]=0,this.dist[i]=999999,this.prev[i]=-1)}this.setupStart()}setupStart(){this.frame=0,this.visited=0,this.pathLenght=0,this.map[this.startIdx]=2,this.dist[this.startIdx]=0,this.map[this.goalIdx]=3,this.priorityQueue="A*"===this.searchAlgorithm,this.queue=new a(this.mapSize,this.priorityQueue),this.queue.push({key:this.startIdx,value:0}),this.updateName()}resize(){this.setSeed(this.seed),this.setupMaze()}restart(){this.resetMaze(),super.restart()}getSettings(){return[{prop:"searchAlgorithm",type:"select",values:this.searchAlgorithms,toCall:"restart"},{prop:"movementType",type:"select",values:this.movementTypes,toCall:"restart"},{prop:"cellSize",type:"int",min:8,max:48,toCall:"resize"},{prop:"speed",type:"int",min:1,max:64},{prop:"startNewAfterFinish",type:"bool"},{prop:"cellStyle",type:"select",values:this.cellStyles},{prop:"showStats",type:"bool"},this.getSeedSettings("resize")]}}e.exports=r},{"./animation":3,"./queue":26,"./utils":36}],31:[function(t,e,i){"use strict";var s=t("./animation");const a=t("./utils");class r extends s{constructor(t,e,i,s,a=48,r=12,h=!1){super(t,e,i,s,"grid of sine waves","sine-waves.js",`
Grid of random sine waves.
The interesting "effects" for some waves is the artifact of drawing procedure
that draw lines between coordinates that are evenly distributed on the x-axis.

Coded with no external dependencies, using only canvas API.
`),this.cellSize=a,this.cellMargin=r,this.rotateCells=h,this.speed=.5,this.gridWidth=0,this.gridHeight=0,this.waves=[]}drawWave(e,i,s,a,r){this.ctx.beginPath(),this.ctx.moveTo(e-this.cellSize/2,i+Math.sin(r)*a);for(let t=0;t<this.cellSize;++t)this.ctx.lineTo(e-this.cellSize/2+t,i+Math.sin(t/this.cellSize*2*Math.PI*s+r)*a);this.ctx.stroke()}draw(){this.clear(),this.ctx.lineWidth=1,this.ctx.strokeStyle=this.colors[0];var e=this.gridCellsWidth*this.gridCellsHeight;this.rotateCells||this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2);for(let t=0;t<e;++t){var i=this.cellMargin+t%this.gridCellsWidth*this.cellTotalSize-this.gridWidth/2+this.cellSize/2,s=this.cellMargin+Math.floor(t/this.gridCellsWidth)*this.cellTotalSize-this.gridHeight/2+this.cellSize/2,a=this.waves[t];this.ctx.strokeStyle=a.color,this.rotateCells?(this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),this.ctx.translate(i,s),this.ctx.rotate(2*a.rotation*Math.PI),this.drawWave(0,0,a.freq,this.cellSize*a.noise*.5,a.noise*Math.PI+this.time*Math.PI),this.ctx.resetTransform()):this.drawWave(i,s,a.freq,this.cellSize*a.noise*.5,a.noise*Math.PI+this.time*Math.PI)}this.rotateCells||this.ctx.resetTransform()}resize(){this.cellTotalSize=this.cellMargin+this.cellSize,this.gridCellsWidth=Math.floor((this.ctx.canvas.width-this.cellMargin)/this.cellTotalSize),this.gridCellsHeight=Math.floor((this.ctx.canvas.height-this.cellMargin)/this.cellTotalSize),this.gridWidth=this.cellMargin+this.gridCellsWidth*this.cellTotalSize,this.gridHeight=this.cellMargin+this.gridCellsHeight*this.cellTotalSize;var e=Math.max(0,this.gridWidth*this.gridHeight-this.waves.length);for(let t=0;t<e;++t)this.waves.push({freq:Math.pow(2,8*this.rand())*a.randomChoice([-1,1],this.rand),noise:this.rand(),rotation:this.rand(),color:a.randomChoice(this.colors,this.rand)})}restart(){this.waves=[],this.gridWidth=0,this.gridHeight=0,super.restart()}getSettings(){return[{prop:"cellSize",type:"int",min:16,max:256,toCall:"resize"},{prop:"cellMargin",type:"int",min:8,max:32,toCall:"resize"},{prop:"rotateCells",type:"bool"},{prop:"speed",type:"float",step:.1,min:-4,max:4},this.getSeedSettings()]}}e.exports=r},{"./animation":3,"./utils":36}],32:[function(t,e,i){"use strict";var s=t("./animation");const r=t("./animation-queue"),u=t("./utils");class a{constructor(t,e){this.arr=t,this.moves=[],this.cmpCount=0,this.name=e,this.sort()}getName(){return this.name}comp(t,e,i){return e!==i&&(++this.cmpCount,this.moves.push(["cmp",t[e],t[i]])),t[e].val-t[i].val}compVal(t,e){return t!==e&&(++this.cmpCount,this.moves.push(["cmp",t,e])),t.val-e.val}swap(t,e,i){this.moves.push(["swap",[t[e],t[i]],[t[i],t[e]]]);var s=t[e];t[e]=t[i],t[i]=s}rearrange(e,i,s){var a=[],r=[];for(let t=0;t<i.length;++t)a.push(this.arr[i[t]]),r.push(this.arr[s[t]]);for(let t=0;t<i.length;++t)e[i[t]]=r[t];this.moves.push(["swap",r,a])}sort(){}getMoves(){return this.moves}}class d extends a{constructor(t){super(t,"bubble sort")}sort(){var s=this.arr.length;for(let i=0;i<s;++i){let e=!0;for(let t=0;t<s-1-i;++t)0<this.comp(this.arr,t,t+1)&&(this.swap(this.arr,t,t+1),e=!1);if(e)break}}}class p extends a{constructor(t){super(t,"selection sort")}sort(){var s=this.arr.length;for(let i=0;i<s;++i){let e=i;for(let t=i;t<s;++t)0<this.comp(this.arr,e,t)&&(e=t);i!==e&&this.swap(this.arr,i,e)}}}class m extends a{constructor(t){super(t,"insertion sort")}sort(){var t=this.arr.length;for(let e=1;e<t;++e){let t=e;for(;0<t&&this.comp(this.arr,t,t-1)<0;)this.swap(this.arr,t,t-1),--t}}}class g extends a{constructor(t){super(t,"merge sort")}sort(){this.mergeSort(0,this.arr.length-1)}mergeSort(t,e){var i;t<e&&(i=Math.floor((t+e)/2),this.mergeSort(t,i),this.mergeSort(i+1,e),this.merge(t,i,e))}merge(t,e,i){let s=t,a=e+1;if(!(this.comp(this.arr,e,a)<=0)){var r=[],h=[];for(let t=s;t<=i;++t)h.push(t);for(;s<=e&&a<=i;)this.comp(this.arr,s,a)<0?r.push(s++):r.push(a++);for(;s<=e;)r.push(s++);for(;a<=i;)r.push(a++);this.rearrange(this.arr,h,r)}}}class f extends a{constructor(t){super(t,"quick sort")}sort(){this.quickSort(0,this.arr.length-1)}quickSort(t,e){var i;1<=e-t&&(t<(i=this.partition(t,e))-1&&this.quickSort(t,i-1),i<e)&&this.quickSort(i,e)}partition(t,e){for(var i=this.arr[Math.floor((e+t)/2)];t<=e;){for(;this.compVal(this.arr[t],i)<0;)++t;for(;0<this.compVal(this.arr[e],i);)--e;t<=e&&this.swap(this.arr,t++,e--)}return t}}class x extends a{constructor(t){super(t,"heap sort")}sort(){for(let t=Math.floor((this.arr.length-1)/2);0<=t;--t)this.heapify(this.arr.length,t);for(let t=this.arr.length-1;0<t;--t)this.swap(this.arr,0,t),this.heapify(t,0)}heapify(t,e){let i=e,s=2*e+1,a=2*e+2;s<t&&0<this.comp(this.arr,s,i)&&(i=s),(i=a<t&&0<this.comp(this.arr,a,i)?a:i)!==e&&(this.swap(this.arr,e,i),this.heapify(t,i))}}class v extends a{constructor(t){super(t,"gnome sort")}sort(){var t=this.arr.length;let e=0;for(;e<t;)0===e||0<=this.comp(this.arr,e,e-1)?++e:(this.swap(this.arr,e,e-1),--e)}}class w extends a{constructor(t){super(t,"shaker sort")}sort(){var s=this.arr.length;for(let i=0;i<s-1;++i){let e=!0;for(let t=0;t<s-1-i;++t)0<this.comp(this.arr,t,t+1)&&(this.swap(this.arr,t,t+1),e=!1);if(e)break;e=!0;for(let t=s-2-i;t>i;--t)this.comp(this.arr,t,t-1)<0&&(this.swap(this.arr,t,t-1),e=!1);if(e)break}}}class h extends s{constructor(t,e,i,s,a="random",r=96,h=2,n=.25,o=.25,l=1,c=!1){super(t,e,i,s,"sorting algorithm visualization","sorting.js",`
Animated visualization of different sorting algorithms.
Like many, sorting algorithms were one of the first things I studied in computer science.
Since then, I have found watching a nice visualization of sorting algorithms quite satisfying.

Coded with no external dependencies, using only canvas API.
`),this.numElements=r,this.elementPadding=h,this.cmpDuration=n,this.swapDuration=o,this.speed=l,this.showStats=c,this.sortAlgoNames=["selection sort","bubble sort","insertion sort","quick sort","merge sort","heap sort","gnome sort","shaker sort"],this.sortAlgoClasses=[p,d,m,f,g,x,v,w],this.sortingAlgorithm=this.assignIfRandom(a,u.randomChoice(this.sortAlgoNames)),this.initialOrderTypes=["random","sorted","reverse sorted","evens then odds"],this.initialOrder="random",this.cmpTotal=0,this.cmpCount=0,this.setup()}setup(){const i=this.numElements;this.animQueue=new r;let e=Array.from({length:i},(t,e)=>e+1);"random"===this.initialOrder?u.randomShuffle(e,this.rand):"reverse sorted"===this.initialOrder?e=e.reverse():"evens then odds"===this.initialOrder&&(e=e.sort((t,e)=>t%2+t/(i+1)-(e%2+e/(i+1)))),this.elements=[];for(let t=0;t<i;++t){var s=e[t]/i,a=u.lerpColor(this.colors[0],this.colors[2],s);this.elements.push({val:s,pos:t,color:a,z:0})}var t=new this.sortAlgoClasses[this.sortAlgoNames.indexOf(this.sortingAlgorithm)](this.elements);this.moves=t.getMoves(),this.name=t.getName()+" algorithm visualization",this.cmpTotal=t.cmpCount,this.cmpCount=0}update(t){for(t=t/1e3*this.speed,this.time+=t,++this.frame;0<this.animQueue.step(t);){if(!this.moves.length)return;var h=this.moves[0];const n=t=>t<.5?u.easeInOutCubic(2*t):1-u.easeInOutCubic(2*t-1),o=u.easeInOutSine;if("cmp"===h[0]){++this.cmpCount;let i=h[1],s=h[2];const a=i.color,r=s.color,l=this.colorsAlt[3],c=this.cmpDuration;this.animQueue.push(function(t){var e=Math.min(t,c)/c;return i.color=u.lerpColor(a,l,n(e)),s.color=u.lerpColor(r,l,n(e)),t-c})}else if("swap"===h[0]){let i=h[1],e=h[2],s=[],a=[],r=[];const d=this.colorsAlt[1],p=this.frame,m=this.swapDuration*i.length;for(let t=0;t<i.length;++t)s.push(i[t].pos),a.push(e[t].pos),r.push(i[t].color);this.animQueue.push(function(t){var e=Math.min(t,m)/m;for(let t=0;t<i.length;++t)i[t].z=p,i[t].color=u.lerpColor(r[t],d,n(e)),i[t].pos=u.lerp(s[t],a[t],o(e));return t-m})}this.moves.shift()}}draw(){this.clear();var t,e,i=this.ctx.canvas.height,s=this.ctx.canvas.width/this.numElements;this.elements=this.elements.sort((t,e)=>t.z-e.z);for(t of this.elements){var a=t.pos*s+this.elementPadding/2,r=t.val*i;this.ctx.fillStyle=t.color,this.ctx.fillRect(a,0,s-this.elementPadding,r)}this.showStats&&(this.resetFont(),e=["Sorting algorithm: "+this.sortingAlgorithm,"Number of elements: "+this.numElements,`Number of elements comparisons: ${this.cmpCount} / `+this.cmpTotal],this.drawTextLines(e,this.lineHeight,this.ctx.canvas.height-(e.length+1)*this.lineHeight))}restart(){super.restart(),this.setup()}getSettings(){return[{prop:"initialOrder",type:"select",values:this.initialOrderTypes,toCall:"setup"},{prop:"sortingAlgorithm",type:"select",values:this.sortAlgoNames,toCall:"setup"},{prop:"numElements",type:"int",min:8,max:256,toCall:"setup"},{prop:"speed",type:"float",step:.25,min:.5,max:8},{prop:"showStats",type:"bool"},this.getSeedSettings()]}}e.exports=h},{"./animation":3,"./animation-queue":2,"./utils":36}],33:[function(t,e,i){"use strict";var s=t("./animation");const d=t("./utils");class a extends s{constructor(t,e,i,s,a=500,r=0,h=!1,n=1,o=1,l="random",c=!1){super(t,e,i,s,"shapes dancing in a circle","spinning-shapes.js",`
Just same shape "dancing" in a circle.
This animation recreates the effect 
described in this [article](https://observablehq.com/@rreusser/instanced-webgl-circles).

Coded with no external dependencies, using only canvas API.
`),this.shapeNames=["circles","points","lines","triangles","rectangles","pentagons","hexagons","heptagons","octagons"],this.vertices=this.assignIfRandom(r,d.randomInt(0,8)),this.updateName(),this.rotateShapes=h,this.shapes=a,this.distanceBase=.6,this.distanceRange=.2,this.sizeBase=.2,this.sizeRange=.12,this.scale=n,this.colorsScale=o,this.colorsShift=this.assignIfRandom(l,d.randomChoice([0,3.14])),this.rainbowColors=c}updateName(){this.name=this.shapeNames[this.vertices]+' "dancing" in a circle'}draw(){this.clear();var e=Math.max(this.ctx.canvas.width,this.ctx.canvas.height)/3*this.scale;this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2);for(let t=0;t<this.shapes;++t){var i=t/this.shapes*2*Math.PI,s=(this.distanceBase+this.distanceRange*Math.cos(6*i+Math.cos(8*i+this.time/2)))*e,a=Math.cos(i)*s,s=Math.sin(i)*s,r=9*i-this.time,h=(this.sizeBase+this.sizeRange*Math.cos(r))*e,r=(Math.cos((r+this.colorsShift)*this.colorsScale)+1)/2;this.rainbowColors?this.ctx.strokeStyle=`hsl(${360*r}, 100%, 75%)`:this.ctx.strokeStyle=d.lerpColor(this.colorA,this.colorB,r),this.ctx.lineWidth=1,this.ctx.beginPath(),0===this.vertices&&d.pathCircle(this.ctx,a,s,h),1===this.vertices?d.pathCircle(this.ctx,a,s,1):d.pathPolygon(this.ctx,a,s,h,this.vertices,i*this.rotateShapes),this.ctx.stroke()}this.ctx.resetTransform()}getSettings(){return[{prop:"vertices",type:"int",min:0,max:8,toCall:"updateName"},{prop:"shapes",type:"int",min:0,max:2500},{prop:"rotateShapes",type:"bool"},{prop:"distanceRange",type:"float",min:0,max:this.distanceBase},{prop:"sizeRange",type:"float",min:0,max:this.sizeBase},{prop:"scale",type:"float",min:.05,max:1.95},{prop:"speed",type:"float",step:.1,min:-4,max:4},{prop:"colorsShift",type:"float",min:0,max:3.14},{prop:"colorsScale",type:"float",min:.05,max:2},{prop:"rainbowColors",type:"bool"}]}}e.exports=a},{"./animation":3,"./utils":36}],34:[function(t,e,i){"use strict";var s=t("./animation");const l=t("./utils");class a extends s{constructor(t,e,i,s,a=4e3,r=2,h="random",n=!0,o=1){super(t,e,i,s,"spirograph","spirograph.js",`
Virtual spirograph created with 2-5 configurable gears.
Spirograph is a drawing toy that use gears to create patterns. I used to play with it a lot as a kid.

You can read about in on
[Wikipedia](https://en.wikipedia.org/wiki/Spirograph).
I also recommend to check this awesome [website] (http://www.eddaardvark.co.uk/v2/spirograph/spirograph2.html),
which is the source of inspiration for this animation.
And also this great [blogpost](https://www.bit-101.com/blog/2022/12/coding-curves-09-roulette-curves/)
that step by step how it works.

Try play with the gears' settings or hit reset button few times 
to get different random configurations.

Coded with no external dependencies, using only canvas API.
`),this.vertices=a,this.lineLength=r,this.maxGears=5,this.rescaleToFit=n,this.scale=o,this.speed=1,this.gearCount=this.assignIfRandom(h,l.randomInt(2,this.maxGears)),this.gearNames=["zero","one","two","three","four","five"],this.updateName(),this.setup()}setup(){this.gears=[];for(let t=0;t<this.maxGears;++t)this.gears.push({radius:l.round(l.randomRange(0,100),2),rate:l.round(l.randomRange(-100,100),2),phase:.005*t})}updateName(){this.name="spirograph with "+this.gearNames[this.gearCount]+" gears"}getXY(e,i,s=1){let a=0,r=0;for(let t=0;t<this.gearCount;++t){var h=this.gears[t];a+=h.radius*s*Math.cos(h.rate*(e+i*h.phase)),r+=h.radius*s*Math.sin(h.rate*(e+i*h.phase))}return{x:a,y:r}}draw(){this.clear();let i=1;if(this.rescaleToFit){let e=0;for(let t=0;t<this.gearCount;++t)e+=this.gears[t].radius;i=Math.min(this.ctx.canvas.width,this.ctx.canvas.height)/2/e}this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2),this.ctx.scale(this.scale,this.scale);var e=Math.PI*this.lineLength/this.vertices;let s=this.getXY(0,this.time,i);for(let t=1;t<this.vertices;++t){var a=this.getXY(t*e,this.time,i),r=l.lerpColor(this.colorA,this.colorB,t/this.vertices);l.drawLine(this.ctx,s.x,s.y,a.x,a.y,1,r),s=a}this.ctx.resetTransform()}getSettings(){let e=[{prop:"vertices",type:"int",min:100,max:32e3},{prop:"lineLength",type:"float",step:.25,min:1,max:16},{prop:"gearCount",type:"int",min:2,max:this.maxGears,toCall:"updateName"},{prop:"rescaleToFit",type:"bool"},{prop:"scale",type:"float",min:.25,max:4},{prop:"speed",type:"float",step:.1,min:-4,max:4}];for(let t=0;t<this.maxGears;++t)e=e.concat([{prop:`gears[${t}].radius`,type:"float",step:.01,min:0,max:100},{prop:`gears[${t}].rate`,type:"float",step:.01,min:-100,max:100},{prop:`gears[${t}].phase`,type:"float",step:.001,min:-.1,max:.1}]);return e}}e.exports=a},{"./animation":3,"./utils":36}],35:[function(t,e,i){"use strict";var s=t("./animation");const l=t("./utils");class a extends s{constructor(t,e,i,s,a=4,r=2,h=6,n=30,o="random"){super(t,e,i,s,"tree visualization","tree-vizualization.js",`
Visualization of the tree using different algorithms.

Coded with no external dependencies, using only canvas API.
`),this.maxDepth=a,this.maxChildren=h,this.minChildren=r,this.radius=n,this.treeAlgoNames=["proportional space","equal space"],this.treeAlgorithm=this.assignIfRandom(o,l.randomChoice(this.treeAlgoNames)),this.nodes=[],this.treeRoot=null,this.restart()}calNodesXY(){}proportionalSpace(){this.treeRoot.theta=90;let e=0,i=[[this.treeRoot]];for(;0<i[e].length;){var s=[];for(let t=0;t<i[e].length;++t){var a=i[e][t];for(let t=0;t<a.children.length;++t){var r=a.children[t];r.theta=a.theta-180/a.parentsChildren+360*(t+.5)/a.children.length/a.parentsChildren,r.parentsChildren=a.parentsChildren*a.children.length,s.push(r)}}++e,i.push(s)}for(var t of this.nodes)t.x=t.depth*this.radius*Math.cos(t.theta*Math.PI/180),t.y=t.depth*this.radius*Math.sin(t.theta*Math.PI/180)}equalSpace(){this.treeRoot.theta=90;let r=0,h=[[this.treeRoot]];for(;0<h[r].length;){let e=[],t=0,s=129600,a=s-1;for(let t=0;t<h[r].length;++t)e.push(...h[r][t].children);if(0==e.length)break;for(let t=0;t<e.length;++t)e[t].theta=360*t/e.length;for(let i=0;i<360;++i){a=0;for(var n of h[r]){let e=0;for(var o of n.children){let t=Math.abs(o.theta+i-o.parent.theta);180<(t%=360)&&(t=360-t),e=Math.max(e,t)}e*=e,a+=e}(a/=h[r].length)<s&&(s=a,t=i)}for(var i of e)i.theta+=t;++r,h.push(e)}for(var t of this.nodes)t.x=t.depth*this.radius*Math.cos(t.theta*Math.PI/180),t.y=t.depth*this.radius*Math.sin(t.theta*Math.PI/180)}plante(){let r=0,i=[[this.treeRoot]];for(;0<i[r].length;){var h=[];for(let e=0;e<i[r].length;++e){let s=i[r][e],a=1,t=s;for(;null!=t.parent;)t=t.parent,a*=t.children.length;for(let i=0;i<s.children.length;++i){let t=s.children[i],e=360*i/(s.children.length-1)/a;0==r&&(e=360*i/s.children.length/a),1==s.children.length?t.theta=s.theta:r<2?t.theta=s.theta-180/a+e:(console.log(i,a,s.theta,e),1==s.children.length?t.theta=s.theta:s.theta<s.parent.theta?t.theta=s.theta+e:s.theta>s.parent.theta?t.theta=s.theta-e:t.theta=s.theta-180/a+e),t.x=s.x+this.radius*Math.cos(t.theta*Math.PI/180),t.y=s.y+this.radius*Math.sin(t.theta*Math.PI/180),h.push(t)}}++r,i.push(h)}}restart(){this.nodes=[],this.treeRoot=this.genNode(null,0),"equal space"==this.treeAlgorithm?this.equalSpace():"proportional space"==this.treeAlgorithm&&this.proportionalSpace()}genNode(t,e){var i={parent:t,children:[],x:0,y:0,theta:0,depth:e,parentsChildren:1};if(this.nodes.push(i),e<this.maxDepth){var s=l.randomInt(this.minChildren,this.maxChildren);for(let t=0;t<s;++t)i.children.push(this.genNode(i,e+1))}return i}draw(){this.clear(),this.ctx.translate(this.ctx.canvas.width/2,this.ctx.canvas.height/2);for(var t of this.nodes){for(var e of t.children)l.drawLine(this.ctx,t.x,t.y,e.x,e.y,1,"#000");l.fillCircle(this.ctx,t.x,t.y,5,this.colors[t.depth])}this.ctx.resetTransform()}getSettings(){return[{prop:"maxDepth",type:"int",min:1,max:6,toCall:"restart"},{prop:"minChildren",type:"int",min:0,max:8,toCall:"restart"},{prop:"maxChildren",type:"int",min:1,max:8,toCall:"restart"},{prop:"radius",type:"int",min:10,max:300,toCall:"restart"},{prop:"treeAlgorithm",type:"select",values:this.treeAlgoNames,toCall:"restart"}]}}e.exports=a},{"./animation":3,"./utils":36}],36:[function(require,module,exports){"use strict";module.exports={Lcg(t){return function(){return(2147483647&(t=0|Math.imul(48271,t)))/2147483648}},Mulberry32(e){return function(){e=(e|=0)+1831565813|0;var t=Math.imul(e^e>>>15,1|e);return(((t=t+Math.imul(t^t>>>7,61|t)^t)^t>>>14)>>>0)/4294967296}},randomRange(t,e,i=Math.random){return i()*(e-t)+t},randomInt(t,e,i=Math.random){return Math.floor(this.randomRange(t,e,i))},randomChoice(t,e=Math.random){return t[Math.floor(e()*t.length)]},randomBoxMuller(t=Math.random){return Math.sqrt(-2*Math.log(1-t()))*Math.cos(2*Math.PI*t())},randomNormal(t,e,i=Math.random){return t+this.randomBoxMuller(i)*e},randomArray(t,e,i,s=Math.random){return Array(t).fill().map(()=>this.randomRange(e,i,s))},randomShuffle(e,i=Math.random){for(let t=e.length-1;0<t;--t){var s=Math.floor(i()*(t+1)),a=e[t];e[t]=e[s],e[s]=a}},randomRulletChoice(t,e=Math.random){let i=0;for(var s in t)i+=t[s];let a=e()*i;for(var r in t)if((a-=t[r])<0)return r},round(t,e=2){e=Math.pow(10,e);return Math.round(t*e)/e},argMax(t){return[].reduce.call(t,(t,e,i,s)=>e>s[t]?i:t,0)},addArrays(t,i){return t.map((t,e)=>t+i[e])},subArrays(t,i){return t.map((t,e)=>t-i[e])},mulArrays(t,i){return t.map((t,e)=>t*i[e])},clip(t,e,i){return Math.max(e,Math.min(i,t))},remap(t,e,i,s,a){return s+(t-e)/(i-e)*(a-s)},sum(t){let e=0;for(var i of t)e+=a;return e},lerp(t,e,i){return(1-i)*t+i*e},lerpColor(t,e,i){var t=parseInt(t.replace("#","0x"),16),s=t>>16,a=t>>8&255,t=255&t,e=parseInt(e.replace("#","0x"),16);return"#"+((1<<24)+(s+i*((e>>16)-s)<<16)+(a+i*((e>>8&255)-a)<<8)+(t+i*((255&e)-t))|0).toString(16).slice(1)},lerpColorsPallet(t,e){var i=1/(t.length-1),s=Math.floor(e/i);return this.lerpColor(t[s%t.length],t[(s+1)%t.length],(e-s*i)/i)},createVec2d(t,e){return{x:t,y:e}},rotateVec2d(t,e){var i=Math.cos(e),e=Math.sin(e),s={...t};return s.x=t.x*i-t.y*e,s.y=t.x*e+t.y*i,s},mulVec2d(t,e){t={...t};return t.x*=e,t.y*=e,t},distVec2d(t,e){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))},linear(t){return t},easeInSine(t){return 1-Math.cos(t*Math.PI/2)},easeOutSine(t){return Math.sin(t*Math.PI/2)},easeInOutSine(t){return-(Math.cos(Math.PI*t)-1)/2},easeInQuad(t){return t*t},easeOutQuad(t){return 1-(1-t)*(1-t)},easeInOutQuad(t){return t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2},easeInCubic(t){return t*t*t},easeOutCubic(t){return 1-Math.pow(1-t,3)},easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2},easeInQuart(t){return t*t*t*t},easeOutQuart(t){return 1-Math.pow(1-t,4)},easeInOutQuart(t){return t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2},clear(t,e){t.fillStyle=e,t.fillRect(0,0,t.canvas.width,t.canvas.height)},pathLine(t,e,i,s,a){t.moveTo(e,i),t.lineTo(s,a)},drawLine(t,e,i,s,a,r=1,h){t.lineWidth=r,void 0!==h&&(t.strokeStyle=h),t.beginPath(),t.moveTo(e,i),t.lineTo(s,a),t.stroke()},pathPolygon(e,i,s,a,r,h=0){var n=2*Math.PI/r;e.moveTo(i+a*Math.cos(h),s+a*Math.sin(h));for(let t=1;t<=r;t++)e.lineTo(i+a*Math.cos(h+t*n),s+a*Math.sin(h+t*n))},pathCircle(t,e,i,s){t.moveTo(e+s,i),t.arc(e,i,s,0,2*Math.PI,!1)},fillCircle(t,e,i,s,a){void 0!==a&&(t.fillStyle=a),t.beginPath(),t.arc(e,i,s,0,2*Math.PI,!1),t.fill()},strokeCircle(t,e,i,s,a){void 0!==(t.strokeStyle=a)&&(t.strokeStyle=a),t.beginPath(),t.arc(e,i,s,0,2*Math.PI,!1),t.stroke()},fillAndStrokeText(t,e,i,s){t.strokeText(e,i,s),t.fillText(e,i,s)},pathShape(e,i){if(i.length)if(i[0].hasOwnProperty("x")&&i[0].hasOwnProperty("y")){e.moveTo(i[0].x,i[0].y);for(let t=1;t<i.length;++t)e.lineTo(i[t].x,i[t].y)}else{e.moveTo(i[0][0],i[0][1]);for(let t=1;t<i.length;++t)e.lineTo(i[t][0],i[t][1])}},pathClosedShape(t,e){e.length&&this.pathShape(t,e.concat([e[0]]))},blendColor(t,e,i=1,s="source-over"){t.save(),t.globalCompositeOperation=s,t.globalAlpha=i,t.fillStyle=e,t.fillRect(0,0,t.canvas.width,t.canvas.height),t.restore()},rgbToHex(t,e,i){return"#"+((1<<24)+(t<<16)+(e<<8)+i).toString(16).slice(1)},createOffscreenCanvas(t,e){var i=document.createElement("canvas");return i.width=t,i.height=e,i},isSuperset(t,e){for(const i of e)if(!t.has(i))return!1;return!0},setsUnion(t,e){var i=new Set(t);for(const s of e)i.add(s);return i},setsIntersection(t,e){var i=new Set;for(const s of e)t.has(s)&&i.add(s);return _intersection},setsSymmetricDifference(t,e){var i=new Set(t);for(const s of e)i.has(s)?i.delete(s):i.add(s);return i},setsDifference(t,e){var i=new Set(t);for(const s of e)i.delete(s);return i},isStrictMode(){return eval("var __temp = null"),"undefined"==typeof __temp?"strict":"non-strict"},getKeys(t){var e,i=[];for(e in t)i.push(e);return i},getValues(t){var e,i=[];for(e in t)i.push(t[e]);return i},addMultipleEventListener(e,t,i){t.forEach(t=>e.addEventListener(t,i))}}},{}]},{},[14]);